
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Agenda
 * 
 */
export type Agenda = $Result.DefaultSelection<Prisma.$AgendaPayload>
/**
 * Model AgendaDay
 * 
 */
export type AgendaDay = $Result.DefaultSelection<Prisma.$AgendaDayPayload>
/**
 * Model AgendaItem
 * 
 */
export type AgendaItem = $Result.DefaultSelection<Prisma.$AgendaItemPayload>
/**
 * Model AgendaItemSpeaker
 * 
 */
export type AgendaItemSpeaker = $Result.DefaultSelection<Prisma.$AgendaItemSpeakerPayload>
/**
 * Model AgendaSession
 * 
 */
export type AgendaSession = $Result.DefaultSelection<Prisma.$AgendaSessionPayload>
/**
 * Model Attendee
 * 
 */
export type Attendee = $Result.DefaultSelection<Prisma.$AttendeePayload>
/**
 * Model Attendees
 * 
 */
export type Attendees = $Result.DefaultSelection<Prisma.$AttendeesPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model ContactRequest
 * 
 */
export type ContactRequest = $Result.DefaultSelection<Prisma.$ContactRequestPayload>
/**
 * Model Delegate
 * 
 */
export type Delegate = $Result.DefaultSelection<Prisma.$DelegatePayload>
/**
 * Model Delegates
 * 
 */
export type Delegates = $Result.DefaultSelection<Prisma.$DelegatesPayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model Enquiry
 * 
 */
export type Enquiry = $Result.DefaultSelection<Prisma.$EnquiryPayload>
/**
 * Model Exhibitor
 * 
 */
export type Exhibitor = $Result.DefaultSelection<Prisma.$ExhibitorPayload>
/**
 * Model Exhibitors
 * 
 */
export type Exhibitors = $Result.DefaultSelection<Prisma.$ExhibitorsPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Marketing
 * 
 */
export type Marketing = $Result.DefaultSelection<Prisma.$MarketingPayload>
/**
 * Model MarketingCampaign
 * 
 */
export type MarketingCampaign = $Result.DefaultSelection<Prisma.$MarketingCampaignPayload>
/**
 * Model MediaPartner
 * 
 */
export type MediaPartner = $Result.DefaultSelection<Prisma.$MediaPartnerPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model Partners
 * 
 */
export type Partners = $Result.DefaultSelection<Prisma.$PartnersPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectStats
 * 
 */
export type ProjectStats = $Result.DefaultSelection<Prisma.$ProjectStatsPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Speaker
 * 
 */
export type Speaker = $Result.DefaultSelection<Prisma.$SpeakerPayload>
/**
 * Model SpeakerSession
 * 
 */
export type SpeakerSession = $Result.DefaultSelection<Prisma.$SpeakerSessionPayload>
/**
 * Model Speakers
 * 
 */
export type Speakers = $Result.DefaultSelection<Prisma.$SpeakersPayload>
/**
 * Model Sponsor
 * 
 */
export type Sponsor = $Result.DefaultSelection<Prisma.$SponsorPayload>
/**
 * Model Sponsors
 * 
 */
export type Sponsors = $Result.DefaultSelection<Prisma.$SponsorsPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model Ticketing
 * 
 */
export type Ticketing = $Result.DefaultSelection<Prisma.$TicketingPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UtmData
 * 
 */
export type UtmData = $Result.DefaultSelection<Prisma.$UtmDataPayload>
/**
 * Model agendadays
 * 
 */
export type agendadays = $Result.DefaultSelection<Prisma.$agendadaysPayload>
/**
 * Model agendaitems
 * 
 */
export type agendaitems = $Result.DefaultSelection<Prisma.$agendaitemsPayload>
/**
 * Model agendaitemspeakers
 * 
 */
export type agendaitemspeakers = $Result.DefaultSelection<Prisma.$agendaitemspeakersPayload>
/**
 * Model agendasessions
 * 
 */
export type agendasessions = $Result.DefaultSelection<Prisma.$agendasessionsPayload>
/**
 * Model exhibitors
 * 
 */
export type exhibitors = $Result.DefaultSelection<Prisma.$exhibitorsPayload>
/**
 * Model projects
 * 
 */
export type projects = $Result.DefaultSelection<Prisma.$projectsPayload>
/**
 * Model speakers
 * 
 */
export type speakers = $Result.DefaultSelection<Prisma.$speakersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Agenda
 * const agenda = await prisma.agenda.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Agenda
   * const agenda = await prisma.agenda.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.agenda`: Exposes CRUD operations for the **Agenda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agenda
    * const agenda = await prisma.agenda.findMany()
    * ```
    */
  get agenda(): Prisma.AgendaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaDay`: Exposes CRUD operations for the **AgendaDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaDays
    * const agendaDays = await prisma.agendaDay.findMany()
    * ```
    */
  get agendaDay(): Prisma.AgendaDayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaItem`: Exposes CRUD operations for the **AgendaItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaItems
    * const agendaItems = await prisma.agendaItem.findMany()
    * ```
    */
  get agendaItem(): Prisma.AgendaItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaItemSpeaker`: Exposes CRUD operations for the **AgendaItemSpeaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaItemSpeakers
    * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany()
    * ```
    */
  get agendaItemSpeaker(): Prisma.AgendaItemSpeakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaSession`: Exposes CRUD operations for the **AgendaSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaSessions
    * const agendaSessions = await prisma.agendaSession.findMany()
    * ```
    */
  get agendaSession(): Prisma.AgendaSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendee`: Exposes CRUD operations for the **Attendee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendees
    * const attendees = await prisma.attendee.findMany()
    * ```
    */
  get attendee(): Prisma.AttendeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendees`: Exposes CRUD operations for the **Attendees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendees
    * const attendees = await prisma.attendees.findMany()
    * ```
    */
  get attendees(): Prisma.AttendeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactRequest`: Exposes CRUD operations for the **ContactRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactRequests
    * const contactRequests = await prisma.contactRequest.findMany()
    * ```
    */
  get contactRequest(): Prisma.ContactRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delegate`: Exposes CRUD operations for the **Delegate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delegates
    * const delegates = await prisma.delegate.findMany()
    * ```
    */
  get delegate(): Prisma.DelegateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delegates`: Exposes CRUD operations for the **Delegates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Delegates
    * const delegates = await prisma.delegates.findMany()
    * ```
    */
  get delegates(): Prisma.DelegatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enquiry`: Exposes CRUD operations for the **Enquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enquiries
    * const enquiries = await prisma.enquiry.findMany()
    * ```
    */
  get enquiry(): Prisma.EnquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitor`: Exposes CRUD operations for the **Exhibitor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exhibitors
    * const exhibitors = await prisma.exhibitor.findMany()
    * ```
    */
  get exhibitor(): Prisma.ExhibitorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitors`: Exposes CRUD operations for the **Exhibitors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exhibitors
    * const exhibitors = await prisma.exhibitors.findMany()
    * ```
    */
  get exhibitors(): Prisma.ExhibitorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketing`: Exposes CRUD operations for the **Marketing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marketings
    * const marketings = await prisma.marketing.findMany()
    * ```
    */
  get marketing(): Prisma.MarketingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingCampaign`: Exposes CRUD operations for the **MarketingCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingCampaigns
    * const marketingCampaigns = await prisma.marketingCampaign.findMany()
    * ```
    */
  get marketingCampaign(): Prisma.MarketingCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaPartner`: Exposes CRUD operations for the **MediaPartner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaPartners
    * const mediaPartners = await prisma.mediaPartner.findMany()
    * ```
    */
  get mediaPartner(): Prisma.MediaPartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partners`: Exposes CRUD operations for the **Partners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partners.findMany()
    * ```
    */
  get partners(): Prisma.PartnersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectStats`: Exposes CRUD operations for the **ProjectStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectStats
    * const projectStats = await prisma.projectStats.findMany()
    * ```
    */
  get projectStats(): Prisma.ProjectStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speaker`: Exposes CRUD operations for the **Speaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speaker.findMany()
    * ```
    */
  get speaker(): Prisma.SpeakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speakerSession`: Exposes CRUD operations for the **SpeakerSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakerSessions
    * const speakerSessions = await prisma.speakerSession.findMany()
    * ```
    */
  get speakerSession(): Prisma.SpeakerSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speakers`: Exposes CRUD operations for the **Speakers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speakers.findMany()
    * ```
    */
  get speakers(): Prisma.SpeakersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsor`: Exposes CRUD operations for the **Sponsor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsor.findMany()
    * ```
    */
  get sponsor(): Prisma.SponsorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sponsors`: Exposes CRUD operations for the **Sponsors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sponsors
    * const sponsors = await prisma.sponsors.findMany()
    * ```
    */
  get sponsors(): Prisma.SponsorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketing`: Exposes CRUD operations for the **Ticketing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ticketings
    * const ticketings = await prisma.ticketing.findMany()
    * ```
    */
  get ticketing(): Prisma.TicketingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utmData`: Exposes CRUD operations for the **UtmData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UtmData
    * const utmData = await prisma.utmData.findMany()
    * ```
    */
  get utmData(): Prisma.UtmDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendadays`: Exposes CRUD operations for the **agendadays** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendadays
    * const agendadays = await prisma.agendadays.findMany()
    * ```
    */
  get agendadays(): Prisma.agendadaysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaitems`: Exposes CRUD operations for the **agendaitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendaitems
    * const agendaitems = await prisma.agendaitems.findMany()
    * ```
    */
  get agendaitems(): Prisma.agendaitemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendaitemspeakers`: Exposes CRUD operations for the **agendaitemspeakers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendaitemspeakers
    * const agendaitemspeakers = await prisma.agendaitemspeakers.findMany()
    * ```
    */
  get agendaitemspeakers(): Prisma.agendaitemspeakersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agendasessions`: Exposes CRUD operations for the **agendasessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendasessions
    * const agendasessions = await prisma.agendasessions.findMany()
    * ```
    */
  get agendasessions(): Prisma.agendasessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitors`: Exposes CRUD operations for the **exhibitors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exhibitors
    * const exhibitors = await prisma.exhibitors.findMany()
    * ```
    */
  get exhibitors(): Prisma.exhibitorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.projectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speakers`: Exposes CRUD operations for the **speakers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speakers.findMany()
    * ```
    */
  get speakers(): Prisma.speakersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Agenda: 'Agenda',
    AgendaDay: 'AgendaDay',
    AgendaItem: 'AgendaItem',
    AgendaItemSpeaker: 'AgendaItemSpeaker',
    AgendaSession: 'AgendaSession',
    Attendee: 'Attendee',
    Attendees: 'Attendees',
    Campaign: 'Campaign',
    ContactRequest: 'ContactRequest',
    Delegate: 'Delegate',
    Delegates: 'Delegates',
    Discount: 'Discount',
    Enquiry: 'Enquiry',
    Exhibitor: 'Exhibitor',
    Exhibitors: 'Exhibitors',
    Lead: 'Lead',
    Marketing: 'Marketing',
    MarketingCampaign: 'MarketingCampaign',
    MediaPartner: 'MediaPartner',
    Order: 'Order',
    Package: 'Package',
    Partner: 'Partner',
    Partners: 'Partners',
    Project: 'Project',
    ProjectStats: 'ProjectStats',
    Session: 'Session',
    Speaker: 'Speaker',
    SpeakerSession: 'SpeakerSession',
    Speakers: 'Speakers',
    Sponsor: 'Sponsor',
    Sponsors: 'Sponsors',
    Ticket: 'Ticket',
    Ticketing: 'Ticketing',
    User: 'User',
    UtmData: 'UtmData',
    agendadays: 'agendadays',
    agendaitems: 'agendaitems',
    agendaitemspeakers: 'agendaitemspeakers',
    agendasessions: 'agendasessions',
    exhibitors: 'exhibitors',
    projects: 'projects',
    speakers: 'speakers'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "agenda" | "agendaDay" | "agendaItem" | "agendaItemSpeaker" | "agendaSession" | "attendee" | "attendees" | "campaign" | "contactRequest" | "delegate" | "delegates" | "discount" | "enquiry" | "exhibitor" | "exhibitors" | "lead" | "marketing" | "marketingCampaign" | "mediaPartner" | "order" | "package" | "partner" | "partners" | "project" | "projectStats" | "session" | "speaker" | "speakerSession" | "speakers" | "sponsor" | "sponsors" | "ticket" | "ticketing" | "user" | "utmData" | "agendadays" | "agendaitems" | "agendaitemspeakers" | "agendasessions" | "exhibitors" | "projects" | "speakers"
      txIsolationLevel: never
    }
    model: {
      Agenda: {
        payload: Prisma.$AgendaPayload<ExtArgs>
        fields: Prisma.AgendaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          findFirst: {
            args: Prisma.AgendaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          findMany: {
            args: Prisma.AgendaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>[]
          }
          create: {
            args: Prisma.AgendaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          createMany: {
            args: Prisma.AgendaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          update: {
            args: Prisma.AgendaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          deleteMany: {
            args: Prisma.AgendaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaPayload>
          }
          aggregate: {
            args: Prisma.AgendaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgenda>
          }
          groupBy: {
            args: Prisma.AgendaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaCountAggregateOutputType> | number
          }
        }
      }
      AgendaDay: {
        payload: Prisma.$AgendaDayPayload<ExtArgs>
        fields: Prisma.AgendaDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          findFirst: {
            args: Prisma.AgendaDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          findMany: {
            args: Prisma.AgendaDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>[]
          }
          create: {
            args: Prisma.AgendaDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          createMany: {
            args: Prisma.AgendaDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          update: {
            args: Prisma.AgendaDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          deleteMany: {
            args: Prisma.AgendaDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaDayPayload>
          }
          aggregate: {
            args: Prisma.AgendaDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaDay>
          }
          groupBy: {
            args: Prisma.AgendaDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaDayGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaDayFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaDayAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaDayCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaDayCountAggregateOutputType> | number
          }
        }
      }
      AgendaItem: {
        payload: Prisma.$AgendaItemPayload<ExtArgs>
        fields: Prisma.AgendaItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          findFirst: {
            args: Prisma.AgendaItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          findMany: {
            args: Prisma.AgendaItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>[]
          }
          create: {
            args: Prisma.AgendaItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          createMany: {
            args: Prisma.AgendaItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          update: {
            args: Prisma.AgendaItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          deleteMany: {
            args: Prisma.AgendaItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemPayload>
          }
          aggregate: {
            args: Prisma.AgendaItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaItem>
          }
          groupBy: {
            args: Prisma.AgendaItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaItemFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaItemAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaItemCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemCountAggregateOutputType> | number
          }
        }
      }
      AgendaItemSpeaker: {
        payload: Prisma.$AgendaItemSpeakerPayload<ExtArgs>
        fields: Prisma.AgendaItemSpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaItemSpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          findFirst: {
            args: Prisma.AgendaItemSpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          findMany: {
            args: Prisma.AgendaItemSpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>[]
          }
          create: {
            args: Prisma.AgendaItemSpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          createMany: {
            args: Prisma.AgendaItemSpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaItemSpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          update: {
            args: Prisma.AgendaItemSpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          deleteMany: {
            args: Prisma.AgendaItemSpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaItemSpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaItemSpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaItemSpeakerPayload>
          }
          aggregate: {
            args: Prisma.AgendaItemSpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaItemSpeaker>
          }
          groupBy: {
            args: Prisma.AgendaItemSpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemSpeakerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaItemSpeakerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaItemSpeakerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaItemSpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaItemSpeakerCountAggregateOutputType> | number
          }
        }
      }
      AgendaSession: {
        payload: Prisma.$AgendaSessionPayload<ExtArgs>
        fields: Prisma.AgendaSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgendaSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgendaSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          findFirst: {
            args: Prisma.AgendaSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgendaSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          findMany: {
            args: Prisma.AgendaSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>[]
          }
          create: {
            args: Prisma.AgendaSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          createMany: {
            args: Prisma.AgendaSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgendaSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          update: {
            args: Prisma.AgendaSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          deleteMany: {
            args: Prisma.AgendaSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgendaSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgendaSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgendaSessionPayload>
          }
          aggregate: {
            args: Prisma.AgendaSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaSession>
          }
          groupBy: {
            args: Prisma.AgendaSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaSessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AgendaSessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AgendaSessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AgendaSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaSessionCountAggregateOutputType> | number
          }
        }
      }
      Attendee: {
        payload: Prisma.$AttendeePayload<ExtArgs>
        fields: Prisma.AttendeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          findFirst: {
            args: Prisma.AttendeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          findMany: {
            args: Prisma.AttendeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>[]
          }
          create: {
            args: Prisma.AttendeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          createMany: {
            args: Prisma.AttendeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          update: {
            args: Prisma.AttendeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          deleteMany: {
            args: Prisma.AttendeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeePayload>
          }
          aggregate: {
            args: Prisma.AttendeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendee>
          }
          groupBy: {
            args: Prisma.AttendeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendeeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttendeeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttendeeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttendeeCountArgs<ExtArgs>
            result: $Utils.Optional<AttendeeCountAggregateOutputType> | number
          }
        }
      }
      Attendees: {
        payload: Prisma.$AttendeesPayload<ExtArgs>
        fields: Prisma.AttendeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          findFirst: {
            args: Prisma.AttendeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          findMany: {
            args: Prisma.AttendeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>[]
          }
          create: {
            args: Prisma.AttendeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          createMany: {
            args: Prisma.AttendeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          update: {
            args: Prisma.AttendeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          deleteMany: {
            args: Prisma.AttendeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendeesPayload>
          }
          aggregate: {
            args: Prisma.AttendeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendees>
          }
          groupBy: {
            args: Prisma.AttendeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendeesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttendeesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttendeesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttendeesCountArgs<ExtArgs>
            result: $Utils.Optional<AttendeesCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CampaignFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CampaignAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      ContactRequest: {
        payload: Prisma.$ContactRequestPayload<ExtArgs>
        fields: Prisma.ContactRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          findFirst: {
            args: Prisma.ContactRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          findMany: {
            args: Prisma.ContactRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>[]
          }
          create: {
            args: Prisma.ContactRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          createMany: {
            args: Prisma.ContactRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          update: {
            args: Prisma.ContactRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          deleteMany: {
            args: Prisma.ContactRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRequestPayload>
          }
          aggregate: {
            args: Prisma.ContactRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactRequest>
          }
          groupBy: {
            args: Prisma.ContactRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactRequestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContactRequestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContactRequestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContactRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ContactRequestCountAggregateOutputType> | number
          }
        }
      }
      Delegate: {
        payload: Prisma.$DelegatePayload<ExtArgs>
        fields: Prisma.DelegateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DelegateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DelegateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          findFirst: {
            args: Prisma.DelegateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DelegateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          findMany: {
            args: Prisma.DelegateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>[]
          }
          create: {
            args: Prisma.DelegateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          createMany: {
            args: Prisma.DelegateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DelegateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          update: {
            args: Prisma.DelegateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          deleteMany: {
            args: Prisma.DelegateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DelegateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DelegateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatePayload>
          }
          aggregate: {
            args: Prisma.DelegateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelegate>
          }
          groupBy: {
            args: Prisma.DelegateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelegateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DelegateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DelegateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DelegateCountArgs<ExtArgs>
            result: $Utils.Optional<DelegateCountAggregateOutputType> | number
          }
        }
      }
      Delegates: {
        payload: Prisma.$DelegatesPayload<ExtArgs>
        fields: Prisma.DelegatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DelegatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DelegatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          findFirst: {
            args: Prisma.DelegatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DelegatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          findMany: {
            args: Prisma.DelegatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>[]
          }
          create: {
            args: Prisma.DelegatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          createMany: {
            args: Prisma.DelegatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DelegatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          update: {
            args: Prisma.DelegatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          deleteMany: {
            args: Prisma.DelegatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DelegatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DelegatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelegatesPayload>
          }
          aggregate: {
            args: Prisma.DelegatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelegates>
          }
          groupBy: {
            args: Prisma.DelegatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelegatesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DelegatesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DelegatesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DelegatesCountArgs<ExtArgs>
            result: $Utils.Optional<DelegatesCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DiscountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DiscountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      Enquiry: {
        payload: Prisma.$EnquiryPayload<ExtArgs>
        fields: Prisma.EnquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findFirst: {
            args: Prisma.EnquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findMany: {
            args: Prisma.EnquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          create: {
            args: Prisma.EnquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          createMany: {
            args: Prisma.EnquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          update: {
            args: Prisma.EnquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          deleteMany: {
            args: Prisma.EnquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          aggregate: {
            args: Prisma.EnquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnquiry>
          }
          groupBy: {
            args: Prisma.EnquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnquiryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EnquiryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EnquiryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EnquiryCountArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCountAggregateOutputType> | number
          }
        }
      }
      Exhibitor: {
        payload: Prisma.$ExhibitorPayload<ExtArgs>
        fields: Prisma.ExhibitorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExhibitorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExhibitorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          findFirst: {
            args: Prisma.ExhibitorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExhibitorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          findMany: {
            args: Prisma.ExhibitorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>[]
          }
          create: {
            args: Prisma.ExhibitorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          createMany: {
            args: Prisma.ExhibitorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExhibitorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          update: {
            args: Prisma.ExhibitorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          deleteMany: {
            args: Prisma.ExhibitorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExhibitorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExhibitorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorPayload>
          }
          aggregate: {
            args: Prisma.ExhibitorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExhibitor>
          }
          groupBy: {
            args: Prisma.ExhibitorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExhibitorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExhibitorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExhibitorCountArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorCountAggregateOutputType> | number
          }
        }
      }
      Exhibitors: {
        payload: Prisma.$ExhibitorsPayload<ExtArgs>
        fields: Prisma.ExhibitorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExhibitorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExhibitorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          findFirst: {
            args: Prisma.ExhibitorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExhibitorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          findMany: {
            args: Prisma.ExhibitorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>[]
          }
          create: {
            args: Prisma.ExhibitorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          createMany: {
            args: Prisma.ExhibitorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExhibitorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          update: {
            args: Prisma.ExhibitorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          deleteMany: {
            args: Prisma.ExhibitorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExhibitorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExhibitorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExhibitorsPayload>
          }
          aggregate: {
            args: Prisma.ExhibitorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExhibitors>
          }
          groupBy: {
            args: Prisma.ExhibitorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExhibitorsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExhibitorsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExhibitorsCountArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorsCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LeadFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LeadAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Marketing: {
        payload: Prisma.$MarketingPayload<ExtArgs>
        fields: Prisma.MarketingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          findFirst: {
            args: Prisma.MarketingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          findMany: {
            args: Prisma.MarketingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>[]
          }
          create: {
            args: Prisma.MarketingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          createMany: {
            args: Prisma.MarketingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          update: {
            args: Prisma.MarketingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          deleteMany: {
            args: Prisma.MarketingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingPayload>
          }
          aggregate: {
            args: Prisma.MarketingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketing>
          }
          groupBy: {
            args: Prisma.MarketingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingCountAggregateOutputType> | number
          }
        }
      }
      MarketingCampaign: {
        payload: Prisma.$MarketingCampaignPayload<ExtArgs>
        fields: Prisma.MarketingCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          findFirst: {
            args: Prisma.MarketingCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          findMany: {
            args: Prisma.MarketingCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>[]
          }
          create: {
            args: Prisma.MarketingCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          createMany: {
            args: Prisma.MarketingCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketingCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          update: {
            args: Prisma.MarketingCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          deleteMany: {
            args: Prisma.MarketingCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingCampaignPayload>
          }
          aggregate: {
            args: Prisma.MarketingCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingCampaign>
          }
          groupBy: {
            args: Prisma.MarketingCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingCampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketingCampaignFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketingCampaignAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketingCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingCampaignCountAggregateOutputType> | number
          }
        }
      }
      MediaPartner: {
        payload: Prisma.$MediaPartnerPayload<ExtArgs>
        fields: Prisma.MediaPartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaPartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaPartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          findFirst: {
            args: Prisma.MediaPartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaPartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          findMany: {
            args: Prisma.MediaPartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>[]
          }
          create: {
            args: Prisma.MediaPartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          createMany: {
            args: Prisma.MediaPartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaPartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          update: {
            args: Prisma.MediaPartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          deleteMany: {
            args: Prisma.MediaPartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaPartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaPartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPartnerPayload>
          }
          aggregate: {
            args: Prisma.MediaPartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaPartner>
          }
          groupBy: {
            args: Prisma.MediaPartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaPartnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MediaPartnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MediaPartnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MediaPartnerCountArgs<ExtArgs>
            result: $Utils.Optional<MediaPartnerCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PackageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PackageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PartnerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PartnerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      Partners: {
        payload: Prisma.$PartnersPayload<ExtArgs>
        fields: Prisma.PartnersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          findFirst: {
            args: Prisma.PartnersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          findMany: {
            args: Prisma.PartnersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>[]
          }
          create: {
            args: Prisma.PartnersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          createMany: {
            args: Prisma.PartnersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PartnersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          update: {
            args: Prisma.PartnersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          deleteMany: {
            args: Prisma.PartnersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnersPayload>
          }
          aggregate: {
            args: Prisma.PartnersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartners>
          }
          groupBy: {
            args: Prisma.PartnersGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PartnersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PartnersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PartnersCountArgs<ExtArgs>
            result: $Utils.Optional<PartnersCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectStats: {
        payload: Prisma.$ProjectStatsPayload<ExtArgs>
        fields: Prisma.ProjectStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          findFirst: {
            args: Prisma.ProjectStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          findMany: {
            args: Prisma.ProjectStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>[]
          }
          create: {
            args: Prisma.ProjectStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          createMany: {
            args: Prisma.ProjectStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          update: {
            args: Prisma.ProjectStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectStatsPayload>
          }
          aggregate: {
            args: Prisma.ProjectStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectStats>
          }
          groupBy: {
            args: Prisma.ProjectStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProjectStatsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProjectStatsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProjectStatsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectStatsCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Speaker: {
        payload: Prisma.$SpeakerPayload<ExtArgs>
        fields: Prisma.SpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findFirst: {
            args: Prisma.SpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findMany: {
            args: Prisma.SpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
          }
          create: {
            args: Prisma.SpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          createMany: {
            args: Prisma.SpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          update: {
            args: Prisma.SpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          deleteMany: {
            args: Prisma.SpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          aggregate: {
            args: Prisma.SpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeaker>
          }
          groupBy: {
            args: Prisma.SpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpeakerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpeakerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakerCountAggregateOutputType> | number
          }
        }
      }
      SpeakerSession: {
        payload: Prisma.$SpeakerSessionPayload<ExtArgs>
        fields: Prisma.SpeakerSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakerSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakerSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          findFirst: {
            args: Prisma.SpeakerSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakerSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          findMany: {
            args: Prisma.SpeakerSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>[]
          }
          create: {
            args: Prisma.SpeakerSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          createMany: {
            args: Prisma.SpeakerSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpeakerSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          update: {
            args: Prisma.SpeakerSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          deleteMany: {
            args: Prisma.SpeakerSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakerSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakerSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerSessionPayload>
          }
          aggregate: {
            args: Prisma.SpeakerSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakerSession>
          }
          groupBy: {
            args: Prisma.SpeakerSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakerSessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpeakerSessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpeakerSessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpeakerSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakerSessionCountAggregateOutputType> | number
          }
        }
      }
      Speakers: {
        payload: Prisma.$SpeakersPayload<ExtArgs>
        fields: Prisma.SpeakersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          findFirst: {
            args: Prisma.SpeakersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          findMany: {
            args: Prisma.SpeakersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>[]
          }
          create: {
            args: Prisma.SpeakersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          createMany: {
            args: Prisma.SpeakersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpeakersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          update: {
            args: Prisma.SpeakersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          deleteMany: {
            args: Prisma.SpeakersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakersPayload>
          }
          aggregate: {
            args: Prisma.SpeakersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakers>
          }
          groupBy: {
            args: Prisma.SpeakersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SpeakersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SpeakersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SpeakersCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakersCountAggregateOutputType> | number
          }
        }
      }
      Sponsor: {
        payload: Prisma.$SponsorPayload<ExtArgs>
        fields: Prisma.SponsorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findFirst: {
            args: Prisma.SponsorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          findMany: {
            args: Prisma.SponsorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>[]
          }
          create: {
            args: Prisma.SponsorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          createMany: {
            args: Prisma.SponsorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SponsorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          update: {
            args: Prisma.SponsorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          deleteMany: {
            args: Prisma.SponsorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SponsorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorPayload>
          }
          aggregate: {
            args: Prisma.SponsorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsor>
          }
          groupBy: {
            args: Prisma.SponsorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SponsorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SponsorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SponsorCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorCountAggregateOutputType> | number
          }
        }
      }
      Sponsors: {
        payload: Prisma.$SponsorsPayload<ExtArgs>
        fields: Prisma.SponsorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SponsorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SponsorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          findFirst: {
            args: Prisma.SponsorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SponsorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          findMany: {
            args: Prisma.SponsorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>[]
          }
          create: {
            args: Prisma.SponsorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          createMany: {
            args: Prisma.SponsorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SponsorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          update: {
            args: Prisma.SponsorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          deleteMany: {
            args: Prisma.SponsorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SponsorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SponsorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SponsorsPayload>
          }
          aggregate: {
            args: Prisma.SponsorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSponsors>
          }
          groupBy: {
            args: Prisma.SponsorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SponsorsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SponsorsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SponsorsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SponsorsCountArgs<ExtArgs>
            result: $Utils.Optional<SponsorsCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      Ticketing: {
        payload: Prisma.$TicketingPayload<ExtArgs>
        fields: Prisma.TicketingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          findFirst: {
            args: Prisma.TicketingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          findMany: {
            args: Prisma.TicketingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>[]
          }
          create: {
            args: Prisma.TicketingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          createMany: {
            args: Prisma.TicketingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          update: {
            args: Prisma.TicketingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          deleteMany: {
            args: Prisma.TicketingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketingPayload>
          }
          aggregate: {
            args: Prisma.TicketingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketing>
          }
          groupBy: {
            args: Prisma.TicketingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TicketingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TicketingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TicketingCountArgs<ExtArgs>
            result: $Utils.Optional<TicketingCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UtmData: {
        payload: Prisma.$UtmDataPayload<ExtArgs>
        fields: Prisma.UtmDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtmDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtmDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          findFirst: {
            args: Prisma.UtmDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtmDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          findMany: {
            args: Prisma.UtmDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>[]
          }
          create: {
            args: Prisma.UtmDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          createMany: {
            args: Prisma.UtmDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UtmDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          update: {
            args: Prisma.UtmDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          deleteMany: {
            args: Prisma.UtmDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtmDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UtmDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtmDataPayload>
          }
          aggregate: {
            args: Prisma.UtmDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtmData>
          }
          groupBy: {
            args: Prisma.UtmDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtmDataGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UtmDataFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UtmDataAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UtmDataCountArgs<ExtArgs>
            result: $Utils.Optional<UtmDataCountAggregateOutputType> | number
          }
        }
      }
      agendadays: {
        payload: Prisma.$agendadaysPayload<ExtArgs>
        fields: Prisma.agendadaysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agendadaysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agendadaysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          findFirst: {
            args: Prisma.agendadaysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agendadaysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          findMany: {
            args: Prisma.agendadaysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>[]
          }
          create: {
            args: Prisma.agendadaysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          createMany: {
            args: Prisma.agendadaysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agendadaysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          update: {
            args: Prisma.agendadaysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          deleteMany: {
            args: Prisma.agendadaysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agendadaysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agendadaysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendadaysPayload>
          }
          aggregate: {
            args: Prisma.AgendadaysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendadays>
          }
          groupBy: {
            args: Prisma.agendadaysGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendadaysGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.agendadaysFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.agendadaysAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.agendadaysCountArgs<ExtArgs>
            result: $Utils.Optional<AgendadaysCountAggregateOutputType> | number
          }
        }
      }
      agendaitems: {
        payload: Prisma.$agendaitemsPayload<ExtArgs>
        fields: Prisma.agendaitemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agendaitemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agendaitemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          findFirst: {
            args: Prisma.agendaitemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agendaitemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          findMany: {
            args: Prisma.agendaitemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>[]
          }
          create: {
            args: Prisma.agendaitemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          createMany: {
            args: Prisma.agendaitemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agendaitemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          update: {
            args: Prisma.agendaitemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          deleteMany: {
            args: Prisma.agendaitemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agendaitemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agendaitemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemsPayload>
          }
          aggregate: {
            args: Prisma.AgendaitemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaitems>
          }
          groupBy: {
            args: Prisma.agendaitemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaitemsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.agendaitemsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.agendaitemsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.agendaitemsCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaitemsCountAggregateOutputType> | number
          }
        }
      }
      agendaitemspeakers: {
        payload: Prisma.$agendaitemspeakersPayload<ExtArgs>
        fields: Prisma.agendaitemspeakersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agendaitemspeakersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agendaitemspeakersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          findFirst: {
            args: Prisma.agendaitemspeakersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agendaitemspeakersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          findMany: {
            args: Prisma.agendaitemspeakersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>[]
          }
          create: {
            args: Prisma.agendaitemspeakersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          createMany: {
            args: Prisma.agendaitemspeakersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agendaitemspeakersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          update: {
            args: Prisma.agendaitemspeakersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          deleteMany: {
            args: Prisma.agendaitemspeakersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agendaitemspeakersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agendaitemspeakersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendaitemspeakersPayload>
          }
          aggregate: {
            args: Prisma.AgendaitemspeakersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendaitemspeakers>
          }
          groupBy: {
            args: Prisma.agendaitemspeakersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendaitemspeakersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.agendaitemspeakersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.agendaitemspeakersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.agendaitemspeakersCountArgs<ExtArgs>
            result: $Utils.Optional<AgendaitemspeakersCountAggregateOutputType> | number
          }
        }
      }
      agendasessions: {
        payload: Prisma.$agendasessionsPayload<ExtArgs>
        fields: Prisma.agendasessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agendasessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agendasessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          findFirst: {
            args: Prisma.agendasessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agendasessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          findMany: {
            args: Prisma.agendasessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>[]
          }
          create: {
            args: Prisma.agendasessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          createMany: {
            args: Prisma.agendasessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agendasessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          update: {
            args: Prisma.agendasessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          deleteMany: {
            args: Prisma.agendasessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agendasessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agendasessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agendasessionsPayload>
          }
          aggregate: {
            args: Prisma.AgendasessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgendasessions>
          }
          groupBy: {
            args: Prisma.agendasessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgendasessionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.agendasessionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.agendasessionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.agendasessionsCountArgs<ExtArgs>
            result: $Utils.Optional<AgendasessionsCountAggregateOutputType> | number
          }
        }
      }
      exhibitors: {
        payload: Prisma.$exhibitorsPayload<ExtArgs>
        fields: Prisma.exhibitorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exhibitorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exhibitorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          findFirst: {
            args: Prisma.exhibitorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exhibitorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          findMany: {
            args: Prisma.exhibitorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>[]
          }
          create: {
            args: Prisma.exhibitorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          createMany: {
            args: Prisma.exhibitorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.exhibitorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          update: {
            args: Prisma.exhibitorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          deleteMany: {
            args: Prisma.exhibitorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exhibitorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.exhibitorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exhibitorsPayload>
          }
          aggregate: {
            args: Prisma.ExhibitorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExhibitors>
          }
          groupBy: {
            args: Prisma.exhibitorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.exhibitorsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.exhibitorsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.exhibitorsCountArgs<ExtArgs>
            result: $Utils.Optional<ExhibitorsCountAggregateOutputType> | number
          }
        }
      }
      projects: {
        payload: Prisma.$projectsPayload<ExtArgs>
        fields: Prisma.projectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findFirst: {
            args: Prisma.projectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findMany: {
            args: Prisma.projectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          create: {
            args: Prisma.projectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          createMany: {
            args: Prisma.projectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.projectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          update: {
            args: Prisma.projectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          deleteMany: {
            args: Prisma.projectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          aggregate: {
            args: Prisma.ProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjects>
          }
          groupBy: {
            args: Prisma.projectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.projectsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.projectsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.projectsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectsCountAggregateOutputType> | number
          }
        }
      }
      speakers: {
        payload: Prisma.$speakersPayload<ExtArgs>
        fields: Prisma.speakersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.speakersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.speakersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          findFirst: {
            args: Prisma.speakersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.speakersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          findMany: {
            args: Prisma.speakersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>[]
          }
          create: {
            args: Prisma.speakersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          createMany: {
            args: Prisma.speakersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.speakersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          update: {
            args: Prisma.speakersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          deleteMany: {
            args: Prisma.speakersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.speakersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.speakersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$speakersPayload>
          }
          aggregate: {
            args: Prisma.SpeakersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakers>
          }
          groupBy: {
            args: Prisma.speakersGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.speakersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.speakersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.speakersCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    agenda?: AgendaOmit
    agendaDay?: AgendaDayOmit
    agendaItem?: AgendaItemOmit
    agendaItemSpeaker?: AgendaItemSpeakerOmit
    agendaSession?: AgendaSessionOmit
    attendee?: AttendeeOmit
    attendees?: AttendeesOmit
    campaign?: CampaignOmit
    contactRequest?: ContactRequestOmit
    delegate?: DelegateOmit
    delegates?: DelegatesOmit
    discount?: DiscountOmit
    enquiry?: EnquiryOmit
    exhibitor?: ExhibitorOmit
    exhibitors?: ExhibitorsOmit
    lead?: LeadOmit
    marketing?: MarketingOmit
    marketingCampaign?: MarketingCampaignOmit
    mediaPartner?: MediaPartnerOmit
    order?: OrderOmit
    package?: PackageOmit
    partner?: PartnerOmit
    partners?: PartnersOmit
    project?: ProjectOmit
    projectStats?: ProjectStatsOmit
    session?: SessionOmit
    speaker?: SpeakerOmit
    speakerSession?: SpeakerSessionOmit
    speakers?: SpeakersOmit
    sponsor?: SponsorOmit
    sponsors?: SponsorsOmit
    ticket?: TicketOmit
    ticketing?: TicketingOmit
    user?: UserOmit
    utmData?: UtmDataOmit
    agendadays?: agendadaysOmit
    agendaitems?: agendaitemsOmit
    agendaitemspeakers?: agendaitemspeakersOmit
    agendasessions?: agendasessionsOmit
    exhibitors?: exhibitorsOmit
    projects?: projectsOmit
    speakers?: speakersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Agenda
   */

  export type AggregateAgenda = {
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  export type AgendaMinAggregateOutputType = {
    id: string | null
  }

  export type AgendaMaxAggregateOutputType = {
    id: string | null
  }

  export type AgendaCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type AgendaMinAggregateInputType = {
    id?: true
  }

  export type AgendaMaxAggregateInputType = {
    id?: true
  }

  export type AgendaCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type AgendaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agenda to aggregate.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agenda
    **/
    _count?: true | AgendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaMaxAggregateInputType
  }

  export type GetAgendaAggregateType<T extends AgendaAggregateArgs> = {
        [P in keyof T & keyof AggregateAgenda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenda[P]>
      : GetScalarType<T[P], AggregateAgenda[P]>
  }




  export type AgendaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaWhereInput
    orderBy?: AgendaOrderByWithAggregationInput | AgendaOrderByWithAggregationInput[]
    by: AgendaScalarFieldEnum[] | AgendaScalarFieldEnum
    having?: AgendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaCountAggregateInputType | true
    _min?: AgendaMinAggregateInputType
    _max?: AgendaMaxAggregateInputType
  }

  export type AgendaGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  type GetAgendaGroupByPayload<T extends AgendaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaGroupByOutputType[P]>
        }
      >
    >


  export type AgendaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["agenda"]>



  export type AgendaSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type AgendaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["agenda"]>

  export type $AgendaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agenda"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["agenda"]>
    composites: {}
  }

  type AgendaGetPayload<S extends boolean | null | undefined | AgendaDefaultArgs> = $Result.GetResult<Prisma.$AgendaPayload, S>

  type AgendaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaCountAggregateInputType | true
    }

  export interface AgendaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agenda'], meta: { name: 'Agenda' } }
    /**
     * Find zero or one Agenda that matches the filter.
     * @param {AgendaFindUniqueArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaFindUniqueArgs>(args: SelectSubset<T, AgendaFindUniqueArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agenda that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaFindUniqueOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaFindFirstArgs>(args?: SelectSubset<T, AgendaFindFirstArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agenda that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenda
     * const agenda = await prisma.agenda.findMany()
     * 
     * // Get first 10 Agenda
     * const agenda = await prisma.agenda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaWithIdOnly = await prisma.agenda.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaFindManyArgs>(args?: SelectSubset<T, AgendaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agenda.
     * @param {AgendaCreateArgs} args - Arguments to create a Agenda.
     * @example
     * // Create one Agenda
     * const Agenda = await prisma.agenda.create({
     *   data: {
     *     // ... data to create a Agenda
     *   }
     * })
     * 
     */
    create<T extends AgendaCreateArgs>(args: SelectSubset<T, AgendaCreateArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agenda.
     * @param {AgendaCreateManyArgs} args - Arguments to create many Agenda.
     * @example
     * // Create many Agenda
     * const agenda = await prisma.agenda.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaCreateManyArgs>(args?: SelectSubset<T, AgendaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agenda.
     * @param {AgendaDeleteArgs} args - Arguments to delete one Agenda.
     * @example
     * // Delete one Agenda
     * const Agenda = await prisma.agenda.delete({
     *   where: {
     *     // ... filter to delete one Agenda
     *   }
     * })
     * 
     */
    delete<T extends AgendaDeleteArgs>(args: SelectSubset<T, AgendaDeleteArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agenda.
     * @param {AgendaUpdateArgs} args - Arguments to update one Agenda.
     * @example
     * // Update one Agenda
     * const agenda = await prisma.agenda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaUpdateArgs>(args: SelectSubset<T, AgendaUpdateArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agenda.
     * @param {AgendaDeleteManyArgs} args - Arguments to filter Agenda to delete.
     * @example
     * // Delete a few Agenda
     * const { count } = await prisma.agenda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaDeleteManyArgs>(args?: SelectSubset<T, AgendaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenda
     * const agenda = await prisma.agenda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaUpdateManyArgs>(args: SelectSubset<T, AgendaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agenda.
     * @param {AgendaUpsertArgs} args - Arguments to update or create a Agenda.
     * @example
     * // Update or create a Agenda
     * const agenda = await prisma.agenda.upsert({
     *   create: {
     *     // ... data to create a Agenda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenda we want to update
     *   }
     * })
     */
    upsert<T extends AgendaUpsertArgs>(args: SelectSubset<T, AgendaUpsertArgs<ExtArgs>>): Prisma__AgendaClient<$Result.GetResult<Prisma.$AgendaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agenda that matches the filter.
     * @param {AgendaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agenda = await prisma.agenda.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agenda.
     * @param {AgendaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agenda = await prisma.agenda.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaCountArgs} args - Arguments to filter Agenda to count.
     * @example
     * // Count the number of Agenda
     * const count = await prisma.agenda.count({
     *   where: {
     *     // ... the filter for the Agenda we want to count
     *   }
     * })
    **/
    count<T extends AgendaCountArgs>(
      args?: Subset<T, AgendaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaAggregateArgs>(args: Subset<T, AgendaAggregateArgs>): Prisma.PrismaPromise<GetAgendaAggregateType<T>>

    /**
     * Group by Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaGroupByArgs['orderBy'] }
        : { orderBy?: AgendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agenda model
   */
  readonly fields: AgendaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agenda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agenda model
   */
  interface AgendaFieldRefs {
    readonly id: FieldRef<"Agenda", 'String'>
    readonly projectId: FieldRef<"Agenda", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Agenda findUnique
   */
  export type AgendaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda findUniqueOrThrow
   */
  export type AgendaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda findFirst
   */
  export type AgendaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda findFirstOrThrow
   */
  export type AgendaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     */
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda findMany
   */
  export type AgendaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter, which Agenda to fetch.
     */
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     */
    orderBy?: AgendaOrderByWithRelationInput | AgendaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agenda.
     */
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     */
    skip?: number
    distinct?: AgendaScalarFieldEnum | AgendaScalarFieldEnum[]
  }

  /**
   * Agenda create
   */
  export type AgendaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * The data needed to create a Agenda.
     */
    data?: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
  }

  /**
   * Agenda createMany
   */
  export type AgendaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agenda.
     */
    data: AgendaCreateManyInput | AgendaCreateManyInput[]
  }

  /**
   * Agenda update
   */
  export type AgendaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * The data needed to update a Agenda.
     */
    data: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
    /**
     * Choose, which Agenda to update.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda updateMany
   */
  export type AgendaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agenda.
     */
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyInput>
    /**
     * Filter which Agenda to update
     */
    where?: AgendaWhereInput
    /**
     * Limit how many Agenda to update.
     */
    limit?: number
  }

  /**
   * Agenda upsert
   */
  export type AgendaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * The filter to search for the Agenda to update in case it exists.
     */
    where: AgendaWhereUniqueInput
    /**
     * In case the Agenda found by the `where` argument doesn't exist, create a new Agenda with this data.
     */
    create: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
    /**
     * In case the Agenda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
  }

  /**
   * Agenda delete
   */
  export type AgendaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
    /**
     * Filter which Agenda to delete.
     */
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda deleteMany
   */
  export type AgendaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agenda to delete
     */
    where?: AgendaWhereInput
    /**
     * Limit how many Agenda to delete.
     */
    limit?: number
  }

  /**
   * Agenda findRaw
   */
  export type AgendaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Agenda aggregateRaw
   */
  export type AgendaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Agenda without action
   */
  export type AgendaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agenda
     */
    select?: AgendaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agenda
     */
    omit?: AgendaOmit<ExtArgs> | null
  }


  /**
   * Model AgendaDay
   */

  export type AggregateAgendaDay = {
    _count: AgendaDayCountAggregateOutputType | null
    _avg: AgendaDayAvgAggregateOutputType | null
    _sum: AgendaDaySumAggregateOutputType | null
    _min: AgendaDayMinAggregateOutputType | null
    _max: AgendaDayMaxAggregateOutputType | null
  }

  export type AgendaDayAvgAggregateOutputType = {
    dayNumber: number | null
  }

  export type AgendaDaySumAggregateOutputType = {
    dayNumber: bigint | null
  }

  export type AgendaDayMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    date: Date | null
    dayNumber: bigint | null
    name: string | null
    projectId: string | null
    updatedAt: Date | null
  }

  export type AgendaDayMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    date: Date | null
    dayNumber: bigint | null
    name: string | null
    projectId: string | null
    updatedAt: Date | null
  }

  export type AgendaDayCountAggregateOutputType = {
    id: number
    createdAt: number
    date: number
    dayNumber: number
    name: number
    projectId: number
    updatedAt: number
    _all: number
  }


  export type AgendaDayAvgAggregateInputType = {
    dayNumber?: true
  }

  export type AgendaDaySumAggregateInputType = {
    dayNumber?: true
  }

  export type AgendaDayMinAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    dayNumber?: true
    name?: true
    projectId?: true
    updatedAt?: true
  }

  export type AgendaDayMaxAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    dayNumber?: true
    name?: true
    projectId?: true
    updatedAt?: true
  }

  export type AgendaDayCountAggregateInputType = {
    id?: true
    createdAt?: true
    date?: true
    dayNumber?: true
    name?: true
    projectId?: true
    updatedAt?: true
    _all?: true
  }

  export type AgendaDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaDay to aggregate.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaDays
    **/
    _count?: true | AgendaDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgendaDayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgendaDaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaDayMaxAggregateInputType
  }

  export type GetAgendaDayAggregateType<T extends AgendaDayAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaDay[P]>
      : GetScalarType<T[P], AggregateAgendaDay[P]>
  }




  export type AgendaDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaDayWhereInput
    orderBy?: AgendaDayOrderByWithAggregationInput | AgendaDayOrderByWithAggregationInput[]
    by: AgendaDayScalarFieldEnum[] | AgendaDayScalarFieldEnum
    having?: AgendaDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaDayCountAggregateInputType | true
    _avg?: AgendaDayAvgAggregateInputType
    _sum?: AgendaDaySumAggregateInputType
    _min?: AgendaDayMinAggregateInputType
    _max?: AgendaDayMaxAggregateInputType
  }

  export type AgendaDayGroupByOutputType = {
    id: string
    createdAt: Date
    date: Date
    dayNumber: bigint
    name: string
    projectId: string
    updatedAt: Date
    _count: AgendaDayCountAggregateOutputType | null
    _avg: AgendaDayAvgAggregateOutputType | null
    _sum: AgendaDaySumAggregateOutputType | null
    _min: AgendaDayMinAggregateOutputType | null
    _max: AgendaDayMaxAggregateOutputType | null
  }

  type GetAgendaDayGroupByPayload<T extends AgendaDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaDayGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaDayGroupByOutputType[P]>
        }
      >
    >


  export type AgendaDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    date?: boolean
    dayNumber?: boolean
    name?: boolean
    projectId?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agendaDay"]>



  export type AgendaDaySelectScalar = {
    id?: boolean
    createdAt?: boolean
    date?: boolean
    dayNumber?: boolean
    name?: boolean
    projectId?: boolean
    updatedAt?: boolean
  }

  export type AgendaDayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "date" | "dayNumber" | "name" | "projectId" | "updatedAt", ExtArgs["result"]["agendaDay"]>

  export type $AgendaDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaDay"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      date: Date
      dayNumber: bigint
      name: string
      projectId: string
      updatedAt: Date
    }, ExtArgs["result"]["agendaDay"]>
    composites: {}
  }

  type AgendaDayGetPayload<S extends boolean | null | undefined | AgendaDayDefaultArgs> = $Result.GetResult<Prisma.$AgendaDayPayload, S>

  type AgendaDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaDayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaDayCountAggregateInputType | true
    }

  export interface AgendaDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaDay'], meta: { name: 'AgendaDay' } }
    /**
     * Find zero or one AgendaDay that matches the filter.
     * @param {AgendaDayFindUniqueArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaDayFindUniqueArgs>(args: SelectSubset<T, AgendaDayFindUniqueArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaDay that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaDayFindUniqueOrThrowArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaDayFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindFirstArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaDayFindFirstArgs>(args?: SelectSubset<T, AgendaDayFindFirstArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindFirstOrThrowArgs} args - Arguments to find a AgendaDay
     * @example
     * // Get one AgendaDay
     * const agendaDay = await prisma.agendaDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaDayFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaDays
     * const agendaDays = await prisma.agendaDay.findMany()
     * 
     * // Get first 10 AgendaDays
     * const agendaDays = await prisma.agendaDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaDayWithIdOnly = await prisma.agendaDay.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaDayFindManyArgs>(args?: SelectSubset<T, AgendaDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaDay.
     * @param {AgendaDayCreateArgs} args - Arguments to create a AgendaDay.
     * @example
     * // Create one AgendaDay
     * const AgendaDay = await prisma.agendaDay.create({
     *   data: {
     *     // ... data to create a AgendaDay
     *   }
     * })
     * 
     */
    create<T extends AgendaDayCreateArgs>(args: SelectSubset<T, AgendaDayCreateArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaDays.
     * @param {AgendaDayCreateManyArgs} args - Arguments to create many AgendaDays.
     * @example
     * // Create many AgendaDays
     * const agendaDay = await prisma.agendaDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaDayCreateManyArgs>(args?: SelectSubset<T, AgendaDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaDay.
     * @param {AgendaDayDeleteArgs} args - Arguments to delete one AgendaDay.
     * @example
     * // Delete one AgendaDay
     * const AgendaDay = await prisma.agendaDay.delete({
     *   where: {
     *     // ... filter to delete one AgendaDay
     *   }
     * })
     * 
     */
    delete<T extends AgendaDayDeleteArgs>(args: SelectSubset<T, AgendaDayDeleteArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaDay.
     * @param {AgendaDayUpdateArgs} args - Arguments to update one AgendaDay.
     * @example
     * // Update one AgendaDay
     * const agendaDay = await prisma.agendaDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaDayUpdateArgs>(args: SelectSubset<T, AgendaDayUpdateArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaDays.
     * @param {AgendaDayDeleteManyArgs} args - Arguments to filter AgendaDays to delete.
     * @example
     * // Delete a few AgendaDays
     * const { count } = await prisma.agendaDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaDayDeleteManyArgs>(args?: SelectSubset<T, AgendaDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaDays
     * const agendaDay = await prisma.agendaDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaDayUpdateManyArgs>(args: SelectSubset<T, AgendaDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaDay.
     * @param {AgendaDayUpsertArgs} args - Arguments to update or create a AgendaDay.
     * @example
     * // Update or create a AgendaDay
     * const agendaDay = await prisma.agendaDay.upsert({
     *   create: {
     *     // ... data to create a AgendaDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaDay we want to update
     *   }
     * })
     */
    upsert<T extends AgendaDayUpsertArgs>(args: SelectSubset<T, AgendaDayUpsertArgs<ExtArgs>>): Prisma__AgendaDayClient<$Result.GetResult<Prisma.$AgendaDayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaDays that matches the filter.
     * @param {AgendaDayFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaDay = await prisma.agendaDay.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaDayFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaDay.
     * @param {AgendaDayAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaDay = await prisma.agendaDay.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaDayAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayCountArgs} args - Arguments to filter AgendaDays to count.
     * @example
     * // Count the number of AgendaDays
     * const count = await prisma.agendaDay.count({
     *   where: {
     *     // ... the filter for the AgendaDays we want to count
     *   }
     * })
    **/
    count<T extends AgendaDayCountArgs>(
      args?: Subset<T, AgendaDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaDayAggregateArgs>(args: Subset<T, AgendaDayAggregateArgs>): Prisma.PrismaPromise<GetAgendaDayAggregateType<T>>

    /**
     * Group by AgendaDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaDayGroupByArgs['orderBy'] }
        : { orderBy?: AgendaDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaDay model
   */
  readonly fields: AgendaDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaDay model
   */
  interface AgendaDayFieldRefs {
    readonly id: FieldRef<"AgendaDay", 'String'>
    readonly createdAt: FieldRef<"AgendaDay", 'DateTime'>
    readonly date: FieldRef<"AgendaDay", 'DateTime'>
    readonly dayNumber: FieldRef<"AgendaDay", 'BigInt'>
    readonly name: FieldRef<"AgendaDay", 'String'>
    readonly projectId: FieldRef<"AgendaDay", 'String'>
    readonly updatedAt: FieldRef<"AgendaDay", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgendaDay findUnique
   */
  export type AgendaDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay findUniqueOrThrow
   */
  export type AgendaDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay findFirst
   */
  export type AgendaDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaDays.
     */
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay findFirstOrThrow
   */
  export type AgendaDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter, which AgendaDay to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaDays.
     */
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay findMany
   */
  export type AgendaDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter, which AgendaDays to fetch.
     */
    where?: AgendaDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaDays to fetch.
     */
    orderBy?: AgendaDayOrderByWithRelationInput | AgendaDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaDays.
     */
    cursor?: AgendaDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaDays.
     */
    skip?: number
    distinct?: AgendaDayScalarFieldEnum | AgendaDayScalarFieldEnum[]
  }

  /**
   * AgendaDay create
   */
  export type AgendaDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * The data needed to create a AgendaDay.
     */
    data: XOR<AgendaDayCreateInput, AgendaDayUncheckedCreateInput>
  }

  /**
   * AgendaDay createMany
   */
  export type AgendaDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaDays.
     */
    data: AgendaDayCreateManyInput | AgendaDayCreateManyInput[]
  }

  /**
   * AgendaDay update
   */
  export type AgendaDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * The data needed to update a AgendaDay.
     */
    data: XOR<AgendaDayUpdateInput, AgendaDayUncheckedUpdateInput>
    /**
     * Choose, which AgendaDay to update.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay updateMany
   */
  export type AgendaDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaDays.
     */
    data: XOR<AgendaDayUpdateManyMutationInput, AgendaDayUncheckedUpdateManyInput>
    /**
     * Filter which AgendaDays to update
     */
    where?: AgendaDayWhereInput
    /**
     * Limit how many AgendaDays to update.
     */
    limit?: number
  }

  /**
   * AgendaDay upsert
   */
  export type AgendaDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * The filter to search for the AgendaDay to update in case it exists.
     */
    where: AgendaDayWhereUniqueInput
    /**
     * In case the AgendaDay found by the `where` argument doesn't exist, create a new AgendaDay with this data.
     */
    create: XOR<AgendaDayCreateInput, AgendaDayUncheckedCreateInput>
    /**
     * In case the AgendaDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaDayUpdateInput, AgendaDayUncheckedUpdateInput>
  }

  /**
   * AgendaDay delete
   */
  export type AgendaDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
    /**
     * Filter which AgendaDay to delete.
     */
    where: AgendaDayWhereUniqueInput
  }

  /**
   * AgendaDay deleteMany
   */
  export type AgendaDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaDays to delete
     */
    where?: AgendaDayWhereInput
    /**
     * Limit how many AgendaDays to delete.
     */
    limit?: number
  }

  /**
   * AgendaDay findRaw
   */
  export type AgendaDayFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaDay aggregateRaw
   */
  export type AgendaDayAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaDay without action
   */
  export type AgendaDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaDay
     */
    select?: AgendaDaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaDay
     */
    omit?: AgendaDayOmit<ExtArgs> | null
  }


  /**
   * Model AgendaItem
   */

  export type AggregateAgendaItem = {
    _count: AgendaItemCountAggregateOutputType | null
    _min: AgendaItemMinAggregateOutputType | null
    _max: AgendaItemMaxAggregateOutputType | null
  }

  export type AgendaItemMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    description: string | null
    endTime: string | null
    sessionId: string | null
    startTime: string | null
    title: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type AgendaItemMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    description: string | null
    endTime: string | null
    sessionId: string | null
    startTime: string | null
    title: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type AgendaItemCountAggregateOutputType = {
    id: number
    createdAt: number
    description: number
    endTime: number
    sessionId: number
    startTime: number
    title: number
    type: number
    updatedAt: number
    _all: number
  }


  export type AgendaItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    description?: true
    endTime?: true
    sessionId?: true
    startTime?: true
    title?: true
    type?: true
    updatedAt?: true
  }

  export type AgendaItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    description?: true
    endTime?: true
    sessionId?: true
    startTime?: true
    title?: true
    type?: true
    updatedAt?: true
  }

  export type AgendaItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    description?: true
    endTime?: true
    sessionId?: true
    startTime?: true
    title?: true
    type?: true
    updatedAt?: true
    _all?: true
  }

  export type AgendaItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItem to aggregate.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaItems
    **/
    _count?: true | AgendaItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaItemMaxAggregateInputType
  }

  export type GetAgendaItemAggregateType<T extends AgendaItemAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaItem[P]>
      : GetScalarType<T[P], AggregateAgendaItem[P]>
  }




  export type AgendaItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemWhereInput
    orderBy?: AgendaItemOrderByWithAggregationInput | AgendaItemOrderByWithAggregationInput[]
    by: AgendaItemScalarFieldEnum[] | AgendaItemScalarFieldEnum
    having?: AgendaItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaItemCountAggregateInputType | true
    _min?: AgendaItemMinAggregateInputType
    _max?: AgendaItemMaxAggregateInputType
  }

  export type AgendaItemGroupByOutputType = {
    id: string
    createdAt: Date
    description: string
    endTime: string
    sessionId: string
    startTime: string
    title: string
    type: string
    updatedAt: Date
    _count: AgendaItemCountAggregateOutputType | null
    _min: AgendaItemMinAggregateOutputType | null
    _max: AgendaItemMaxAggregateOutputType | null
  }

  type GetAgendaItemGroupByPayload<T extends AgendaItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaItemGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaItemGroupByOutputType[P]>
        }
      >
    >


  export type AgendaItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    description?: boolean
    endTime?: boolean
    sessionId?: boolean
    startTime?: boolean
    title?: boolean
    type?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agendaItem"]>



  export type AgendaItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    description?: boolean
    endTime?: boolean
    sessionId?: boolean
    startTime?: boolean
    title?: boolean
    type?: boolean
    updatedAt?: boolean
  }

  export type AgendaItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "description" | "endTime" | "sessionId" | "startTime" | "title" | "type" | "updatedAt", ExtArgs["result"]["agendaItem"]>

  export type $AgendaItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      description: string
      endTime: string
      sessionId: string
      startTime: string
      title: string
      type: string
      updatedAt: Date
    }, ExtArgs["result"]["agendaItem"]>
    composites: {}
  }

  type AgendaItemGetPayload<S extends boolean | null | undefined | AgendaItemDefaultArgs> = $Result.GetResult<Prisma.$AgendaItemPayload, S>

  type AgendaItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaItemCountAggregateInputType | true
    }

  export interface AgendaItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaItem'], meta: { name: 'AgendaItem' } }
    /**
     * Find zero or one AgendaItem that matches the filter.
     * @param {AgendaItemFindUniqueArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaItemFindUniqueArgs>(args: SelectSubset<T, AgendaItemFindUniqueArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaItemFindUniqueOrThrowArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaItemFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindFirstArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaItemFindFirstArgs>(args?: SelectSubset<T, AgendaItemFindFirstArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindFirstOrThrowArgs} args - Arguments to find a AgendaItem
     * @example
     * // Get one AgendaItem
     * const agendaItem = await prisma.agendaItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaItemFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaItems
     * const agendaItems = await prisma.agendaItem.findMany()
     * 
     * // Get first 10 AgendaItems
     * const agendaItems = await prisma.agendaItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaItemWithIdOnly = await prisma.agendaItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaItemFindManyArgs>(args?: SelectSubset<T, AgendaItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaItem.
     * @param {AgendaItemCreateArgs} args - Arguments to create a AgendaItem.
     * @example
     * // Create one AgendaItem
     * const AgendaItem = await prisma.agendaItem.create({
     *   data: {
     *     // ... data to create a AgendaItem
     *   }
     * })
     * 
     */
    create<T extends AgendaItemCreateArgs>(args: SelectSubset<T, AgendaItemCreateArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaItems.
     * @param {AgendaItemCreateManyArgs} args - Arguments to create many AgendaItems.
     * @example
     * // Create many AgendaItems
     * const agendaItem = await prisma.agendaItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaItemCreateManyArgs>(args?: SelectSubset<T, AgendaItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaItem.
     * @param {AgendaItemDeleteArgs} args - Arguments to delete one AgendaItem.
     * @example
     * // Delete one AgendaItem
     * const AgendaItem = await prisma.agendaItem.delete({
     *   where: {
     *     // ... filter to delete one AgendaItem
     *   }
     * })
     * 
     */
    delete<T extends AgendaItemDeleteArgs>(args: SelectSubset<T, AgendaItemDeleteArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaItem.
     * @param {AgendaItemUpdateArgs} args - Arguments to update one AgendaItem.
     * @example
     * // Update one AgendaItem
     * const agendaItem = await prisma.agendaItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaItemUpdateArgs>(args: SelectSubset<T, AgendaItemUpdateArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaItems.
     * @param {AgendaItemDeleteManyArgs} args - Arguments to filter AgendaItems to delete.
     * @example
     * // Delete a few AgendaItems
     * const { count } = await prisma.agendaItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaItemDeleteManyArgs>(args?: SelectSubset<T, AgendaItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaItems
     * const agendaItem = await prisma.agendaItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaItemUpdateManyArgs>(args: SelectSubset<T, AgendaItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaItem.
     * @param {AgendaItemUpsertArgs} args - Arguments to update or create a AgendaItem.
     * @example
     * // Update or create a AgendaItem
     * const agendaItem = await prisma.agendaItem.upsert({
     *   create: {
     *     // ... data to create a AgendaItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaItem we want to update
     *   }
     * })
     */
    upsert<T extends AgendaItemUpsertArgs>(args: SelectSubset<T, AgendaItemUpsertArgs<ExtArgs>>): Prisma__AgendaItemClient<$Result.GetResult<Prisma.$AgendaItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItems that matches the filter.
     * @param {AgendaItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaItem = await prisma.agendaItem.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaItemFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaItem.
     * @param {AgendaItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaItem = await prisma.agendaItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaItemAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemCountArgs} args - Arguments to filter AgendaItems to count.
     * @example
     * // Count the number of AgendaItems
     * const count = await prisma.agendaItem.count({
     *   where: {
     *     // ... the filter for the AgendaItems we want to count
     *   }
     * })
    **/
    count<T extends AgendaItemCountArgs>(
      args?: Subset<T, AgendaItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaItemAggregateArgs>(args: Subset<T, AgendaItemAggregateArgs>): Prisma.PrismaPromise<GetAgendaItemAggregateType<T>>

    /**
     * Group by AgendaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaItemGroupByArgs['orderBy'] }
        : { orderBy?: AgendaItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaItem model
   */
  readonly fields: AgendaItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaItem model
   */
  interface AgendaItemFieldRefs {
    readonly id: FieldRef<"AgendaItem", 'String'>
    readonly createdAt: FieldRef<"AgendaItem", 'DateTime'>
    readonly description: FieldRef<"AgendaItem", 'String'>
    readonly endTime: FieldRef<"AgendaItem", 'String'>
    readonly sessionId: FieldRef<"AgendaItem", 'String'>
    readonly startTime: FieldRef<"AgendaItem", 'String'>
    readonly title: FieldRef<"AgendaItem", 'String'>
    readonly type: FieldRef<"AgendaItem", 'String'>
    readonly updatedAt: FieldRef<"AgendaItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgendaItem findUnique
   */
  export type AgendaItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem findUniqueOrThrow
   */
  export type AgendaItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem findFirst
   */
  export type AgendaItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItems.
     */
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem findFirstOrThrow
   */
  export type AgendaItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItem to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItems.
     */
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem findMany
   */
  export type AgendaItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItems to fetch.
     */
    where?: AgendaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItems to fetch.
     */
    orderBy?: AgendaItemOrderByWithRelationInput | AgendaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaItems.
     */
    cursor?: AgendaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItems.
     */
    skip?: number
    distinct?: AgendaItemScalarFieldEnum | AgendaItemScalarFieldEnum[]
  }

  /**
   * AgendaItem create
   */
  export type AgendaItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * The data needed to create a AgendaItem.
     */
    data: XOR<AgendaItemCreateInput, AgendaItemUncheckedCreateInput>
  }

  /**
   * AgendaItem createMany
   */
  export type AgendaItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaItems.
     */
    data: AgendaItemCreateManyInput | AgendaItemCreateManyInput[]
  }

  /**
   * AgendaItem update
   */
  export type AgendaItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * The data needed to update a AgendaItem.
     */
    data: XOR<AgendaItemUpdateInput, AgendaItemUncheckedUpdateInput>
    /**
     * Choose, which AgendaItem to update.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem updateMany
   */
  export type AgendaItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaItems.
     */
    data: XOR<AgendaItemUpdateManyMutationInput, AgendaItemUncheckedUpdateManyInput>
    /**
     * Filter which AgendaItems to update
     */
    where?: AgendaItemWhereInput
    /**
     * Limit how many AgendaItems to update.
     */
    limit?: number
  }

  /**
   * AgendaItem upsert
   */
  export type AgendaItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * The filter to search for the AgendaItem to update in case it exists.
     */
    where: AgendaItemWhereUniqueInput
    /**
     * In case the AgendaItem found by the `where` argument doesn't exist, create a new AgendaItem with this data.
     */
    create: XOR<AgendaItemCreateInput, AgendaItemUncheckedCreateInput>
    /**
     * In case the AgendaItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaItemUpdateInput, AgendaItemUncheckedUpdateInput>
  }

  /**
   * AgendaItem delete
   */
  export type AgendaItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
    /**
     * Filter which AgendaItem to delete.
     */
    where: AgendaItemWhereUniqueInput
  }

  /**
   * AgendaItem deleteMany
   */
  export type AgendaItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItems to delete
     */
    where?: AgendaItemWhereInput
    /**
     * Limit how many AgendaItems to delete.
     */
    limit?: number
  }

  /**
   * AgendaItem findRaw
   */
  export type AgendaItemFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItem aggregateRaw
   */
  export type AgendaItemAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItem without action
   */
  export type AgendaItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItem
     */
    select?: AgendaItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItem
     */
    omit?: AgendaItemOmit<ExtArgs> | null
  }


  /**
   * Model AgendaItemSpeaker
   */

  export type AggregateAgendaItemSpeaker = {
    _count: AgendaItemSpeakerCountAggregateOutputType | null
    _min: AgendaItemSpeakerMinAggregateOutputType | null
    _max: AgendaItemSpeakerMaxAggregateOutputType | null
  }

  export type AgendaItemSpeakerMinAggregateOutputType = {
    id: string | null
  }

  export type AgendaItemSpeakerMaxAggregateOutputType = {
    id: string | null
  }

  export type AgendaItemSpeakerCountAggregateOutputType = {
    id: number
    agendaItemId: number
    speakerId: number
    _all: number
  }


  export type AgendaItemSpeakerMinAggregateInputType = {
    id?: true
  }

  export type AgendaItemSpeakerMaxAggregateInputType = {
    id?: true
  }

  export type AgendaItemSpeakerCountAggregateInputType = {
    id?: true
    agendaItemId?: true
    speakerId?: true
    _all?: true
  }

  export type AgendaItemSpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItemSpeaker to aggregate.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaItemSpeakers
    **/
    _count?: true | AgendaItemSpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaItemSpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaItemSpeakerMaxAggregateInputType
  }

  export type GetAgendaItemSpeakerAggregateType<T extends AgendaItemSpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaItemSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaItemSpeaker[P]>
      : GetScalarType<T[P], AggregateAgendaItemSpeaker[P]>
  }




  export type AgendaItemSpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaItemSpeakerWhereInput
    orderBy?: AgendaItemSpeakerOrderByWithAggregationInput | AgendaItemSpeakerOrderByWithAggregationInput[]
    by: AgendaItemSpeakerScalarFieldEnum[] | AgendaItemSpeakerScalarFieldEnum
    having?: AgendaItemSpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaItemSpeakerCountAggregateInputType | true
    _min?: AgendaItemSpeakerMinAggregateInputType
    _max?: AgendaItemSpeakerMaxAggregateInputType
  }

  export type AgendaItemSpeakerGroupByOutputType = {
    id: string
    agendaItemId: JsonValue | null
    speakerId: JsonValue | null
    _count: AgendaItemSpeakerCountAggregateOutputType | null
    _min: AgendaItemSpeakerMinAggregateOutputType | null
    _max: AgendaItemSpeakerMaxAggregateOutputType | null
  }

  type GetAgendaItemSpeakerGroupByPayload<T extends AgendaItemSpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaItemSpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaItemSpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaItemSpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaItemSpeakerGroupByOutputType[P]>
        }
      >
    >


  export type AgendaItemSpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agendaItemId?: boolean
    speakerId?: boolean
  }, ExtArgs["result"]["agendaItemSpeaker"]>



  export type AgendaItemSpeakerSelectScalar = {
    id?: boolean
    agendaItemId?: boolean
    speakerId?: boolean
  }

  export type AgendaItemSpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agendaItemId" | "speakerId", ExtArgs["result"]["agendaItemSpeaker"]>

  export type $AgendaItemSpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaItemSpeaker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      agendaItemId: Prisma.JsonValue | null
      /**
       * Field referred in an index, but found no data to define the type.
       */
      speakerId: Prisma.JsonValue | null
    }, ExtArgs["result"]["agendaItemSpeaker"]>
    composites: {}
  }

  type AgendaItemSpeakerGetPayload<S extends boolean | null | undefined | AgendaItemSpeakerDefaultArgs> = $Result.GetResult<Prisma.$AgendaItemSpeakerPayload, S>

  type AgendaItemSpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaItemSpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaItemSpeakerCountAggregateInputType | true
    }

  export interface AgendaItemSpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaItemSpeaker'], meta: { name: 'AgendaItemSpeaker' } }
    /**
     * Find zero or one AgendaItemSpeaker that matches the filter.
     * @param {AgendaItemSpeakerFindUniqueArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaItemSpeakerFindUniqueArgs>(args: SelectSubset<T, AgendaItemSpeakerFindUniqueArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaItemSpeaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaItemSpeakerFindUniqueOrThrowArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaItemSpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItemSpeaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindFirstArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaItemSpeakerFindFirstArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindFirstArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaItemSpeaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindFirstOrThrowArgs} args - Arguments to find a AgendaItemSpeaker
     * @example
     * // Get one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaItemSpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItemSpeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaItemSpeakers
     * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany()
     * 
     * // Get first 10 AgendaItemSpeakers
     * const agendaItemSpeakers = await prisma.agendaItemSpeaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaItemSpeakerWithIdOnly = await prisma.agendaItemSpeaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaItemSpeakerFindManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerCreateArgs} args - Arguments to create a AgendaItemSpeaker.
     * @example
     * // Create one AgendaItemSpeaker
     * const AgendaItemSpeaker = await prisma.agendaItemSpeaker.create({
     *   data: {
     *     // ... data to create a AgendaItemSpeaker
     *   }
     * })
     * 
     */
    create<T extends AgendaItemSpeakerCreateArgs>(args: SelectSubset<T, AgendaItemSpeakerCreateArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaItemSpeakers.
     * @param {AgendaItemSpeakerCreateManyArgs} args - Arguments to create many AgendaItemSpeakers.
     * @example
     * // Create many AgendaItemSpeakers
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaItemSpeakerCreateManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerDeleteArgs} args - Arguments to delete one AgendaItemSpeaker.
     * @example
     * // Delete one AgendaItemSpeaker
     * const AgendaItemSpeaker = await prisma.agendaItemSpeaker.delete({
     *   where: {
     *     // ... filter to delete one AgendaItemSpeaker
     *   }
     * })
     * 
     */
    delete<T extends AgendaItemSpeakerDeleteArgs>(args: SelectSubset<T, AgendaItemSpeakerDeleteArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaItemSpeaker.
     * @param {AgendaItemSpeakerUpdateArgs} args - Arguments to update one AgendaItemSpeaker.
     * @example
     * // Update one AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaItemSpeakerUpdateArgs>(args: SelectSubset<T, AgendaItemSpeakerUpdateArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaItemSpeakers.
     * @param {AgendaItemSpeakerDeleteManyArgs} args - Arguments to filter AgendaItemSpeakers to delete.
     * @example
     * // Delete a few AgendaItemSpeakers
     * const { count } = await prisma.agendaItemSpeaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaItemSpeakerDeleteManyArgs>(args?: SelectSubset<T, AgendaItemSpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaItemSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaItemSpeakers
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaItemSpeakerUpdateManyArgs>(args: SelectSubset<T, AgendaItemSpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaItemSpeaker.
     * @param {AgendaItemSpeakerUpsertArgs} args - Arguments to update or create a AgendaItemSpeaker.
     * @example
     * // Update or create a AgendaItemSpeaker
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.upsert({
     *   create: {
     *     // ... data to create a AgendaItemSpeaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaItemSpeaker we want to update
     *   }
     * })
     */
    upsert<T extends AgendaItemSpeakerUpsertArgs>(args: SelectSubset<T, AgendaItemSpeakerUpsertArgs<ExtArgs>>): Prisma__AgendaItemSpeakerClient<$Result.GetResult<Prisma.$AgendaItemSpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaItemSpeakers that matches the filter.
     * @param {AgendaItemSpeakerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaItemSpeakerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaItemSpeaker.
     * @param {AgendaItemSpeakerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaItemSpeaker = await prisma.agendaItemSpeaker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaItemSpeakerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaItemSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerCountArgs} args - Arguments to filter AgendaItemSpeakers to count.
     * @example
     * // Count the number of AgendaItemSpeakers
     * const count = await prisma.agendaItemSpeaker.count({
     *   where: {
     *     // ... the filter for the AgendaItemSpeakers we want to count
     *   }
     * })
    **/
    count<T extends AgendaItemSpeakerCountArgs>(
      args?: Subset<T, AgendaItemSpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaItemSpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaItemSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaItemSpeakerAggregateArgs>(args: Subset<T, AgendaItemSpeakerAggregateArgs>): Prisma.PrismaPromise<GetAgendaItemSpeakerAggregateType<T>>

    /**
     * Group by AgendaItemSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaItemSpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaItemSpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaItemSpeakerGroupByArgs['orderBy'] }
        : { orderBy?: AgendaItemSpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaItemSpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaItemSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaItemSpeaker model
   */
  readonly fields: AgendaItemSpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaItemSpeaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaItemSpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaItemSpeaker model
   */
  interface AgendaItemSpeakerFieldRefs {
    readonly id: FieldRef<"AgendaItemSpeaker", 'String'>
    readonly agendaItemId: FieldRef<"AgendaItemSpeaker", 'Json'>
    readonly speakerId: FieldRef<"AgendaItemSpeaker", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AgendaItemSpeaker findUnique
   */
  export type AgendaItemSpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker findUniqueOrThrow
   */
  export type AgendaItemSpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker findFirst
   */
  export type AgendaItemSpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItemSpeakers.
     */
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker findFirstOrThrow
   */
  export type AgendaItemSpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeaker to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaItemSpeakers.
     */
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker findMany
   */
  export type AgendaItemSpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter, which AgendaItemSpeakers to fetch.
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaItemSpeakers to fetch.
     */
    orderBy?: AgendaItemSpeakerOrderByWithRelationInput | AgendaItemSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaItemSpeakers.
     */
    cursor?: AgendaItemSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaItemSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaItemSpeakers.
     */
    skip?: number
    distinct?: AgendaItemSpeakerScalarFieldEnum | AgendaItemSpeakerScalarFieldEnum[]
  }

  /**
   * AgendaItemSpeaker create
   */
  export type AgendaItemSpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * The data needed to create a AgendaItemSpeaker.
     */
    data?: XOR<AgendaItemSpeakerCreateInput, AgendaItemSpeakerUncheckedCreateInput>
  }

  /**
   * AgendaItemSpeaker createMany
   */
  export type AgendaItemSpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaItemSpeakers.
     */
    data: AgendaItemSpeakerCreateManyInput | AgendaItemSpeakerCreateManyInput[]
  }

  /**
   * AgendaItemSpeaker update
   */
  export type AgendaItemSpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * The data needed to update a AgendaItemSpeaker.
     */
    data: XOR<AgendaItemSpeakerUpdateInput, AgendaItemSpeakerUncheckedUpdateInput>
    /**
     * Choose, which AgendaItemSpeaker to update.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker updateMany
   */
  export type AgendaItemSpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaItemSpeakers.
     */
    data: XOR<AgendaItemSpeakerUpdateManyMutationInput, AgendaItemSpeakerUncheckedUpdateManyInput>
    /**
     * Filter which AgendaItemSpeakers to update
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * Limit how many AgendaItemSpeakers to update.
     */
    limit?: number
  }

  /**
   * AgendaItemSpeaker upsert
   */
  export type AgendaItemSpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * The filter to search for the AgendaItemSpeaker to update in case it exists.
     */
    where: AgendaItemSpeakerWhereUniqueInput
    /**
     * In case the AgendaItemSpeaker found by the `where` argument doesn't exist, create a new AgendaItemSpeaker with this data.
     */
    create: XOR<AgendaItemSpeakerCreateInput, AgendaItemSpeakerUncheckedCreateInput>
    /**
     * In case the AgendaItemSpeaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaItemSpeakerUpdateInput, AgendaItemSpeakerUncheckedUpdateInput>
  }

  /**
   * AgendaItemSpeaker delete
   */
  export type AgendaItemSpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
    /**
     * Filter which AgendaItemSpeaker to delete.
     */
    where: AgendaItemSpeakerWhereUniqueInput
  }

  /**
   * AgendaItemSpeaker deleteMany
   */
  export type AgendaItemSpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaItemSpeakers to delete
     */
    where?: AgendaItemSpeakerWhereInput
    /**
     * Limit how many AgendaItemSpeakers to delete.
     */
    limit?: number
  }

  /**
   * AgendaItemSpeaker findRaw
   */
  export type AgendaItemSpeakerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItemSpeaker aggregateRaw
   */
  export type AgendaItemSpeakerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaItemSpeaker without action
   */
  export type AgendaItemSpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaItemSpeaker
     */
    select?: AgendaItemSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaItemSpeaker
     */
    omit?: AgendaItemSpeakerOmit<ExtArgs> | null
  }


  /**
   * Model AgendaSession
   */

  export type AggregateAgendaSession = {
    _count: AgendaSessionCountAggregateOutputType | null
    _min: AgendaSessionMinAggregateOutputType | null
    _max: AgendaSessionMaxAggregateOutputType | null
  }

  export type AgendaSessionMinAggregateOutputType = {
    id: string | null
    color: string | null
    createdAt: Date | null
    dayId: string | null
    endTime: string | null
    startTime: string | null
    title: string | null
    updatedAt: Date | null
    venue: string | null
  }

  export type AgendaSessionMaxAggregateOutputType = {
    id: string | null
    color: string | null
    createdAt: Date | null
    dayId: string | null
    endTime: string | null
    startTime: string | null
    title: string | null
    updatedAt: Date | null
    venue: string | null
  }

  export type AgendaSessionCountAggregateOutputType = {
    id: number
    color: number
    createdAt: number
    dayId: number
    endTime: number
    startTime: number
    title: number
    updatedAt: number
    venue: number
    _all: number
  }


  export type AgendaSessionMinAggregateInputType = {
    id?: true
    color?: true
    createdAt?: true
    dayId?: true
    endTime?: true
    startTime?: true
    title?: true
    updatedAt?: true
    venue?: true
  }

  export type AgendaSessionMaxAggregateInputType = {
    id?: true
    color?: true
    createdAt?: true
    dayId?: true
    endTime?: true
    startTime?: true
    title?: true
    updatedAt?: true
    venue?: true
  }

  export type AgendaSessionCountAggregateInputType = {
    id?: true
    color?: true
    createdAt?: true
    dayId?: true
    endTime?: true
    startTime?: true
    title?: true
    updatedAt?: true
    venue?: true
    _all?: true
  }

  export type AgendaSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaSession to aggregate.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaSessions
    **/
    _count?: true | AgendaSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaSessionMaxAggregateInputType
  }

  export type GetAgendaSessionAggregateType<T extends AgendaSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaSession[P]>
      : GetScalarType<T[P], AggregateAgendaSession[P]>
  }




  export type AgendaSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgendaSessionWhereInput
    orderBy?: AgendaSessionOrderByWithAggregationInput | AgendaSessionOrderByWithAggregationInput[]
    by: AgendaSessionScalarFieldEnum[] | AgendaSessionScalarFieldEnum
    having?: AgendaSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaSessionCountAggregateInputType | true
    _min?: AgendaSessionMinAggregateInputType
    _max?: AgendaSessionMaxAggregateInputType
  }

  export type AgendaSessionGroupByOutputType = {
    id: string
    color: string
    createdAt: Date
    dayId: string
    endTime: string
    startTime: string
    title: string
    updatedAt: Date
    venue: string
    _count: AgendaSessionCountAggregateOutputType | null
    _min: AgendaSessionMinAggregateOutputType | null
    _max: AgendaSessionMaxAggregateOutputType | null
  }

  type GetAgendaSessionGroupByPayload<T extends AgendaSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaSessionGroupByOutputType[P]>
        }
      >
    >


  export type AgendaSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    color?: boolean
    createdAt?: boolean
    dayId?: boolean
    endTime?: boolean
    startTime?: boolean
    title?: boolean
    updatedAt?: boolean
    venue?: boolean
  }, ExtArgs["result"]["agendaSession"]>



  export type AgendaSessionSelectScalar = {
    id?: boolean
    color?: boolean
    createdAt?: boolean
    dayId?: boolean
    endTime?: boolean
    startTime?: boolean
    title?: boolean
    updatedAt?: boolean
    venue?: boolean
  }

  export type AgendaSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "color" | "createdAt" | "dayId" | "endTime" | "startTime" | "title" | "updatedAt" | "venue", ExtArgs["result"]["agendaSession"]>

  export type $AgendaSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgendaSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      color: string
      createdAt: Date
      dayId: string
      endTime: string
      startTime: string
      title: string
      updatedAt: Date
      venue: string
    }, ExtArgs["result"]["agendaSession"]>
    composites: {}
  }

  type AgendaSessionGetPayload<S extends boolean | null | undefined | AgendaSessionDefaultArgs> = $Result.GetResult<Prisma.$AgendaSessionPayload, S>

  type AgendaSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgendaSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaSessionCountAggregateInputType | true
    }

  export interface AgendaSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgendaSession'], meta: { name: 'AgendaSession' } }
    /**
     * Find zero or one AgendaSession that matches the filter.
     * @param {AgendaSessionFindUniqueArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgendaSessionFindUniqueArgs>(args: SelectSubset<T, AgendaSessionFindUniqueArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgendaSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgendaSessionFindUniqueOrThrowArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgendaSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgendaSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindFirstArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgendaSessionFindFirstArgs>(args?: SelectSubset<T, AgendaSessionFindFirstArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgendaSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindFirstOrThrowArgs} args - Arguments to find a AgendaSession
     * @example
     * // Get one AgendaSession
     * const agendaSession = await prisma.agendaSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgendaSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgendaSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaSessions
     * const agendaSessions = await prisma.agendaSession.findMany()
     * 
     * // Get first 10 AgendaSessions
     * const agendaSessions = await prisma.agendaSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaSessionWithIdOnly = await prisma.agendaSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgendaSessionFindManyArgs>(args?: SelectSubset<T, AgendaSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgendaSession.
     * @param {AgendaSessionCreateArgs} args - Arguments to create a AgendaSession.
     * @example
     * // Create one AgendaSession
     * const AgendaSession = await prisma.agendaSession.create({
     *   data: {
     *     // ... data to create a AgendaSession
     *   }
     * })
     * 
     */
    create<T extends AgendaSessionCreateArgs>(args: SelectSubset<T, AgendaSessionCreateArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgendaSessions.
     * @param {AgendaSessionCreateManyArgs} args - Arguments to create many AgendaSessions.
     * @example
     * // Create many AgendaSessions
     * const agendaSession = await prisma.agendaSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgendaSessionCreateManyArgs>(args?: SelectSubset<T, AgendaSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaSession.
     * @param {AgendaSessionDeleteArgs} args - Arguments to delete one AgendaSession.
     * @example
     * // Delete one AgendaSession
     * const AgendaSession = await prisma.agendaSession.delete({
     *   where: {
     *     // ... filter to delete one AgendaSession
     *   }
     * })
     * 
     */
    delete<T extends AgendaSessionDeleteArgs>(args: SelectSubset<T, AgendaSessionDeleteArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgendaSession.
     * @param {AgendaSessionUpdateArgs} args - Arguments to update one AgendaSession.
     * @example
     * // Update one AgendaSession
     * const agendaSession = await prisma.agendaSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgendaSessionUpdateArgs>(args: SelectSubset<T, AgendaSessionUpdateArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgendaSessions.
     * @param {AgendaSessionDeleteManyArgs} args - Arguments to filter AgendaSessions to delete.
     * @example
     * // Delete a few AgendaSessions
     * const { count } = await prisma.agendaSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgendaSessionDeleteManyArgs>(args?: SelectSubset<T, AgendaSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaSessions
     * const agendaSession = await prisma.agendaSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgendaSessionUpdateManyArgs>(args: SelectSubset<T, AgendaSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaSession.
     * @param {AgendaSessionUpsertArgs} args - Arguments to update or create a AgendaSession.
     * @example
     * // Update or create a AgendaSession
     * const agendaSession = await prisma.agendaSession.upsert({
     *   create: {
     *     // ... data to create a AgendaSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaSession we want to update
     *   }
     * })
     */
    upsert<T extends AgendaSessionUpsertArgs>(args: SelectSubset<T, AgendaSessionUpsertArgs<ExtArgs>>): Prisma__AgendaSessionClient<$Result.GetResult<Prisma.$AgendaSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgendaSessions that matches the filter.
     * @param {AgendaSessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaSession = await prisma.agendaSession.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AgendaSessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AgendaSession.
     * @param {AgendaSessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaSession = await prisma.agendaSession.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AgendaSessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AgendaSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionCountArgs} args - Arguments to filter AgendaSessions to count.
     * @example
     * // Count the number of AgendaSessions
     * const count = await prisma.agendaSession.count({
     *   where: {
     *     // ... the filter for the AgendaSessions we want to count
     *   }
     * })
    **/
    count<T extends AgendaSessionCountArgs>(
      args?: Subset<T, AgendaSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaSessionAggregateArgs>(args: Subset<T, AgendaSessionAggregateArgs>): Prisma.PrismaPromise<GetAgendaSessionAggregateType<T>>

    /**
     * Group by AgendaSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaSessionGroupByArgs['orderBy'] }
        : { orderBy?: AgendaSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgendaSession model
   */
  readonly fields: AgendaSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgendaSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgendaSession model
   */
  interface AgendaSessionFieldRefs {
    readonly id: FieldRef<"AgendaSession", 'String'>
    readonly color: FieldRef<"AgendaSession", 'String'>
    readonly createdAt: FieldRef<"AgendaSession", 'DateTime'>
    readonly dayId: FieldRef<"AgendaSession", 'String'>
    readonly endTime: FieldRef<"AgendaSession", 'String'>
    readonly startTime: FieldRef<"AgendaSession", 'String'>
    readonly title: FieldRef<"AgendaSession", 'String'>
    readonly updatedAt: FieldRef<"AgendaSession", 'DateTime'>
    readonly venue: FieldRef<"AgendaSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgendaSession findUnique
   */
  export type AgendaSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession findUniqueOrThrow
   */
  export type AgendaSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession findFirst
   */
  export type AgendaSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaSessions.
     */
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession findFirstOrThrow
   */
  export type AgendaSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter, which AgendaSession to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaSessions.
     */
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession findMany
   */
  export type AgendaSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter, which AgendaSessions to fetch.
     */
    where?: AgendaSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaSessions to fetch.
     */
    orderBy?: AgendaSessionOrderByWithRelationInput | AgendaSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaSessions.
     */
    cursor?: AgendaSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaSessions.
     */
    skip?: number
    distinct?: AgendaSessionScalarFieldEnum | AgendaSessionScalarFieldEnum[]
  }

  /**
   * AgendaSession create
   */
  export type AgendaSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a AgendaSession.
     */
    data: XOR<AgendaSessionCreateInput, AgendaSessionUncheckedCreateInput>
  }

  /**
   * AgendaSession createMany
   */
  export type AgendaSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgendaSessions.
     */
    data: AgendaSessionCreateManyInput | AgendaSessionCreateManyInput[]
  }

  /**
   * AgendaSession update
   */
  export type AgendaSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a AgendaSession.
     */
    data: XOR<AgendaSessionUpdateInput, AgendaSessionUncheckedUpdateInput>
    /**
     * Choose, which AgendaSession to update.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession updateMany
   */
  export type AgendaSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgendaSessions.
     */
    data: XOR<AgendaSessionUpdateManyMutationInput, AgendaSessionUncheckedUpdateManyInput>
    /**
     * Filter which AgendaSessions to update
     */
    where?: AgendaSessionWhereInput
    /**
     * Limit how many AgendaSessions to update.
     */
    limit?: number
  }

  /**
   * AgendaSession upsert
   */
  export type AgendaSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the AgendaSession to update in case it exists.
     */
    where: AgendaSessionWhereUniqueInput
    /**
     * In case the AgendaSession found by the `where` argument doesn't exist, create a new AgendaSession with this data.
     */
    create: XOR<AgendaSessionCreateInput, AgendaSessionUncheckedCreateInput>
    /**
     * In case the AgendaSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgendaSessionUpdateInput, AgendaSessionUncheckedUpdateInput>
  }

  /**
   * AgendaSession delete
   */
  export type AgendaSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
    /**
     * Filter which AgendaSession to delete.
     */
    where: AgendaSessionWhereUniqueInput
  }

  /**
   * AgendaSession deleteMany
   */
  export type AgendaSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgendaSessions to delete
     */
    where?: AgendaSessionWhereInput
    /**
     * Limit how many AgendaSessions to delete.
     */
    limit?: number
  }

  /**
   * AgendaSession findRaw
   */
  export type AgendaSessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaSession aggregateRaw
   */
  export type AgendaSessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AgendaSession without action
   */
  export type AgendaSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgendaSession
     */
    select?: AgendaSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgendaSession
     */
    omit?: AgendaSessionOmit<ExtArgs> | null
  }


  /**
   * Model Attendee
   */

  export type AggregateAttendee = {
    _count: AttendeeCountAggregateOutputType | null
    _min: AttendeeMinAggregateOutputType | null
    _max: AttendeeMaxAggregateOutputType | null
  }

  export type AttendeeMinAggregateOutputType = {
    id: string | null
    checkedIn: boolean | null
    checkinTime: Date | null
    company: string | null
    createdAt: Date | null
    email: string | null
    jobTitle: string | null
    name: string | null
    phone: string | null
    projectId: string | null
    updatedAt: Date | null
  }

  export type AttendeeMaxAggregateOutputType = {
    id: string | null
    checkedIn: boolean | null
    checkinTime: Date | null
    company: string | null
    createdAt: Date | null
    email: string | null
    jobTitle: string | null
    name: string | null
    phone: string | null
    projectId: string | null
    updatedAt: Date | null
  }

  export type AttendeeCountAggregateOutputType = {
    id: number
    checkedIn: number
    checkinTime: number
    company: number
    createdAt: number
    email: number
    jobTitle: number
    name: number
    phone: number
    projectId: number
    updatedAt: number
    _all: number
  }


  export type AttendeeMinAggregateInputType = {
    id?: true
    checkedIn?: true
    checkinTime?: true
    company?: true
    createdAt?: true
    email?: true
    jobTitle?: true
    name?: true
    phone?: true
    projectId?: true
    updatedAt?: true
  }

  export type AttendeeMaxAggregateInputType = {
    id?: true
    checkedIn?: true
    checkinTime?: true
    company?: true
    createdAt?: true
    email?: true
    jobTitle?: true
    name?: true
    phone?: true
    projectId?: true
    updatedAt?: true
  }

  export type AttendeeCountAggregateInputType = {
    id?: true
    checkedIn?: true
    checkinTime?: true
    company?: true
    createdAt?: true
    email?: true
    jobTitle?: true
    name?: true
    phone?: true
    projectId?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendee to aggregate.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendees
    **/
    _count?: true | AttendeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendeeMaxAggregateInputType
  }

  export type GetAttendeeAggregateType<T extends AttendeeAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendee[P]>
      : GetScalarType<T[P], AggregateAttendee[P]>
  }




  export type AttendeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendeeWhereInput
    orderBy?: AttendeeOrderByWithAggregationInput | AttendeeOrderByWithAggregationInput[]
    by: AttendeeScalarFieldEnum[] | AttendeeScalarFieldEnum
    having?: AttendeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendeeCountAggregateInputType | true
    _min?: AttendeeMinAggregateInputType
    _max?: AttendeeMaxAggregateInputType
  }

  export type AttendeeGroupByOutputType = {
    id: string
    checkedIn: boolean
    checkinTime: Date
    company: string
    createdAt: Date
    email: string
    jobTitle: string
    name: string
    phone: string
    projectId: string
    updatedAt: Date
    _count: AttendeeCountAggregateOutputType | null
    _min: AttendeeMinAggregateOutputType | null
    _max: AttendeeMaxAggregateOutputType | null
  }

  type GetAttendeeGroupByPayload<T extends AttendeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendeeGroupByOutputType[P]>
            : GetScalarType<T[P], AttendeeGroupByOutputType[P]>
        }
      >
    >


  export type AttendeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    company?: boolean
    createdAt?: boolean
    email?: boolean
    jobTitle?: boolean
    name?: boolean
    phone?: boolean
    projectId?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["attendee"]>



  export type AttendeeSelectScalar = {
    id?: boolean
    checkedIn?: boolean
    checkinTime?: boolean
    company?: boolean
    createdAt?: boolean
    email?: boolean
    jobTitle?: boolean
    name?: boolean
    phone?: boolean
    projectId?: boolean
    updatedAt?: boolean
  }

  export type AttendeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checkedIn" | "checkinTime" | "company" | "createdAt" | "email" | "jobTitle" | "name" | "phone" | "projectId" | "updatedAt", ExtArgs["result"]["attendee"]>

  export type $AttendeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checkedIn: boolean
      checkinTime: Date
      company: string
      createdAt: Date
      email: string
      jobTitle: string
      name: string
      phone: string
      projectId: string
      updatedAt: Date
    }, ExtArgs["result"]["attendee"]>
    composites: {}
  }

  type AttendeeGetPayload<S extends boolean | null | undefined | AttendeeDefaultArgs> = $Result.GetResult<Prisma.$AttendeePayload, S>

  type AttendeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendeeCountAggregateInputType | true
    }

  export interface AttendeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendee'], meta: { name: 'Attendee' } }
    /**
     * Find zero or one Attendee that matches the filter.
     * @param {AttendeeFindUniqueArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendeeFindUniqueArgs>(args: SelectSubset<T, AttendeeFindUniqueArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendeeFindUniqueOrThrowArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendeeFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindFirstArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendeeFindFirstArgs>(args?: SelectSubset<T, AttendeeFindFirstArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindFirstOrThrowArgs} args - Arguments to find a Attendee
     * @example
     * // Get one Attendee
     * const attendee = await prisma.attendee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendeeFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendees
     * const attendees = await prisma.attendee.findMany()
     * 
     * // Get first 10 Attendees
     * const attendees = await prisma.attendee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendeeWithIdOnly = await prisma.attendee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendeeFindManyArgs>(args?: SelectSubset<T, AttendeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendee.
     * @param {AttendeeCreateArgs} args - Arguments to create a Attendee.
     * @example
     * // Create one Attendee
     * const Attendee = await prisma.attendee.create({
     *   data: {
     *     // ... data to create a Attendee
     *   }
     * })
     * 
     */
    create<T extends AttendeeCreateArgs>(args: SelectSubset<T, AttendeeCreateArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendees.
     * @param {AttendeeCreateManyArgs} args - Arguments to create many Attendees.
     * @example
     * // Create many Attendees
     * const attendee = await prisma.attendee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendeeCreateManyArgs>(args?: SelectSubset<T, AttendeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendee.
     * @param {AttendeeDeleteArgs} args - Arguments to delete one Attendee.
     * @example
     * // Delete one Attendee
     * const Attendee = await prisma.attendee.delete({
     *   where: {
     *     // ... filter to delete one Attendee
     *   }
     * })
     * 
     */
    delete<T extends AttendeeDeleteArgs>(args: SelectSubset<T, AttendeeDeleteArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendee.
     * @param {AttendeeUpdateArgs} args - Arguments to update one Attendee.
     * @example
     * // Update one Attendee
     * const attendee = await prisma.attendee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendeeUpdateArgs>(args: SelectSubset<T, AttendeeUpdateArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendees.
     * @param {AttendeeDeleteManyArgs} args - Arguments to filter Attendees to delete.
     * @example
     * // Delete a few Attendees
     * const { count } = await prisma.attendee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendeeDeleteManyArgs>(args?: SelectSubset<T, AttendeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendees
     * const attendee = await prisma.attendee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendeeUpdateManyArgs>(args: SelectSubset<T, AttendeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendee.
     * @param {AttendeeUpsertArgs} args - Arguments to update or create a Attendee.
     * @example
     * // Update or create a Attendee
     * const attendee = await prisma.attendee.upsert({
     *   create: {
     *     // ... data to create a Attendee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendee we want to update
     *   }
     * })
     */
    upsert<T extends AttendeeUpsertArgs>(args: SelectSubset<T, AttendeeUpsertArgs<ExtArgs>>): Prisma__AttendeeClient<$Result.GetResult<Prisma.$AttendeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * @param {AttendeeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendee = await prisma.attendee.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttendeeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendee.
     * @param {AttendeeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendee = await prisma.attendee.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttendeeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeCountArgs} args - Arguments to filter Attendees to count.
     * @example
     * // Count the number of Attendees
     * const count = await prisma.attendee.count({
     *   where: {
     *     // ... the filter for the Attendees we want to count
     *   }
     * })
    **/
    count<T extends AttendeeCountArgs>(
      args?: Subset<T, AttendeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendeeAggregateArgs>(args: Subset<T, AttendeeAggregateArgs>): Prisma.PrismaPromise<GetAttendeeAggregateType<T>>

    /**
     * Group by Attendee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendeeGroupByArgs['orderBy'] }
        : { orderBy?: AttendeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendee model
   */
  readonly fields: AttendeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendee model
   */
  interface AttendeeFieldRefs {
    readonly id: FieldRef<"Attendee", 'String'>
    readonly checkedIn: FieldRef<"Attendee", 'Boolean'>
    readonly checkinTime: FieldRef<"Attendee", 'DateTime'>
    readonly company: FieldRef<"Attendee", 'String'>
    readonly createdAt: FieldRef<"Attendee", 'DateTime'>
    readonly email: FieldRef<"Attendee", 'String'>
    readonly jobTitle: FieldRef<"Attendee", 'String'>
    readonly name: FieldRef<"Attendee", 'String'>
    readonly phone: FieldRef<"Attendee", 'String'>
    readonly projectId: FieldRef<"Attendee", 'String'>
    readonly updatedAt: FieldRef<"Attendee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendee findUnique
   */
  export type AttendeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee findUniqueOrThrow
   */
  export type AttendeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee findFirst
   */
  export type AttendeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee findFirstOrThrow
   */
  export type AttendeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter, which Attendee to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee findMany
   */
  export type AttendeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where?: AttendeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeeOrderByWithRelationInput | AttendeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendees.
     */
    cursor?: AttendeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    distinct?: AttendeeScalarFieldEnum | AttendeeScalarFieldEnum[]
  }

  /**
   * Attendee create
   */
  export type AttendeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * The data needed to create a Attendee.
     */
    data: XOR<AttendeeCreateInput, AttendeeUncheckedCreateInput>
  }

  /**
   * Attendee createMany
   */
  export type AttendeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendees.
     */
    data: AttendeeCreateManyInput | AttendeeCreateManyInput[]
  }

  /**
   * Attendee update
   */
  export type AttendeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * The data needed to update a Attendee.
     */
    data: XOR<AttendeeUpdateInput, AttendeeUncheckedUpdateInput>
    /**
     * Choose, which Attendee to update.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee updateMany
   */
  export type AttendeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendees.
     */
    data: XOR<AttendeeUpdateManyMutationInput, AttendeeUncheckedUpdateManyInput>
    /**
     * Filter which Attendees to update
     */
    where?: AttendeeWhereInput
    /**
     * Limit how many Attendees to update.
     */
    limit?: number
  }

  /**
   * Attendee upsert
   */
  export type AttendeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * The filter to search for the Attendee to update in case it exists.
     */
    where: AttendeeWhereUniqueInput
    /**
     * In case the Attendee found by the `where` argument doesn't exist, create a new Attendee with this data.
     */
    create: XOR<AttendeeCreateInput, AttendeeUncheckedCreateInput>
    /**
     * In case the Attendee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendeeUpdateInput, AttendeeUncheckedUpdateInput>
  }

  /**
   * Attendee delete
   */
  export type AttendeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
    /**
     * Filter which Attendee to delete.
     */
    where: AttendeeWhereUniqueInput
  }

  /**
   * Attendee deleteMany
   */
  export type AttendeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendees to delete
     */
    where?: AttendeeWhereInput
    /**
     * Limit how many Attendees to delete.
     */
    limit?: number
  }

  /**
   * Attendee findRaw
   */
  export type AttendeeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendee aggregateRaw
   */
  export type AttendeeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendee without action
   */
  export type AttendeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendee
     */
    select?: AttendeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendee
     */
    omit?: AttendeeOmit<ExtArgs> | null
  }


  /**
   * Model Attendees
   */

  export type AggregateAttendees = {
    _count: AttendeesCountAggregateOutputType | null
    _min: AttendeesMinAggregateOutputType | null
    _max: AttendeesMaxAggregateOutputType | null
  }

  export type AttendeesMinAggregateOutputType = {
    id: string | null
  }

  export type AttendeesMaxAggregateOutputType = {
    id: string | null
  }

  export type AttendeesCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type AttendeesMinAggregateInputType = {
    id?: true
  }

  export type AttendeesMaxAggregateInputType = {
    id?: true
  }

  export type AttendeesCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type AttendeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendees to aggregate.
     */
    where?: AttendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeesOrderByWithRelationInput | AttendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendees
    **/
    _count?: true | AttendeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendeesMaxAggregateInputType
  }

  export type GetAttendeesAggregateType<T extends AttendeesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendees[P]>
      : GetScalarType<T[P], AggregateAttendees[P]>
  }




  export type AttendeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendeesWhereInput
    orderBy?: AttendeesOrderByWithAggregationInput | AttendeesOrderByWithAggregationInput[]
    by: AttendeesScalarFieldEnum[] | AttendeesScalarFieldEnum
    having?: AttendeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendeesCountAggregateInputType | true
    _min?: AttendeesMinAggregateInputType
    _max?: AttendeesMaxAggregateInputType
  }

  export type AttendeesGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: AttendeesCountAggregateOutputType | null
    _min: AttendeesMinAggregateOutputType | null
    _max: AttendeesMaxAggregateOutputType | null
  }

  type GetAttendeesGroupByPayload<T extends AttendeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendeesGroupByOutputType[P]>
            : GetScalarType<T[P], AttendeesGroupByOutputType[P]>
        }
      >
    >


  export type AttendeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["attendees"]>



  export type AttendeesSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type AttendeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["attendees"]>

  export type $AttendeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendees"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["attendees"]>
    composites: {}
  }

  type AttendeesGetPayload<S extends boolean | null | undefined | AttendeesDefaultArgs> = $Result.GetResult<Prisma.$AttendeesPayload, S>

  type AttendeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendeesCountAggregateInputType | true
    }

  export interface AttendeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendees'], meta: { name: 'Attendees' } }
    /**
     * Find zero or one Attendees that matches the filter.
     * @param {AttendeesFindUniqueArgs} args - Arguments to find a Attendees
     * @example
     * // Get one Attendees
     * const attendees = await prisma.attendees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendeesFindUniqueArgs>(args: SelectSubset<T, AttendeesFindUniqueArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendeesFindUniqueOrThrowArgs} args - Arguments to find a Attendees
     * @example
     * // Get one Attendees
     * const attendees = await prisma.attendees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendeesFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesFindFirstArgs} args - Arguments to find a Attendees
     * @example
     * // Get one Attendees
     * const attendees = await prisma.attendees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendeesFindFirstArgs>(args?: SelectSubset<T, AttendeesFindFirstArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesFindFirstOrThrowArgs} args - Arguments to find a Attendees
     * @example
     * // Get one Attendees
     * const attendees = await prisma.attendees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendeesFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendees
     * const attendees = await prisma.attendees.findMany()
     * 
     * // Get first 10 Attendees
     * const attendees = await prisma.attendees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendeesWithIdOnly = await prisma.attendees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendeesFindManyArgs>(args?: SelectSubset<T, AttendeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendees.
     * @param {AttendeesCreateArgs} args - Arguments to create a Attendees.
     * @example
     * // Create one Attendees
     * const Attendees = await prisma.attendees.create({
     *   data: {
     *     // ... data to create a Attendees
     *   }
     * })
     * 
     */
    create<T extends AttendeesCreateArgs>(args: SelectSubset<T, AttendeesCreateArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendees.
     * @param {AttendeesCreateManyArgs} args - Arguments to create many Attendees.
     * @example
     * // Create many Attendees
     * const attendees = await prisma.attendees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendeesCreateManyArgs>(args?: SelectSubset<T, AttendeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendees.
     * @param {AttendeesDeleteArgs} args - Arguments to delete one Attendees.
     * @example
     * // Delete one Attendees
     * const Attendees = await prisma.attendees.delete({
     *   where: {
     *     // ... filter to delete one Attendees
     *   }
     * })
     * 
     */
    delete<T extends AttendeesDeleteArgs>(args: SelectSubset<T, AttendeesDeleteArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendees.
     * @param {AttendeesUpdateArgs} args - Arguments to update one Attendees.
     * @example
     * // Update one Attendees
     * const attendees = await prisma.attendees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendeesUpdateArgs>(args: SelectSubset<T, AttendeesUpdateArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendees.
     * @param {AttendeesDeleteManyArgs} args - Arguments to filter Attendees to delete.
     * @example
     * // Delete a few Attendees
     * const { count } = await prisma.attendees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendeesDeleteManyArgs>(args?: SelectSubset<T, AttendeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendees
     * const attendees = await prisma.attendees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendeesUpdateManyArgs>(args: SelectSubset<T, AttendeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendees.
     * @param {AttendeesUpsertArgs} args - Arguments to update or create a Attendees.
     * @example
     * // Update or create a Attendees
     * const attendees = await prisma.attendees.upsert({
     *   create: {
     *     // ... data to create a Attendees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendees we want to update
     *   }
     * })
     */
    upsert<T extends AttendeesUpsertArgs>(args: SelectSubset<T, AttendeesUpsertArgs<ExtArgs>>): Prisma__AttendeesClient<$Result.GetResult<Prisma.$AttendeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendees that matches the filter.
     * @param {AttendeesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendees = await prisma.attendees.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttendeesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendees.
     * @param {AttendeesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendees = await prisma.attendees.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttendeesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesCountArgs} args - Arguments to filter Attendees to count.
     * @example
     * // Count the number of Attendees
     * const count = await prisma.attendees.count({
     *   where: {
     *     // ... the filter for the Attendees we want to count
     *   }
     * })
    **/
    count<T extends AttendeesCountArgs>(
      args?: Subset<T, AttendeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendeesAggregateArgs>(args: Subset<T, AttendeesAggregateArgs>): Prisma.PrismaPromise<GetAttendeesAggregateType<T>>

    /**
     * Group by Attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendeesGroupByArgs['orderBy'] }
        : { orderBy?: AttendeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendees model
   */
  readonly fields: AttendeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendees model
   */
  interface AttendeesFieldRefs {
    readonly id: FieldRef<"Attendees", 'String'>
    readonly projectId: FieldRef<"Attendees", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Attendees findUnique
   */
  export type AttendeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where: AttendeesWhereUniqueInput
  }

  /**
   * Attendees findUniqueOrThrow
   */
  export type AttendeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where: AttendeesWhereUniqueInput
  }

  /**
   * Attendees findFirst
   */
  export type AttendeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where?: AttendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeesOrderByWithRelationInput | AttendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeesScalarFieldEnum | AttendeesScalarFieldEnum[]
  }

  /**
   * Attendees findFirstOrThrow
   */
  export type AttendeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where?: AttendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeesOrderByWithRelationInput | AttendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendees.
     */
    cursor?: AttendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendees.
     */
    distinct?: AttendeesScalarFieldEnum | AttendeesScalarFieldEnum[]
  }

  /**
   * Attendees findMany
   */
  export type AttendeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter, which Attendees to fetch.
     */
    where?: AttendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendees to fetch.
     */
    orderBy?: AttendeesOrderByWithRelationInput | AttendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendees.
     */
    cursor?: AttendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendees.
     */
    skip?: number
    distinct?: AttendeesScalarFieldEnum | AttendeesScalarFieldEnum[]
  }

  /**
   * Attendees create
   */
  export type AttendeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * The data needed to create a Attendees.
     */
    data?: XOR<AttendeesCreateInput, AttendeesUncheckedCreateInput>
  }

  /**
   * Attendees createMany
   */
  export type AttendeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendees.
     */
    data: AttendeesCreateManyInput | AttendeesCreateManyInput[]
  }

  /**
   * Attendees update
   */
  export type AttendeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * The data needed to update a Attendees.
     */
    data: XOR<AttendeesUpdateInput, AttendeesUncheckedUpdateInput>
    /**
     * Choose, which Attendees to update.
     */
    where: AttendeesWhereUniqueInput
  }

  /**
   * Attendees updateMany
   */
  export type AttendeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendees.
     */
    data: XOR<AttendeesUpdateManyMutationInput, AttendeesUncheckedUpdateManyInput>
    /**
     * Filter which Attendees to update
     */
    where?: AttendeesWhereInput
    /**
     * Limit how many Attendees to update.
     */
    limit?: number
  }

  /**
   * Attendees upsert
   */
  export type AttendeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * The filter to search for the Attendees to update in case it exists.
     */
    where: AttendeesWhereUniqueInput
    /**
     * In case the Attendees found by the `where` argument doesn't exist, create a new Attendees with this data.
     */
    create: XOR<AttendeesCreateInput, AttendeesUncheckedCreateInput>
    /**
     * In case the Attendees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendeesUpdateInput, AttendeesUncheckedUpdateInput>
  }

  /**
   * Attendees delete
   */
  export type AttendeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
    /**
     * Filter which Attendees to delete.
     */
    where: AttendeesWhereUniqueInput
  }

  /**
   * Attendees deleteMany
   */
  export type AttendeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendees to delete
     */
    where?: AttendeesWhereInput
    /**
     * Limit how many Attendees to delete.
     */
    limit?: number
  }

  /**
   * Attendees findRaw
   */
  export type AttendeesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendees aggregateRaw
   */
  export type AttendeesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendees without action
   */
  export type AttendeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendees
     */
    select?: AttendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendees
     */
    omit?: AttendeesOmit<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["campaign"]>



  export type CampaignSelectScalar = {
    id?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["campaign"]>

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * @param {CampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const campaign = await prisma.campaign.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CampaignFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Campaign.
     * @param {CampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const campaign = await prisma.campaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CampaignAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data?: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign findRaw
   */
  export type CampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Campaign aggregateRaw
   */
  export type CampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
  }


  /**
   * Model ContactRequest
   */

  export type AggregateContactRequest = {
    _count: ContactRequestCountAggregateOutputType | null
    _min: ContactRequestMinAggregateOutputType | null
    _max: ContactRequestMaxAggregateOutputType | null
  }

  export type ContactRequestMinAggregateOutputType = {
    id: string | null
  }

  export type ContactRequestMaxAggregateOutputType = {
    id: string | null
  }

  export type ContactRequestCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ContactRequestMinAggregateInputType = {
    id?: true
  }

  export type ContactRequestMaxAggregateInputType = {
    id?: true
  }

  export type ContactRequestCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ContactRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactRequest to aggregate.
     */
    where?: ContactRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRequests to fetch.
     */
    orderBy?: ContactRequestOrderByWithRelationInput | ContactRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactRequests
    **/
    _count?: true | ContactRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactRequestMaxAggregateInputType
  }

  export type GetContactRequestAggregateType<T extends ContactRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateContactRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactRequest[P]>
      : GetScalarType<T[P], AggregateContactRequest[P]>
  }




  export type ContactRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactRequestWhereInput
    orderBy?: ContactRequestOrderByWithAggregationInput | ContactRequestOrderByWithAggregationInput[]
    by: ContactRequestScalarFieldEnum[] | ContactRequestScalarFieldEnum
    having?: ContactRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactRequestCountAggregateInputType | true
    _min?: ContactRequestMinAggregateInputType
    _max?: ContactRequestMaxAggregateInputType
  }

  export type ContactRequestGroupByOutputType = {
    id: string
    _count: ContactRequestCountAggregateOutputType | null
    _min: ContactRequestMinAggregateOutputType | null
    _max: ContactRequestMaxAggregateOutputType | null
  }

  type GetContactRequestGroupByPayload<T extends ContactRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ContactRequestGroupByOutputType[P]>
        }
      >
    >


  export type ContactRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["contactRequest"]>



  export type ContactRequestSelectScalar = {
    id?: boolean
  }

  export type ContactRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["contactRequest"]>

  export type $ContactRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["contactRequest"]>
    composites: {}
  }

  type ContactRequestGetPayload<S extends boolean | null | undefined | ContactRequestDefaultArgs> = $Result.GetResult<Prisma.$ContactRequestPayload, S>

  type ContactRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactRequestCountAggregateInputType | true
    }

  export interface ContactRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactRequest'], meta: { name: 'ContactRequest' } }
    /**
     * Find zero or one ContactRequest that matches the filter.
     * @param {ContactRequestFindUniqueArgs} args - Arguments to find a ContactRequest
     * @example
     * // Get one ContactRequest
     * const contactRequest = await prisma.contactRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactRequestFindUniqueArgs>(args: SelectSubset<T, ContactRequestFindUniqueArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactRequestFindUniqueOrThrowArgs} args - Arguments to find a ContactRequest
     * @example
     * // Get one ContactRequest
     * const contactRequest = await prisma.contactRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestFindFirstArgs} args - Arguments to find a ContactRequest
     * @example
     * // Get one ContactRequest
     * const contactRequest = await prisma.contactRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactRequestFindFirstArgs>(args?: SelectSubset<T, ContactRequestFindFirstArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestFindFirstOrThrowArgs} args - Arguments to find a ContactRequest
     * @example
     * // Get one ContactRequest
     * const contactRequest = await prisma.contactRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactRequests
     * const contactRequests = await prisma.contactRequest.findMany()
     * 
     * // Get first 10 ContactRequests
     * const contactRequests = await prisma.contactRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactRequestWithIdOnly = await prisma.contactRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactRequestFindManyArgs>(args?: SelectSubset<T, ContactRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactRequest.
     * @param {ContactRequestCreateArgs} args - Arguments to create a ContactRequest.
     * @example
     * // Create one ContactRequest
     * const ContactRequest = await prisma.contactRequest.create({
     *   data: {
     *     // ... data to create a ContactRequest
     *   }
     * })
     * 
     */
    create<T extends ContactRequestCreateArgs>(args: SelectSubset<T, ContactRequestCreateArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactRequests.
     * @param {ContactRequestCreateManyArgs} args - Arguments to create many ContactRequests.
     * @example
     * // Create many ContactRequests
     * const contactRequest = await prisma.contactRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactRequestCreateManyArgs>(args?: SelectSubset<T, ContactRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactRequest.
     * @param {ContactRequestDeleteArgs} args - Arguments to delete one ContactRequest.
     * @example
     * // Delete one ContactRequest
     * const ContactRequest = await prisma.contactRequest.delete({
     *   where: {
     *     // ... filter to delete one ContactRequest
     *   }
     * })
     * 
     */
    delete<T extends ContactRequestDeleteArgs>(args: SelectSubset<T, ContactRequestDeleteArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactRequest.
     * @param {ContactRequestUpdateArgs} args - Arguments to update one ContactRequest.
     * @example
     * // Update one ContactRequest
     * const contactRequest = await prisma.contactRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactRequestUpdateArgs>(args: SelectSubset<T, ContactRequestUpdateArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactRequests.
     * @param {ContactRequestDeleteManyArgs} args - Arguments to filter ContactRequests to delete.
     * @example
     * // Delete a few ContactRequests
     * const { count } = await prisma.contactRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactRequestDeleteManyArgs>(args?: SelectSubset<T, ContactRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactRequests
     * const contactRequest = await prisma.contactRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactRequestUpdateManyArgs>(args: SelectSubset<T, ContactRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactRequest.
     * @param {ContactRequestUpsertArgs} args - Arguments to update or create a ContactRequest.
     * @example
     * // Update or create a ContactRequest
     * const contactRequest = await prisma.contactRequest.upsert({
     *   create: {
     *     // ... data to create a ContactRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactRequest we want to update
     *   }
     * })
     */
    upsert<T extends ContactRequestUpsertArgs>(args: SelectSubset<T, ContactRequestUpsertArgs<ExtArgs>>): Prisma__ContactRequestClient<$Result.GetResult<Prisma.$ContactRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactRequests that matches the filter.
     * @param {ContactRequestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactRequest = await prisma.contactRequest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContactRequestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactRequest.
     * @param {ContactRequestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactRequest = await prisma.contactRequest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContactRequestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContactRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestCountArgs} args - Arguments to filter ContactRequests to count.
     * @example
     * // Count the number of ContactRequests
     * const count = await prisma.contactRequest.count({
     *   where: {
     *     // ... the filter for the ContactRequests we want to count
     *   }
     * })
    **/
    count<T extends ContactRequestCountArgs>(
      args?: Subset<T, ContactRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactRequestAggregateArgs>(args: Subset<T, ContactRequestAggregateArgs>): Prisma.PrismaPromise<GetContactRequestAggregateType<T>>

    /**
     * Group by ContactRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactRequestGroupByArgs['orderBy'] }
        : { orderBy?: ContactRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactRequest model
   */
  readonly fields: ContactRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactRequest model
   */
  interface ContactRequestFieldRefs {
    readonly id: FieldRef<"ContactRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactRequest findUnique
   */
  export type ContactRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter, which ContactRequest to fetch.
     */
    where: ContactRequestWhereUniqueInput
  }

  /**
   * ContactRequest findUniqueOrThrow
   */
  export type ContactRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter, which ContactRequest to fetch.
     */
    where: ContactRequestWhereUniqueInput
  }

  /**
   * ContactRequest findFirst
   */
  export type ContactRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter, which ContactRequest to fetch.
     */
    where?: ContactRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRequests to fetch.
     */
    orderBy?: ContactRequestOrderByWithRelationInput | ContactRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactRequests.
     */
    cursor?: ContactRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactRequests.
     */
    distinct?: ContactRequestScalarFieldEnum | ContactRequestScalarFieldEnum[]
  }

  /**
   * ContactRequest findFirstOrThrow
   */
  export type ContactRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter, which ContactRequest to fetch.
     */
    where?: ContactRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRequests to fetch.
     */
    orderBy?: ContactRequestOrderByWithRelationInput | ContactRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactRequests.
     */
    cursor?: ContactRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactRequests.
     */
    distinct?: ContactRequestScalarFieldEnum | ContactRequestScalarFieldEnum[]
  }

  /**
   * ContactRequest findMany
   */
  export type ContactRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter, which ContactRequests to fetch.
     */
    where?: ContactRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRequests to fetch.
     */
    orderBy?: ContactRequestOrderByWithRelationInput | ContactRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactRequests.
     */
    cursor?: ContactRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRequests.
     */
    skip?: number
    distinct?: ContactRequestScalarFieldEnum | ContactRequestScalarFieldEnum[]
  }

  /**
   * ContactRequest create
   */
  export type ContactRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactRequest.
     */
    data?: XOR<ContactRequestCreateInput, ContactRequestUncheckedCreateInput>
  }

  /**
   * ContactRequest createMany
   */
  export type ContactRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactRequests.
     */
    data: ContactRequestCreateManyInput | ContactRequestCreateManyInput[]
  }

  /**
   * ContactRequest update
   */
  export type ContactRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactRequest.
     */
    data: XOR<ContactRequestUpdateInput, ContactRequestUncheckedUpdateInput>
    /**
     * Choose, which ContactRequest to update.
     */
    where: ContactRequestWhereUniqueInput
  }

  /**
   * ContactRequest updateMany
   */
  export type ContactRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactRequests.
     */
    data: XOR<ContactRequestUpdateManyMutationInput, ContactRequestUncheckedUpdateManyInput>
    /**
     * Filter which ContactRequests to update
     */
    where?: ContactRequestWhereInput
    /**
     * Limit how many ContactRequests to update.
     */
    limit?: number
  }

  /**
   * ContactRequest upsert
   */
  export type ContactRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactRequest to update in case it exists.
     */
    where: ContactRequestWhereUniqueInput
    /**
     * In case the ContactRequest found by the `where` argument doesn't exist, create a new ContactRequest with this data.
     */
    create: XOR<ContactRequestCreateInput, ContactRequestUncheckedCreateInput>
    /**
     * In case the ContactRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactRequestUpdateInput, ContactRequestUncheckedUpdateInput>
  }

  /**
   * ContactRequest delete
   */
  export type ContactRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
    /**
     * Filter which ContactRequest to delete.
     */
    where: ContactRequestWhereUniqueInput
  }

  /**
   * ContactRequest deleteMany
   */
  export type ContactRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactRequests to delete
     */
    where?: ContactRequestWhereInput
    /**
     * Limit how many ContactRequests to delete.
     */
    limit?: number
  }

  /**
   * ContactRequest findRaw
   */
  export type ContactRequestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactRequest aggregateRaw
   */
  export type ContactRequestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactRequest without action
   */
  export type ContactRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRequest
     */
    select?: ContactRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRequest
     */
    omit?: ContactRequestOmit<ExtArgs> | null
  }


  /**
   * Model Delegate
   */

  export type AggregateDelegate = {
    _count: DelegateCountAggregateOutputType | null
    _avg: DelegateAvgAggregateOutputType | null
    _sum: DelegateSumAggregateOutputType | null
    _min: DelegateMinAggregateOutputType | null
    _max: DelegateMaxAggregateOutputType | null
  }

  export type DelegateAvgAggregateOutputType = {
    priority: number | null
  }

  export type DelegateSumAggregateOutputType = {
    priority: bigint | null
  }

  export type DelegateMinAggregateOutputType = {
    id: string | null
    address: string | null
    booth: string | null
    company: string | null
    createdAt: Date | null
    description: string | null
    email: string | null
    featured: boolean | null
    image: string | null
    jobTitle: string | null
    name: string | null
    phone: string | null
    priority: bigint | null
    projectId: string | null
    status: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type DelegateMaxAggregateOutputType = {
    id: string | null
    address: string | null
    booth: string | null
    company: string | null
    createdAt: Date | null
    description: string | null
    email: string | null
    featured: boolean | null
    image: string | null
    jobTitle: string | null
    name: string | null
    phone: string | null
    priority: bigint | null
    projectId: string | null
    status: string | null
    type: string | null
    updatedAt: Date | null
  }

  export type DelegateCountAggregateOutputType = {
    id: number
    address: number
    booth: number
    company: number
    createdAt: number
    description: number
    email: number
    featured: number
    image: number
    jobTitle: number
    name: number
    phone: number
    priority: number
    projectId: number
    status: number
    type: number
    updatedAt: number
    _all: number
  }


  export type DelegateAvgAggregateInputType = {
    priority?: true
  }

  export type DelegateSumAggregateInputType = {
    priority?: true
  }

  export type DelegateMinAggregateInputType = {
    id?: true
    address?: true
    booth?: true
    company?: true
    createdAt?: true
    description?: true
    email?: true
    featured?: true
    image?: true
    jobTitle?: true
    name?: true
    phone?: true
    priority?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
  }

  export type DelegateMaxAggregateInputType = {
    id?: true
    address?: true
    booth?: true
    company?: true
    createdAt?: true
    description?: true
    email?: true
    featured?: true
    image?: true
    jobTitle?: true
    name?: true
    phone?: true
    priority?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
  }

  export type DelegateCountAggregateInputType = {
    id?: true
    address?: true
    booth?: true
    company?: true
    createdAt?: true
    description?: true
    email?: true
    featured?: true
    image?: true
    jobTitle?: true
    name?: true
    phone?: true
    priority?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
    _all?: true
  }

  export type DelegateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegate to aggregate.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Delegates
    **/
    _count?: true | DelegateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DelegateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DelegateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelegateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelegateMaxAggregateInputType
  }

  export type GetDelegateAggregateType<T extends DelegateAggregateArgs> = {
        [P in keyof T & keyof AggregateDelegate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelegate[P]>
      : GetScalarType<T[P], AggregateDelegate[P]>
  }




  export type DelegateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelegateWhereInput
    orderBy?: DelegateOrderByWithAggregationInput | DelegateOrderByWithAggregationInput[]
    by: DelegateScalarFieldEnum[] | DelegateScalarFieldEnum
    having?: DelegateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelegateCountAggregateInputType | true
    _avg?: DelegateAvgAggregateInputType
    _sum?: DelegateSumAggregateInputType
    _min?: DelegateMinAggregateInputType
    _max?: DelegateMaxAggregateInputType
  }

  export type DelegateGroupByOutputType = {
    id: string
    address: string
    booth: string
    company: string
    createdAt: Date
    description: string
    email: string
    featured: boolean
    image: string
    jobTitle: string
    name: string
    phone: string
    priority: bigint
    projectId: string
    status: string
    type: string
    updatedAt: Date
    _count: DelegateCountAggregateOutputType | null
    _avg: DelegateAvgAggregateOutputType | null
    _sum: DelegateSumAggregateOutputType | null
    _min: DelegateMinAggregateOutputType | null
    _max: DelegateMaxAggregateOutputType | null
  }

  type GetDelegateGroupByPayload<T extends DelegateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelegateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelegateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelegateGroupByOutputType[P]>
            : GetScalarType<T[P], DelegateGroupByOutputType[P]>
        }
      >
    >


  export type DelegateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    booth?: boolean
    company?: boolean
    createdAt?: boolean
    description?: boolean
    email?: boolean
    featured?: boolean
    image?: boolean
    jobTitle?: boolean
    name?: boolean
    phone?: boolean
    priority?: boolean
    projectId?: boolean
    status?: boolean
    type?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["delegate"]>



  export type DelegateSelectScalar = {
    id?: boolean
    address?: boolean
    booth?: boolean
    company?: boolean
    createdAt?: boolean
    description?: boolean
    email?: boolean
    featured?: boolean
    image?: boolean
    jobTitle?: boolean
    name?: boolean
    phone?: boolean
    priority?: boolean
    projectId?: boolean
    status?: boolean
    type?: boolean
    updatedAt?: boolean
  }

  export type DelegateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "address" | "booth" | "company" | "createdAt" | "description" | "email" | "featured" | "image" | "jobTitle" | "name" | "phone" | "priority" | "projectId" | "status" | "type" | "updatedAt", ExtArgs["result"]["delegate"]>

  export type $DelegatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delegate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string
      booth: string
      company: string
      createdAt: Date
      description: string
      email: string
      featured: boolean
      image: string
      jobTitle: string
      name: string
      phone: string
      priority: bigint
      projectId: string
      status: string
      type: string
      updatedAt: Date
    }, ExtArgs["result"]["delegate"]>
    composites: {}
  }

  type DelegateGetPayload<S extends boolean | null | undefined | DelegateDefaultArgs> = $Result.GetResult<Prisma.$DelegatePayload, S>

  type DelegateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DelegateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelegateCountAggregateInputType | true
    }

  export interface DelegateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delegate'], meta: { name: 'Delegate' } }
    /**
     * Find zero or one Delegate that matches the filter.
     * @param {DelegateFindUniqueArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DelegateFindUniqueArgs>(args: SelectSubset<T, DelegateFindUniqueArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delegate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DelegateFindUniqueOrThrowArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DelegateFindUniqueOrThrowArgs>(args: SelectSubset<T, DelegateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindFirstArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DelegateFindFirstArgs>(args?: SelectSubset<T, DelegateFindFirstArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindFirstOrThrowArgs} args - Arguments to find a Delegate
     * @example
     * // Get one Delegate
     * const delegate = await prisma.delegate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DelegateFindFirstOrThrowArgs>(args?: SelectSubset<T, DelegateFindFirstOrThrowArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delegates
     * const delegates = await prisma.delegate.findMany()
     * 
     * // Get first 10 Delegates
     * const delegates = await prisma.delegate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delegateWithIdOnly = await prisma.delegate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DelegateFindManyArgs>(args?: SelectSubset<T, DelegateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delegate.
     * @param {DelegateCreateArgs} args - Arguments to create a Delegate.
     * @example
     * // Create one Delegate
     * const Delegate = await prisma.delegate.create({
     *   data: {
     *     // ... data to create a Delegate
     *   }
     * })
     * 
     */
    create<T extends DelegateCreateArgs>(args: SelectSubset<T, DelegateCreateArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delegates.
     * @param {DelegateCreateManyArgs} args - Arguments to create many Delegates.
     * @example
     * // Create many Delegates
     * const delegate = await prisma.delegate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DelegateCreateManyArgs>(args?: SelectSubset<T, DelegateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Delegate.
     * @param {DelegateDeleteArgs} args - Arguments to delete one Delegate.
     * @example
     * // Delete one Delegate
     * const Delegate = await prisma.delegate.delete({
     *   where: {
     *     // ... filter to delete one Delegate
     *   }
     * })
     * 
     */
    delete<T extends DelegateDeleteArgs>(args: SelectSubset<T, DelegateDeleteArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delegate.
     * @param {DelegateUpdateArgs} args - Arguments to update one Delegate.
     * @example
     * // Update one Delegate
     * const delegate = await prisma.delegate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DelegateUpdateArgs>(args: SelectSubset<T, DelegateUpdateArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delegates.
     * @param {DelegateDeleteManyArgs} args - Arguments to filter Delegates to delete.
     * @example
     * // Delete a few Delegates
     * const { count } = await prisma.delegate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DelegateDeleteManyArgs>(args?: SelectSubset<T, DelegateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delegates
     * const delegate = await prisma.delegate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DelegateUpdateManyArgs>(args: SelectSubset<T, DelegateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delegate.
     * @param {DelegateUpsertArgs} args - Arguments to update or create a Delegate.
     * @example
     * // Update or create a Delegate
     * const delegate = await prisma.delegate.upsert({
     *   create: {
     *     // ... data to create a Delegate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delegate we want to update
     *   }
     * })
     */
    upsert<T extends DelegateUpsertArgs>(args: SelectSubset<T, DelegateUpsertArgs<ExtArgs>>): Prisma__DelegateClient<$Result.GetResult<Prisma.$DelegatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * @param {DelegateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const delegate = await prisma.delegate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DelegateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Delegate.
     * @param {DelegateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const delegate = await prisma.delegate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DelegateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateCountArgs} args - Arguments to filter Delegates to count.
     * @example
     * // Count the number of Delegates
     * const count = await prisma.delegate.count({
     *   where: {
     *     // ... the filter for the Delegates we want to count
     *   }
     * })
    **/
    count<T extends DelegateCountArgs>(
      args?: Subset<T, DelegateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelegateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delegate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelegateAggregateArgs>(args: Subset<T, DelegateAggregateArgs>): Prisma.PrismaPromise<GetDelegateAggregateType<T>>

    /**
     * Group by Delegate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DelegateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DelegateGroupByArgs['orderBy'] }
        : { orderBy?: DelegateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DelegateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelegateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delegate model
   */
  readonly fields: DelegateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delegate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DelegateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delegate model
   */
  interface DelegateFieldRefs {
    readonly id: FieldRef<"Delegate", 'String'>
    readonly address: FieldRef<"Delegate", 'String'>
    readonly booth: FieldRef<"Delegate", 'String'>
    readonly company: FieldRef<"Delegate", 'String'>
    readonly createdAt: FieldRef<"Delegate", 'DateTime'>
    readonly description: FieldRef<"Delegate", 'String'>
    readonly email: FieldRef<"Delegate", 'String'>
    readonly featured: FieldRef<"Delegate", 'Boolean'>
    readonly image: FieldRef<"Delegate", 'String'>
    readonly jobTitle: FieldRef<"Delegate", 'String'>
    readonly name: FieldRef<"Delegate", 'String'>
    readonly phone: FieldRef<"Delegate", 'String'>
    readonly priority: FieldRef<"Delegate", 'BigInt'>
    readonly projectId: FieldRef<"Delegate", 'String'>
    readonly status: FieldRef<"Delegate", 'String'>
    readonly type: FieldRef<"Delegate", 'String'>
    readonly updatedAt: FieldRef<"Delegate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Delegate findUnique
   */
  export type DelegateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate findUniqueOrThrow
   */
  export type DelegateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate findFirst
   */
  export type DelegateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate findFirstOrThrow
   */
  export type DelegateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter, which Delegate to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate findMany
   */
  export type DelegateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where?: DelegateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegateOrderByWithRelationInput | DelegateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Delegates.
     */
    cursor?: DelegateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    distinct?: DelegateScalarFieldEnum | DelegateScalarFieldEnum[]
  }

  /**
   * Delegate create
   */
  export type DelegateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * The data needed to create a Delegate.
     */
    data: XOR<DelegateCreateInput, DelegateUncheckedCreateInput>
  }

  /**
   * Delegate createMany
   */
  export type DelegateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Delegates.
     */
    data: DelegateCreateManyInput | DelegateCreateManyInput[]
  }

  /**
   * Delegate update
   */
  export type DelegateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * The data needed to update a Delegate.
     */
    data: XOR<DelegateUpdateInput, DelegateUncheckedUpdateInput>
    /**
     * Choose, which Delegate to update.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate updateMany
   */
  export type DelegateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Delegates.
     */
    data: XOR<DelegateUpdateManyMutationInput, DelegateUncheckedUpdateManyInput>
    /**
     * Filter which Delegates to update
     */
    where?: DelegateWhereInput
    /**
     * Limit how many Delegates to update.
     */
    limit?: number
  }

  /**
   * Delegate upsert
   */
  export type DelegateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * The filter to search for the Delegate to update in case it exists.
     */
    where: DelegateWhereUniqueInput
    /**
     * In case the Delegate found by the `where` argument doesn't exist, create a new Delegate with this data.
     */
    create: XOR<DelegateCreateInput, DelegateUncheckedCreateInput>
    /**
     * In case the Delegate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DelegateUpdateInput, DelegateUncheckedUpdateInput>
  }

  /**
   * Delegate delete
   */
  export type DelegateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
    /**
     * Filter which Delegate to delete.
     */
    where: DelegateWhereUniqueInput
  }

  /**
   * Delegate deleteMany
   */
  export type DelegateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegates to delete
     */
    where?: DelegateWhereInput
    /**
     * Limit how many Delegates to delete.
     */
    limit?: number
  }

  /**
   * Delegate findRaw
   */
  export type DelegateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegate aggregateRaw
   */
  export type DelegateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegate without action
   */
  export type DelegateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegate
     */
    select?: DelegateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegate
     */
    omit?: DelegateOmit<ExtArgs> | null
  }


  /**
   * Model Delegates
   */

  export type AggregateDelegates = {
    _count: DelegatesCountAggregateOutputType | null
    _min: DelegatesMinAggregateOutputType | null
    _max: DelegatesMaxAggregateOutputType | null
  }

  export type DelegatesMinAggregateOutputType = {
    id: string | null
  }

  export type DelegatesMaxAggregateOutputType = {
    id: string | null
  }

  export type DelegatesCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type DelegatesMinAggregateInputType = {
    id?: true
  }

  export type DelegatesMaxAggregateInputType = {
    id?: true
  }

  export type DelegatesCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type DelegatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegates to aggregate.
     */
    where?: DelegatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegatesOrderByWithRelationInput | DelegatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DelegatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Delegates
    **/
    _count?: true | DelegatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelegatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelegatesMaxAggregateInputType
  }

  export type GetDelegatesAggregateType<T extends DelegatesAggregateArgs> = {
        [P in keyof T & keyof AggregateDelegates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelegates[P]>
      : GetScalarType<T[P], AggregateDelegates[P]>
  }




  export type DelegatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelegatesWhereInput
    orderBy?: DelegatesOrderByWithAggregationInput | DelegatesOrderByWithAggregationInput[]
    by: DelegatesScalarFieldEnum[] | DelegatesScalarFieldEnum
    having?: DelegatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelegatesCountAggregateInputType | true
    _min?: DelegatesMinAggregateInputType
    _max?: DelegatesMaxAggregateInputType
  }

  export type DelegatesGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: DelegatesCountAggregateOutputType | null
    _min: DelegatesMinAggregateOutputType | null
    _max: DelegatesMaxAggregateOutputType | null
  }

  type GetDelegatesGroupByPayload<T extends DelegatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelegatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelegatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelegatesGroupByOutputType[P]>
            : GetScalarType<T[P], DelegatesGroupByOutputType[P]>
        }
      >
    >


  export type DelegatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["delegates"]>



  export type DelegatesSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type DelegatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["delegates"]>

  export type $DelegatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delegates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["delegates"]>
    composites: {}
  }

  type DelegatesGetPayload<S extends boolean | null | undefined | DelegatesDefaultArgs> = $Result.GetResult<Prisma.$DelegatesPayload, S>

  type DelegatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DelegatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelegatesCountAggregateInputType | true
    }

  export interface DelegatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delegates'], meta: { name: 'Delegates' } }
    /**
     * Find zero or one Delegates that matches the filter.
     * @param {DelegatesFindUniqueArgs} args - Arguments to find a Delegates
     * @example
     * // Get one Delegates
     * const delegates = await prisma.delegates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DelegatesFindUniqueArgs>(args: SelectSubset<T, DelegatesFindUniqueArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delegates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DelegatesFindUniqueOrThrowArgs} args - Arguments to find a Delegates
     * @example
     * // Get one Delegates
     * const delegates = await prisma.delegates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DelegatesFindUniqueOrThrowArgs>(args: SelectSubset<T, DelegatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesFindFirstArgs} args - Arguments to find a Delegates
     * @example
     * // Get one Delegates
     * const delegates = await prisma.delegates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DelegatesFindFirstArgs>(args?: SelectSubset<T, DelegatesFindFirstArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delegates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesFindFirstOrThrowArgs} args - Arguments to find a Delegates
     * @example
     * // Get one Delegates
     * const delegates = await prisma.delegates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DelegatesFindFirstOrThrowArgs>(args?: SelectSubset<T, DelegatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Delegates
     * const delegates = await prisma.delegates.findMany()
     * 
     * // Get first 10 Delegates
     * const delegates = await prisma.delegates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delegatesWithIdOnly = await prisma.delegates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DelegatesFindManyArgs>(args?: SelectSubset<T, DelegatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delegates.
     * @param {DelegatesCreateArgs} args - Arguments to create a Delegates.
     * @example
     * // Create one Delegates
     * const Delegates = await prisma.delegates.create({
     *   data: {
     *     // ... data to create a Delegates
     *   }
     * })
     * 
     */
    create<T extends DelegatesCreateArgs>(args: SelectSubset<T, DelegatesCreateArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Delegates.
     * @param {DelegatesCreateManyArgs} args - Arguments to create many Delegates.
     * @example
     * // Create many Delegates
     * const delegates = await prisma.delegates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DelegatesCreateManyArgs>(args?: SelectSubset<T, DelegatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Delegates.
     * @param {DelegatesDeleteArgs} args - Arguments to delete one Delegates.
     * @example
     * // Delete one Delegates
     * const Delegates = await prisma.delegates.delete({
     *   where: {
     *     // ... filter to delete one Delegates
     *   }
     * })
     * 
     */
    delete<T extends DelegatesDeleteArgs>(args: SelectSubset<T, DelegatesDeleteArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delegates.
     * @param {DelegatesUpdateArgs} args - Arguments to update one Delegates.
     * @example
     * // Update one Delegates
     * const delegates = await prisma.delegates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DelegatesUpdateArgs>(args: SelectSubset<T, DelegatesUpdateArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Delegates.
     * @param {DelegatesDeleteManyArgs} args - Arguments to filter Delegates to delete.
     * @example
     * // Delete a few Delegates
     * const { count } = await prisma.delegates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DelegatesDeleteManyArgs>(args?: SelectSubset<T, DelegatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Delegates
     * const delegates = await prisma.delegates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DelegatesUpdateManyArgs>(args: SelectSubset<T, DelegatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delegates.
     * @param {DelegatesUpsertArgs} args - Arguments to update or create a Delegates.
     * @example
     * // Update or create a Delegates
     * const delegates = await prisma.delegates.upsert({
     *   create: {
     *     // ... data to create a Delegates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delegates we want to update
     *   }
     * })
     */
    upsert<T extends DelegatesUpsertArgs>(args: SelectSubset<T, DelegatesUpsertArgs<ExtArgs>>): Prisma__DelegatesClient<$Result.GetResult<Prisma.$DelegatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Delegates that matches the filter.
     * @param {DelegatesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const delegates = await prisma.delegates.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DelegatesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Delegates.
     * @param {DelegatesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const delegates = await prisma.delegates.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DelegatesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesCountArgs} args - Arguments to filter Delegates to count.
     * @example
     * // Count the number of Delegates
     * const count = await prisma.delegates.count({
     *   where: {
     *     // ... the filter for the Delegates we want to count
     *   }
     * })
    **/
    count<T extends DelegatesCountArgs>(
      args?: Subset<T, DelegatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelegatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelegatesAggregateArgs>(args: Subset<T, DelegatesAggregateArgs>): Prisma.PrismaPromise<GetDelegatesAggregateType<T>>

    /**
     * Group by Delegates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelegatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DelegatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DelegatesGroupByArgs['orderBy'] }
        : { orderBy?: DelegatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DelegatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelegatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delegates model
   */
  readonly fields: DelegatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delegates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DelegatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delegates model
   */
  interface DelegatesFieldRefs {
    readonly id: FieldRef<"Delegates", 'String'>
    readonly projectId: FieldRef<"Delegates", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Delegates findUnique
   */
  export type DelegatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where: DelegatesWhereUniqueInput
  }

  /**
   * Delegates findUniqueOrThrow
   */
  export type DelegatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where: DelegatesWhereUniqueInput
  }

  /**
   * Delegates findFirst
   */
  export type DelegatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where?: DelegatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegatesOrderByWithRelationInput | DelegatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegatesScalarFieldEnum | DelegatesScalarFieldEnum[]
  }

  /**
   * Delegates findFirstOrThrow
   */
  export type DelegatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where?: DelegatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegatesOrderByWithRelationInput | DelegatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Delegates.
     */
    cursor?: DelegatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Delegates.
     */
    distinct?: DelegatesScalarFieldEnum | DelegatesScalarFieldEnum[]
  }

  /**
   * Delegates findMany
   */
  export type DelegatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter, which Delegates to fetch.
     */
    where?: DelegatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Delegates to fetch.
     */
    orderBy?: DelegatesOrderByWithRelationInput | DelegatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Delegates.
     */
    cursor?: DelegatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Delegates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Delegates.
     */
    skip?: number
    distinct?: DelegatesScalarFieldEnum | DelegatesScalarFieldEnum[]
  }

  /**
   * Delegates create
   */
  export type DelegatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * The data needed to create a Delegates.
     */
    data?: XOR<DelegatesCreateInput, DelegatesUncheckedCreateInput>
  }

  /**
   * Delegates createMany
   */
  export type DelegatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Delegates.
     */
    data: DelegatesCreateManyInput | DelegatesCreateManyInput[]
  }

  /**
   * Delegates update
   */
  export type DelegatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * The data needed to update a Delegates.
     */
    data: XOR<DelegatesUpdateInput, DelegatesUncheckedUpdateInput>
    /**
     * Choose, which Delegates to update.
     */
    where: DelegatesWhereUniqueInput
  }

  /**
   * Delegates updateMany
   */
  export type DelegatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Delegates.
     */
    data: XOR<DelegatesUpdateManyMutationInput, DelegatesUncheckedUpdateManyInput>
    /**
     * Filter which Delegates to update
     */
    where?: DelegatesWhereInput
    /**
     * Limit how many Delegates to update.
     */
    limit?: number
  }

  /**
   * Delegates upsert
   */
  export type DelegatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * The filter to search for the Delegates to update in case it exists.
     */
    where: DelegatesWhereUniqueInput
    /**
     * In case the Delegates found by the `where` argument doesn't exist, create a new Delegates with this data.
     */
    create: XOR<DelegatesCreateInput, DelegatesUncheckedCreateInput>
    /**
     * In case the Delegates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DelegatesUpdateInput, DelegatesUncheckedUpdateInput>
  }

  /**
   * Delegates delete
   */
  export type DelegatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
    /**
     * Filter which Delegates to delete.
     */
    where: DelegatesWhereUniqueInput
  }

  /**
   * Delegates deleteMany
   */
  export type DelegatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delegates to delete
     */
    where?: DelegatesWhereInput
    /**
     * Limit how many Delegates to delete.
     */
    limit?: number
  }

  /**
   * Delegates findRaw
   */
  export type DelegatesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegates aggregateRaw
   */
  export type DelegatesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Delegates without action
   */
  export type DelegatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delegates
     */
    select?: DelegatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delegates
     */
    omit?: DelegatesOmit<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    code: number
    _all: number
  }


  export type DiscountMinAggregateInputType = {
    id?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    code?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    code: JsonValue | null
    _count: DiscountCountAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
  }, ExtArgs["result"]["discount"]>



  export type DiscountSelectScalar = {
    id?: boolean
    code?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code", ExtArgs["result"]["discount"]>

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      code: Prisma.JsonValue | null
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * @param {DiscountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const discount = await prisma.discount.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DiscountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Discount.
     * @param {DiscountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const discount = await prisma.discount.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DiscountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly code: FieldRef<"Discount", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data?: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount findRaw
   */
  export type DiscountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Discount aggregateRaw
   */
  export type DiscountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
  }


  /**
   * Model Enquiry
   */

  export type AggregateEnquiry = {
    _count: EnquiryCountAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  export type EnquiryMinAggregateOutputType = {
    id: string | null
  }

  export type EnquiryMaxAggregateOutputType = {
    id: string | null
  }

  export type EnquiryCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type EnquiryMinAggregateInputType = {
    id?: true
  }

  export type EnquiryMaxAggregateInputType = {
    id?: true
  }

  export type EnquiryCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type EnquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiry to aggregate.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enquiries
    **/
    _count?: true | EnquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnquiryMaxAggregateInputType
  }

  export type GetEnquiryAggregateType<T extends EnquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateEnquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnquiry[P]>
      : GetScalarType<T[P], AggregateEnquiry[P]>
  }




  export type EnquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithAggregationInput | EnquiryOrderByWithAggregationInput[]
    by: EnquiryScalarFieldEnum[] | EnquiryScalarFieldEnum
    having?: EnquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnquiryCountAggregateInputType | true
    _min?: EnquiryMinAggregateInputType
    _max?: EnquiryMaxAggregateInputType
  }

  export type EnquiryGroupByOutputType = {
    id: string
    _count: EnquiryCountAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  type GetEnquiryGroupByPayload<T extends EnquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
            : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
        }
      >
    >


  export type EnquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["enquiry"]>



  export type EnquirySelectScalar = {
    id?: boolean
  }

  export type EnquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["enquiry"]>

  export type $EnquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enquiry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["enquiry"]>
    composites: {}
  }

  type EnquiryGetPayload<S extends boolean | null | undefined | EnquiryDefaultArgs> = $Result.GetResult<Prisma.$EnquiryPayload, S>

  type EnquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnquiryCountAggregateInputType | true
    }

  export interface EnquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enquiry'], meta: { name: 'Enquiry' } }
    /**
     * Find zero or one Enquiry that matches the filter.
     * @param {EnquiryFindUniqueArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnquiryFindUniqueArgs>(args: SelectSubset<T, EnquiryFindUniqueArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnquiryFindUniqueOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, EnquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnquiryFindFirstArgs>(args?: SelectSubset<T, EnquiryFindFirstArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, EnquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enquiries
     * const enquiries = await prisma.enquiry.findMany()
     * 
     * // Get first 10 Enquiries
     * const enquiries = await prisma.enquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnquiryFindManyArgs>(args?: SelectSubset<T, EnquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enquiry.
     * @param {EnquiryCreateArgs} args - Arguments to create a Enquiry.
     * @example
     * // Create one Enquiry
     * const Enquiry = await prisma.enquiry.create({
     *   data: {
     *     // ... data to create a Enquiry
     *   }
     * })
     * 
     */
    create<T extends EnquiryCreateArgs>(args: SelectSubset<T, EnquiryCreateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enquiries.
     * @param {EnquiryCreateManyArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnquiryCreateManyArgs>(args?: SelectSubset<T, EnquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enquiry.
     * @param {EnquiryDeleteArgs} args - Arguments to delete one Enquiry.
     * @example
     * // Delete one Enquiry
     * const Enquiry = await prisma.enquiry.delete({
     *   where: {
     *     // ... filter to delete one Enquiry
     *   }
     * })
     * 
     */
    delete<T extends EnquiryDeleteArgs>(args: SelectSubset<T, EnquiryDeleteArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enquiry.
     * @param {EnquiryUpdateArgs} args - Arguments to update one Enquiry.
     * @example
     * // Update one Enquiry
     * const enquiry = await prisma.enquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnquiryUpdateArgs>(args: SelectSubset<T, EnquiryUpdateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enquiries.
     * @param {EnquiryDeleteManyArgs} args - Arguments to filter Enquiries to delete.
     * @example
     * // Delete a few Enquiries
     * const { count } = await prisma.enquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnquiryDeleteManyArgs>(args?: SelectSubset<T, EnquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enquiries
     * const enquiry = await prisma.enquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnquiryUpdateManyArgs>(args: SelectSubset<T, EnquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enquiry.
     * @param {EnquiryUpsertArgs} args - Arguments to update or create a Enquiry.
     * @example
     * // Update or create a Enquiry
     * const enquiry = await prisma.enquiry.upsert({
     *   create: {
     *     // ... data to create a Enquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enquiry we want to update
     *   }
     * })
     */
    upsert<T extends EnquiryUpsertArgs>(args: SelectSubset<T, EnquiryUpsertArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enquiries that matches the filter.
     * @param {EnquiryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const enquiry = await prisma.enquiry.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EnquiryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Enquiry.
     * @param {EnquiryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const enquiry = await prisma.enquiry.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EnquiryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCountArgs} args - Arguments to filter Enquiries to count.
     * @example
     * // Count the number of Enquiries
     * const count = await prisma.enquiry.count({
     *   where: {
     *     // ... the filter for the Enquiries we want to count
     *   }
     * })
    **/
    count<T extends EnquiryCountArgs>(
      args?: Subset<T, EnquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnquiryAggregateArgs>(args: Subset<T, EnquiryAggregateArgs>): Prisma.PrismaPromise<GetEnquiryAggregateType<T>>

    /**
     * Group by Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnquiryGroupByArgs['orderBy'] }
        : { orderBy?: EnquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enquiry model
   */
  readonly fields: EnquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enquiry model
   */
  interface EnquiryFieldRefs {
    readonly id: FieldRef<"Enquiry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enquiry findUnique
   */
  export type EnquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findUniqueOrThrow
   */
  export type EnquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findFirst
   */
  export type EnquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findFirstOrThrow
   */
  export type EnquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findMany
   */
  export type EnquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter, which Enquiries to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry create
   */
  export type EnquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * The data needed to create a Enquiry.
     */
    data?: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
  }

  /**
   * Enquiry createMany
   */
  export type EnquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
  }

  /**
   * Enquiry update
   */
  export type EnquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * The data needed to update a Enquiry.
     */
    data: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
    /**
     * Choose, which Enquiry to update.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry updateMany
   */
  export type EnquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enquiries.
     */
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyInput>
    /**
     * Filter which Enquiries to update
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to update.
     */
    limit?: number
  }

  /**
   * Enquiry upsert
   */
  export type EnquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * The filter to search for the Enquiry to update in case it exists.
     */
    where: EnquiryWhereUniqueInput
    /**
     * In case the Enquiry found by the `where` argument doesn't exist, create a new Enquiry with this data.
     */
    create: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
    /**
     * In case the Enquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
  }

  /**
   * Enquiry delete
   */
  export type EnquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Filter which Enquiry to delete.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry deleteMany
   */
  export type EnquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiries to delete
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to delete.
     */
    limit?: number
  }

  /**
   * Enquiry findRaw
   */
  export type EnquiryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enquiry aggregateRaw
   */
  export type EnquiryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enquiry without action
   */
  export type EnquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
  }


  /**
   * Model Exhibitor
   */

  export type AggregateExhibitor = {
    _count: ExhibitorCountAggregateOutputType | null
    _min: ExhibitorMinAggregateOutputType | null
    _max: ExhibitorMaxAggregateOutputType | null
  }

  export type ExhibitorMinAggregateOutputType = {
    id: string | null
    boothNumber: string | null
    category: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    projectId: string | null
    size: string | null
    status: string | null
    updatedAt: Date | null
  }

  export type ExhibitorMaxAggregateOutputType = {
    id: string | null
    boothNumber: string | null
    category: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    projectId: string | null
    size: string | null
    status: string | null
    updatedAt: Date | null
  }

  export type ExhibitorCountAggregateOutputType = {
    id: number
    boothNumber: number
    category: number
    createdAt: number
    image: number
    name: number
    projectId: number
    size: number
    status: number
    updatedAt: number
    _all: number
  }


  export type ExhibitorMinAggregateInputType = {
    id?: true
    boothNumber?: true
    category?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    size?: true
    status?: true
    updatedAt?: true
  }

  export type ExhibitorMaxAggregateInputType = {
    id?: true
    boothNumber?: true
    category?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    size?: true
    status?: true
    updatedAt?: true
  }

  export type ExhibitorCountAggregateInputType = {
    id?: true
    boothNumber?: true
    category?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    size?: true
    status?: true
    updatedAt?: true
    _all?: true
  }

  export type ExhibitorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitor to aggregate.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exhibitors
    **/
    _count?: true | ExhibitorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExhibitorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExhibitorMaxAggregateInputType
  }

  export type GetExhibitorAggregateType<T extends ExhibitorAggregateArgs> = {
        [P in keyof T & keyof AggregateExhibitor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitor[P]>
      : GetScalarType<T[P], AggregateExhibitor[P]>
  }




  export type ExhibitorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExhibitorWhereInput
    orderBy?: ExhibitorOrderByWithAggregationInput | ExhibitorOrderByWithAggregationInput[]
    by: ExhibitorScalarFieldEnum[] | ExhibitorScalarFieldEnum
    having?: ExhibitorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExhibitorCountAggregateInputType | true
    _min?: ExhibitorMinAggregateInputType
    _max?: ExhibitorMaxAggregateInputType
  }

  export type ExhibitorGroupByOutputType = {
    id: string
    boothNumber: string
    category: string
    createdAt: Date
    image: string
    name: string
    projectId: string
    size: string
    status: string
    updatedAt: Date
    _count: ExhibitorCountAggregateOutputType | null
    _min: ExhibitorMinAggregateOutputType | null
    _max: ExhibitorMaxAggregateOutputType | null
  }

  type GetExhibitorGroupByPayload<T extends ExhibitorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExhibitorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExhibitorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitorGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitorGroupByOutputType[P]>
        }
      >
    >


  export type ExhibitorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boothNumber?: boolean
    category?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    projectId?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exhibitor"]>



  export type ExhibitorSelectScalar = {
    id?: boolean
    boothNumber?: boolean
    category?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    projectId?: boolean
    size?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type ExhibitorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "boothNumber" | "category" | "createdAt" | "image" | "name" | "projectId" | "size" | "status" | "updatedAt", ExtArgs["result"]["exhibitor"]>

  export type $ExhibitorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exhibitor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      boothNumber: string
      category: string
      createdAt: Date
      image: string
      name: string
      projectId: string
      size: string
      status: string
      updatedAt: Date
    }, ExtArgs["result"]["exhibitor"]>
    composites: {}
  }

  type ExhibitorGetPayload<S extends boolean | null | undefined | ExhibitorDefaultArgs> = $Result.GetResult<Prisma.$ExhibitorPayload, S>

  type ExhibitorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExhibitorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExhibitorCountAggregateInputType | true
    }

  export interface ExhibitorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exhibitor'], meta: { name: 'Exhibitor' } }
    /**
     * Find zero or one Exhibitor that matches the filter.
     * @param {ExhibitorFindUniqueArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExhibitorFindUniqueArgs>(args: SelectSubset<T, ExhibitorFindUniqueArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exhibitor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExhibitorFindUniqueOrThrowArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExhibitorFindUniqueOrThrowArgs>(args: SelectSubset<T, ExhibitorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindFirstArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExhibitorFindFirstArgs>(args?: SelectSubset<T, ExhibitorFindFirstArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindFirstOrThrowArgs} args - Arguments to find a Exhibitor
     * @example
     * // Get one Exhibitor
     * const exhibitor = await prisma.exhibitor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExhibitorFindFirstOrThrowArgs>(args?: SelectSubset<T, ExhibitorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exhibitors
     * const exhibitors = await prisma.exhibitor.findMany()
     * 
     * // Get first 10 Exhibitors
     * const exhibitors = await prisma.exhibitor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exhibitorWithIdOnly = await prisma.exhibitor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExhibitorFindManyArgs>(args?: SelectSubset<T, ExhibitorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exhibitor.
     * @param {ExhibitorCreateArgs} args - Arguments to create a Exhibitor.
     * @example
     * // Create one Exhibitor
     * const Exhibitor = await prisma.exhibitor.create({
     *   data: {
     *     // ... data to create a Exhibitor
     *   }
     * })
     * 
     */
    create<T extends ExhibitorCreateArgs>(args: SelectSubset<T, ExhibitorCreateArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exhibitors.
     * @param {ExhibitorCreateManyArgs} args - Arguments to create many Exhibitors.
     * @example
     * // Create many Exhibitors
     * const exhibitor = await prisma.exhibitor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExhibitorCreateManyArgs>(args?: SelectSubset<T, ExhibitorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exhibitor.
     * @param {ExhibitorDeleteArgs} args - Arguments to delete one Exhibitor.
     * @example
     * // Delete one Exhibitor
     * const Exhibitor = await prisma.exhibitor.delete({
     *   where: {
     *     // ... filter to delete one Exhibitor
     *   }
     * })
     * 
     */
    delete<T extends ExhibitorDeleteArgs>(args: SelectSubset<T, ExhibitorDeleteArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exhibitor.
     * @param {ExhibitorUpdateArgs} args - Arguments to update one Exhibitor.
     * @example
     * // Update one Exhibitor
     * const exhibitor = await prisma.exhibitor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExhibitorUpdateArgs>(args: SelectSubset<T, ExhibitorUpdateArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exhibitors.
     * @param {ExhibitorDeleteManyArgs} args - Arguments to filter Exhibitors to delete.
     * @example
     * // Delete a few Exhibitors
     * const { count } = await prisma.exhibitor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExhibitorDeleteManyArgs>(args?: SelectSubset<T, ExhibitorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exhibitors
     * const exhibitor = await prisma.exhibitor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExhibitorUpdateManyArgs>(args: SelectSubset<T, ExhibitorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exhibitor.
     * @param {ExhibitorUpsertArgs} args - Arguments to update or create a Exhibitor.
     * @example
     * // Update or create a Exhibitor
     * const exhibitor = await prisma.exhibitor.upsert({
     *   create: {
     *     // ... data to create a Exhibitor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exhibitor we want to update
     *   }
     * })
     */
    upsert<T extends ExhibitorUpsertArgs>(args: SelectSubset<T, ExhibitorUpsertArgs<ExtArgs>>): Prisma__ExhibitorClient<$Result.GetResult<Prisma.$ExhibitorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * @param {ExhibitorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const exhibitor = await prisma.exhibitor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExhibitorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Exhibitor.
     * @param {ExhibitorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const exhibitor = await prisma.exhibitor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExhibitorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorCountArgs} args - Arguments to filter Exhibitors to count.
     * @example
     * // Count the number of Exhibitors
     * const count = await prisma.exhibitor.count({
     *   where: {
     *     // ... the filter for the Exhibitors we want to count
     *   }
     * })
    **/
    count<T extends ExhibitorCountArgs>(
      args?: Subset<T, ExhibitorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExhibitorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exhibitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExhibitorAggregateArgs>(args: Subset<T, ExhibitorAggregateArgs>): Prisma.PrismaPromise<GetExhibitorAggregateType<T>>

    /**
     * Group by Exhibitor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExhibitorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExhibitorGroupByArgs['orderBy'] }
        : { orderBy?: ExhibitorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExhibitorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExhibitorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exhibitor model
   */
  readonly fields: ExhibitorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exhibitor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExhibitorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exhibitor model
   */
  interface ExhibitorFieldRefs {
    readonly id: FieldRef<"Exhibitor", 'String'>
    readonly boothNumber: FieldRef<"Exhibitor", 'String'>
    readonly category: FieldRef<"Exhibitor", 'String'>
    readonly createdAt: FieldRef<"Exhibitor", 'DateTime'>
    readonly image: FieldRef<"Exhibitor", 'String'>
    readonly name: FieldRef<"Exhibitor", 'String'>
    readonly projectId: FieldRef<"Exhibitor", 'String'>
    readonly size: FieldRef<"Exhibitor", 'String'>
    readonly status: FieldRef<"Exhibitor", 'String'>
    readonly updatedAt: FieldRef<"Exhibitor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exhibitor findUnique
   */
  export type ExhibitorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor findUniqueOrThrow
   */
  export type ExhibitorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor findFirst
   */
  export type ExhibitorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor findFirstOrThrow
   */
  export type ExhibitorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitor to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor findMany
   */
  export type ExhibitorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where?: ExhibitorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorOrderByWithRelationInput | ExhibitorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exhibitors.
     */
    cursor?: ExhibitorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    distinct?: ExhibitorScalarFieldEnum | ExhibitorScalarFieldEnum[]
  }

  /**
   * Exhibitor create
   */
  export type ExhibitorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * The data needed to create a Exhibitor.
     */
    data: XOR<ExhibitorCreateInput, ExhibitorUncheckedCreateInput>
  }

  /**
   * Exhibitor createMany
   */
  export type ExhibitorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exhibitors.
     */
    data: ExhibitorCreateManyInput | ExhibitorCreateManyInput[]
  }

  /**
   * Exhibitor update
   */
  export type ExhibitorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * The data needed to update a Exhibitor.
     */
    data: XOR<ExhibitorUpdateInput, ExhibitorUncheckedUpdateInput>
    /**
     * Choose, which Exhibitor to update.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor updateMany
   */
  export type ExhibitorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exhibitors.
     */
    data: XOR<ExhibitorUpdateManyMutationInput, ExhibitorUncheckedUpdateManyInput>
    /**
     * Filter which Exhibitors to update
     */
    where?: ExhibitorWhereInput
    /**
     * Limit how many Exhibitors to update.
     */
    limit?: number
  }

  /**
   * Exhibitor upsert
   */
  export type ExhibitorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * The filter to search for the Exhibitor to update in case it exists.
     */
    where: ExhibitorWhereUniqueInput
    /**
     * In case the Exhibitor found by the `where` argument doesn't exist, create a new Exhibitor with this data.
     */
    create: XOR<ExhibitorCreateInput, ExhibitorUncheckedCreateInput>
    /**
     * In case the Exhibitor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExhibitorUpdateInput, ExhibitorUncheckedUpdateInput>
  }

  /**
   * Exhibitor delete
   */
  export type ExhibitorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
    /**
     * Filter which Exhibitor to delete.
     */
    where: ExhibitorWhereUniqueInput
  }

  /**
   * Exhibitor deleteMany
   */
  export type ExhibitorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitors to delete
     */
    where?: ExhibitorWhereInput
    /**
     * Limit how many Exhibitors to delete.
     */
    limit?: number
  }

  /**
   * Exhibitor findRaw
   */
  export type ExhibitorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitor aggregateRaw
   */
  export type ExhibitorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitor without action
   */
  export type ExhibitorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitor
     */
    select?: ExhibitorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitor
     */
    omit?: ExhibitorOmit<ExtArgs> | null
  }


  /**
   * Model Exhibitors
   */

  export type AggregateExhibitors = {
    _count: ExhibitorsCountAggregateOutputType | null
    _min: ExhibitorsMinAggregateOutputType | null
    _max: ExhibitorsMaxAggregateOutputType | null
  }

  export type ExhibitorsMinAggregateOutputType = {
    id: string | null
  }

  export type ExhibitorsMaxAggregateOutputType = {
    id: string | null
  }

  export type ExhibitorsCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type ExhibitorsMinAggregateInputType = {
    id?: true
  }

  export type ExhibitorsMaxAggregateInputType = {
    id?: true
  }

  export type ExhibitorsCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type ExhibitorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitors to aggregate.
     */
    where?: ExhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorsOrderByWithRelationInput | ExhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exhibitors
    **/
    _count?: true | ExhibitorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExhibitorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExhibitorsMaxAggregateInputType
  }

  export type GetExhibitorsAggregateType<T extends ExhibitorsAggregateArgs> = {
        [P in keyof T & keyof AggregateExhibitors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitors[P]>
      : GetScalarType<T[P], AggregateExhibitors[P]>
  }




  export type ExhibitorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExhibitorsWhereInput
    orderBy?: ExhibitorsOrderByWithAggregationInput | ExhibitorsOrderByWithAggregationInput[]
    by: ExhibitorsScalarFieldEnum[] | ExhibitorsScalarFieldEnum
    having?: ExhibitorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExhibitorsCountAggregateInputType | true
    _min?: ExhibitorsMinAggregateInputType
    _max?: ExhibitorsMaxAggregateInputType
  }

  export type ExhibitorsGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: ExhibitorsCountAggregateOutputType | null
    _min: ExhibitorsMinAggregateOutputType | null
    _max: ExhibitorsMaxAggregateOutputType | null
  }

  type GetExhibitorsGroupByPayload<T extends ExhibitorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExhibitorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExhibitorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitorsGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitorsGroupByOutputType[P]>
        }
      >
    >


  export type ExhibitorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["exhibitors"]>



  export type ExhibitorsSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type ExhibitorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["exhibitors"]>

  export type $ExhibitorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exhibitors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["exhibitors"]>
    composites: {}
  }

  type ExhibitorsGetPayload<S extends boolean | null | undefined | ExhibitorsDefaultArgs> = $Result.GetResult<Prisma.$ExhibitorsPayload, S>

  type ExhibitorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExhibitorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExhibitorsCountAggregateInputType | true
    }

  export interface ExhibitorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exhibitors'], meta: { name: 'Exhibitors' } }
    /**
     * Find zero or one Exhibitors that matches the filter.
     * @param {ExhibitorsFindUniqueArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExhibitorsFindUniqueArgs>(args: SelectSubset<T, ExhibitorsFindUniqueArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exhibitors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExhibitorsFindUniqueOrThrowArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExhibitorsFindUniqueOrThrowArgs>(args: SelectSubset<T, ExhibitorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsFindFirstArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExhibitorsFindFirstArgs>(args?: SelectSubset<T, ExhibitorsFindFirstArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsFindFirstOrThrowArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExhibitorsFindFirstOrThrowArgs>(args?: SelectSubset<T, ExhibitorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exhibitors
     * const exhibitors = await prisma.exhibitors.findMany()
     * 
     * // Get first 10 Exhibitors
     * const exhibitors = await prisma.exhibitors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exhibitorsWithIdOnly = await prisma.exhibitors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExhibitorsFindManyArgs>(args?: SelectSubset<T, ExhibitorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exhibitors.
     * @param {ExhibitorsCreateArgs} args - Arguments to create a Exhibitors.
     * @example
     * // Create one Exhibitors
     * const Exhibitors = await prisma.exhibitors.create({
     *   data: {
     *     // ... data to create a Exhibitors
     *   }
     * })
     * 
     */
    create<T extends ExhibitorsCreateArgs>(args: SelectSubset<T, ExhibitorsCreateArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exhibitors.
     * @param {ExhibitorsCreateManyArgs} args - Arguments to create many Exhibitors.
     * @example
     * // Create many Exhibitors
     * const exhibitors = await prisma.exhibitors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExhibitorsCreateManyArgs>(args?: SelectSubset<T, ExhibitorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exhibitors.
     * @param {ExhibitorsDeleteArgs} args - Arguments to delete one Exhibitors.
     * @example
     * // Delete one Exhibitors
     * const Exhibitors = await prisma.exhibitors.delete({
     *   where: {
     *     // ... filter to delete one Exhibitors
     *   }
     * })
     * 
     */
    delete<T extends ExhibitorsDeleteArgs>(args: SelectSubset<T, ExhibitorsDeleteArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exhibitors.
     * @param {ExhibitorsUpdateArgs} args - Arguments to update one Exhibitors.
     * @example
     * // Update one Exhibitors
     * const exhibitors = await prisma.exhibitors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExhibitorsUpdateArgs>(args: SelectSubset<T, ExhibitorsUpdateArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exhibitors.
     * @param {ExhibitorsDeleteManyArgs} args - Arguments to filter Exhibitors to delete.
     * @example
     * // Delete a few Exhibitors
     * const { count } = await prisma.exhibitors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExhibitorsDeleteManyArgs>(args?: SelectSubset<T, ExhibitorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exhibitors
     * const exhibitors = await prisma.exhibitors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExhibitorsUpdateManyArgs>(args: SelectSubset<T, ExhibitorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exhibitors.
     * @param {ExhibitorsUpsertArgs} args - Arguments to update or create a Exhibitors.
     * @example
     * // Update or create a Exhibitors
     * const exhibitors = await prisma.exhibitors.upsert({
     *   create: {
     *     // ... data to create a Exhibitors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exhibitors we want to update
     *   }
     * })
     */
    upsert<T extends ExhibitorsUpsertArgs>(args: SelectSubset<T, ExhibitorsUpsertArgs<ExtArgs>>): Prisma__ExhibitorsClient<$Result.GetResult<Prisma.$ExhibitorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * @param {ExhibitorsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const exhibitors = await prisma.exhibitors.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExhibitorsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Exhibitors.
     * @param {ExhibitorsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const exhibitors = await prisma.exhibitors.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExhibitorsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsCountArgs} args - Arguments to filter Exhibitors to count.
     * @example
     * // Count the number of Exhibitors
     * const count = await prisma.exhibitors.count({
     *   where: {
     *     // ... the filter for the Exhibitors we want to count
     *   }
     * })
    **/
    count<T extends ExhibitorsCountArgs>(
      args?: Subset<T, ExhibitorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExhibitorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExhibitorsAggregateArgs>(args: Subset<T, ExhibitorsAggregateArgs>): Prisma.PrismaPromise<GetExhibitorsAggregateType<T>>

    /**
     * Group by Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExhibitorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExhibitorsGroupByArgs['orderBy'] }
        : { orderBy?: ExhibitorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExhibitorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExhibitorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exhibitors model
   */
  readonly fields: ExhibitorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exhibitors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExhibitorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exhibitors model
   */
  interface ExhibitorsFieldRefs {
    readonly id: FieldRef<"Exhibitors", 'String'>
    readonly projectId: FieldRef<"Exhibitors", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Exhibitors findUnique
   */
  export type ExhibitorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where: ExhibitorsWhereUniqueInput
  }

  /**
   * Exhibitors findUniqueOrThrow
   */
  export type ExhibitorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where: ExhibitorsWhereUniqueInput
  }

  /**
   * Exhibitors findFirst
   */
  export type ExhibitorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where?: ExhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorsOrderByWithRelationInput | ExhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * Exhibitors findFirstOrThrow
   */
  export type ExhibitorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where?: ExhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorsOrderByWithRelationInput | ExhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exhibitors.
     */
    cursor?: ExhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exhibitors.
     */
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * Exhibitors findMany
   */
  export type ExhibitorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which Exhibitors to fetch.
     */
    where?: ExhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exhibitors to fetch.
     */
    orderBy?: ExhibitorsOrderByWithRelationInput | ExhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exhibitors.
     */
    cursor?: ExhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exhibitors.
     */
    skip?: number
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * Exhibitors create
   */
  export type ExhibitorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * The data needed to create a Exhibitors.
     */
    data?: XOR<ExhibitorsCreateInput, ExhibitorsUncheckedCreateInput>
  }

  /**
   * Exhibitors createMany
   */
  export type ExhibitorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exhibitors.
     */
    data: ExhibitorsCreateManyInput | ExhibitorsCreateManyInput[]
  }

  /**
   * Exhibitors update
   */
  export type ExhibitorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * The data needed to update a Exhibitors.
     */
    data: XOR<ExhibitorsUpdateInput, ExhibitorsUncheckedUpdateInput>
    /**
     * Choose, which Exhibitors to update.
     */
    where: ExhibitorsWhereUniqueInput
  }

  /**
   * Exhibitors updateMany
   */
  export type ExhibitorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exhibitors.
     */
    data: XOR<ExhibitorsUpdateManyMutationInput, ExhibitorsUncheckedUpdateManyInput>
    /**
     * Filter which Exhibitors to update
     */
    where?: ExhibitorsWhereInput
    /**
     * Limit how many Exhibitors to update.
     */
    limit?: number
  }

  /**
   * Exhibitors upsert
   */
  export type ExhibitorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * The filter to search for the Exhibitors to update in case it exists.
     */
    where: ExhibitorsWhereUniqueInput
    /**
     * In case the Exhibitors found by the `where` argument doesn't exist, create a new Exhibitors with this data.
     */
    create: XOR<ExhibitorsCreateInput, ExhibitorsUncheckedCreateInput>
    /**
     * In case the Exhibitors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExhibitorsUpdateInput, ExhibitorsUncheckedUpdateInput>
  }

  /**
   * Exhibitors delete
   */
  export type ExhibitorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
    /**
     * Filter which Exhibitors to delete.
     */
    where: ExhibitorsWhereUniqueInput
  }

  /**
   * Exhibitors deleteMany
   */
  export type ExhibitorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exhibitors to delete
     */
    where?: ExhibitorsWhereInput
    /**
     * Limit how many Exhibitors to delete.
     */
    limit?: number
  }

  /**
   * Exhibitors findRaw
   */
  export type ExhibitorsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitors aggregateRaw
   */
  export type ExhibitorsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Exhibitors without action
   */
  export type ExhibitorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exhibitors
     */
    select?: ExhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exhibitors
     */
    omit?: ExhibitorsOmit<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["lead"]>



  export type LeadSelectScalar = {
    id?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["lead"]>

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * @param {LeadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const lead = await prisma.lead.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LeadFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Lead.
     * @param {LeadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const lead = await prisma.lead.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LeadAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data?: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead findRaw
   */
  export type LeadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead aggregateRaw
   */
  export type LeadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
  }


  /**
   * Model Marketing
   */

  export type AggregateMarketing = {
    _count: MarketingCountAggregateOutputType | null
    _min: MarketingMinAggregateOutputType | null
    _max: MarketingMaxAggregateOutputType | null
  }

  export type MarketingMinAggregateOutputType = {
    id: string | null
  }

  export type MarketingMaxAggregateOutputType = {
    id: string | null
  }

  export type MarketingCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type MarketingMinAggregateInputType = {
    id?: true
  }

  export type MarketingMaxAggregateInputType = {
    id?: true
  }

  export type MarketingCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type MarketingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marketing to aggregate.
     */
    where?: MarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketings to fetch.
     */
    orderBy?: MarketingOrderByWithRelationInput | MarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Marketings
    **/
    _count?: true | MarketingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingMaxAggregateInputType
  }

  export type GetMarketingAggregateType<T extends MarketingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketing[P]>
      : GetScalarType<T[P], AggregateMarketing[P]>
  }




  export type MarketingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingWhereInput
    orderBy?: MarketingOrderByWithAggregationInput | MarketingOrderByWithAggregationInput[]
    by: MarketingScalarFieldEnum[] | MarketingScalarFieldEnum
    having?: MarketingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingCountAggregateInputType | true
    _min?: MarketingMinAggregateInputType
    _max?: MarketingMaxAggregateInputType
  }

  export type MarketingGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: MarketingCountAggregateOutputType | null
    _min: MarketingMinAggregateOutputType | null
    _max: MarketingMaxAggregateOutputType | null
  }

  type GetMarketingGroupByPayload<T extends MarketingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingGroupByOutputType[P]>
        }
      >
    >


  export type MarketingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["marketing"]>



  export type MarketingSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type MarketingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["marketing"]>

  export type $MarketingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Marketing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["marketing"]>
    composites: {}
  }

  type MarketingGetPayload<S extends boolean | null | undefined | MarketingDefaultArgs> = $Result.GetResult<Prisma.$MarketingPayload, S>

  type MarketingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingCountAggregateInputType | true
    }

  export interface MarketingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marketing'], meta: { name: 'Marketing' } }
    /**
     * Find zero or one Marketing that matches the filter.
     * @param {MarketingFindUniqueArgs} args - Arguments to find a Marketing
     * @example
     * // Get one Marketing
     * const marketing = await prisma.marketing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingFindUniqueArgs>(args: SelectSubset<T, MarketingFindUniqueArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marketing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingFindUniqueOrThrowArgs} args - Arguments to find a Marketing
     * @example
     * // Get one Marketing
     * const marketing = await prisma.marketing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marketing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingFindFirstArgs} args - Arguments to find a Marketing
     * @example
     * // Get one Marketing
     * const marketing = await prisma.marketing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingFindFirstArgs>(args?: SelectSubset<T, MarketingFindFirstArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marketing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingFindFirstOrThrowArgs} args - Arguments to find a Marketing
     * @example
     * // Get one Marketing
     * const marketing = await prisma.marketing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marketings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marketings
     * const marketings = await prisma.marketing.findMany()
     * 
     * // Get first 10 Marketings
     * const marketings = await prisma.marketing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingWithIdOnly = await prisma.marketing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingFindManyArgs>(args?: SelectSubset<T, MarketingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marketing.
     * @param {MarketingCreateArgs} args - Arguments to create a Marketing.
     * @example
     * // Create one Marketing
     * const Marketing = await prisma.marketing.create({
     *   data: {
     *     // ... data to create a Marketing
     *   }
     * })
     * 
     */
    create<T extends MarketingCreateArgs>(args: SelectSubset<T, MarketingCreateArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marketings.
     * @param {MarketingCreateManyArgs} args - Arguments to create many Marketings.
     * @example
     * // Create many Marketings
     * const marketing = await prisma.marketing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingCreateManyArgs>(args?: SelectSubset<T, MarketingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marketing.
     * @param {MarketingDeleteArgs} args - Arguments to delete one Marketing.
     * @example
     * // Delete one Marketing
     * const Marketing = await prisma.marketing.delete({
     *   where: {
     *     // ... filter to delete one Marketing
     *   }
     * })
     * 
     */
    delete<T extends MarketingDeleteArgs>(args: SelectSubset<T, MarketingDeleteArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marketing.
     * @param {MarketingUpdateArgs} args - Arguments to update one Marketing.
     * @example
     * // Update one Marketing
     * const marketing = await prisma.marketing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingUpdateArgs>(args: SelectSubset<T, MarketingUpdateArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marketings.
     * @param {MarketingDeleteManyArgs} args - Arguments to filter Marketings to delete.
     * @example
     * // Delete a few Marketings
     * const { count } = await prisma.marketing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingDeleteManyArgs>(args?: SelectSubset<T, MarketingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marketings
     * const marketing = await prisma.marketing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingUpdateManyArgs>(args: SelectSubset<T, MarketingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marketing.
     * @param {MarketingUpsertArgs} args - Arguments to update or create a Marketing.
     * @example
     * // Update or create a Marketing
     * const marketing = await prisma.marketing.upsert({
     *   create: {
     *     // ... data to create a Marketing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marketing we want to update
     *   }
     * })
     */
    upsert<T extends MarketingUpsertArgs>(args: SelectSubset<T, MarketingUpsertArgs<ExtArgs>>): Prisma__MarketingClient<$Result.GetResult<Prisma.$MarketingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marketings that matches the filter.
     * @param {MarketingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketing = await prisma.marketing.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Marketing.
     * @param {MarketingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketing = await prisma.marketing.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Marketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCountArgs} args - Arguments to filter Marketings to count.
     * @example
     * // Count the number of Marketings
     * const count = await prisma.marketing.count({
     *   where: {
     *     // ... the filter for the Marketings we want to count
     *   }
     * })
    **/
    count<T extends MarketingCountArgs>(
      args?: Subset<T, MarketingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingAggregateArgs>(args: Subset<T, MarketingAggregateArgs>): Prisma.PrismaPromise<GetMarketingAggregateType<T>>

    /**
     * Group by Marketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingGroupByArgs['orderBy'] }
        : { orderBy?: MarketingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Marketing model
   */
  readonly fields: MarketingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Marketing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Marketing model
   */
  interface MarketingFieldRefs {
    readonly id: FieldRef<"Marketing", 'String'>
    readonly projectId: FieldRef<"Marketing", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Marketing findUnique
   */
  export type MarketingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter, which Marketing to fetch.
     */
    where: MarketingWhereUniqueInput
  }

  /**
   * Marketing findUniqueOrThrow
   */
  export type MarketingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter, which Marketing to fetch.
     */
    where: MarketingWhereUniqueInput
  }

  /**
   * Marketing findFirst
   */
  export type MarketingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter, which Marketing to fetch.
     */
    where?: MarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketings to fetch.
     */
    orderBy?: MarketingOrderByWithRelationInput | MarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marketings.
     */
    cursor?: MarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marketings.
     */
    distinct?: MarketingScalarFieldEnum | MarketingScalarFieldEnum[]
  }

  /**
   * Marketing findFirstOrThrow
   */
  export type MarketingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter, which Marketing to fetch.
     */
    where?: MarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketings to fetch.
     */
    orderBy?: MarketingOrderByWithRelationInput | MarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Marketings.
     */
    cursor?: MarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Marketings.
     */
    distinct?: MarketingScalarFieldEnum | MarketingScalarFieldEnum[]
  }

  /**
   * Marketing findMany
   */
  export type MarketingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter, which Marketings to fetch.
     */
    where?: MarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Marketings to fetch.
     */
    orderBy?: MarketingOrderByWithRelationInput | MarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Marketings.
     */
    cursor?: MarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Marketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Marketings.
     */
    skip?: number
    distinct?: MarketingScalarFieldEnum | MarketingScalarFieldEnum[]
  }

  /**
   * Marketing create
   */
  export type MarketingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * The data needed to create a Marketing.
     */
    data?: XOR<MarketingCreateInput, MarketingUncheckedCreateInput>
  }

  /**
   * Marketing createMany
   */
  export type MarketingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Marketings.
     */
    data: MarketingCreateManyInput | MarketingCreateManyInput[]
  }

  /**
   * Marketing update
   */
  export type MarketingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * The data needed to update a Marketing.
     */
    data: XOR<MarketingUpdateInput, MarketingUncheckedUpdateInput>
    /**
     * Choose, which Marketing to update.
     */
    where: MarketingWhereUniqueInput
  }

  /**
   * Marketing updateMany
   */
  export type MarketingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Marketings.
     */
    data: XOR<MarketingUpdateManyMutationInput, MarketingUncheckedUpdateManyInput>
    /**
     * Filter which Marketings to update
     */
    where?: MarketingWhereInput
    /**
     * Limit how many Marketings to update.
     */
    limit?: number
  }

  /**
   * Marketing upsert
   */
  export type MarketingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * The filter to search for the Marketing to update in case it exists.
     */
    where: MarketingWhereUniqueInput
    /**
     * In case the Marketing found by the `where` argument doesn't exist, create a new Marketing with this data.
     */
    create: XOR<MarketingCreateInput, MarketingUncheckedCreateInput>
    /**
     * In case the Marketing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingUpdateInput, MarketingUncheckedUpdateInput>
  }

  /**
   * Marketing delete
   */
  export type MarketingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
    /**
     * Filter which Marketing to delete.
     */
    where: MarketingWhereUniqueInput
  }

  /**
   * Marketing deleteMany
   */
  export type MarketingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Marketings to delete
     */
    where?: MarketingWhereInput
    /**
     * Limit how many Marketings to delete.
     */
    limit?: number
  }

  /**
   * Marketing findRaw
   */
  export type MarketingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Marketing aggregateRaw
   */
  export type MarketingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Marketing without action
   */
  export type MarketingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marketing
     */
    select?: MarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Marketing
     */
    omit?: MarketingOmit<ExtArgs> | null
  }


  /**
   * Model MarketingCampaign
   */

  export type AggregateMarketingCampaign = {
    _count: MarketingCampaignCountAggregateOutputType | null
    _min: MarketingCampaignMinAggregateOutputType | null
    _max: MarketingCampaignMaxAggregateOutputType | null
  }

  export type MarketingCampaignMinAggregateOutputType = {
    id: string | null
  }

  export type MarketingCampaignMaxAggregateOutputType = {
    id: string | null
  }

  export type MarketingCampaignCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type MarketingCampaignMinAggregateInputType = {
    id?: true
  }

  export type MarketingCampaignMaxAggregateInputType = {
    id?: true
  }

  export type MarketingCampaignCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type MarketingCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingCampaign to aggregate.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingCampaigns
    **/
    _count?: true | MarketingCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingCampaignMaxAggregateInputType
  }

  export type GetMarketingCampaignAggregateType<T extends MarketingCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingCampaign[P]>
      : GetScalarType<T[P], AggregateMarketingCampaign[P]>
  }




  export type MarketingCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingCampaignWhereInput
    orderBy?: MarketingCampaignOrderByWithAggregationInput | MarketingCampaignOrderByWithAggregationInput[]
    by: MarketingCampaignScalarFieldEnum[] | MarketingCampaignScalarFieldEnum
    having?: MarketingCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingCampaignCountAggregateInputType | true
    _min?: MarketingCampaignMinAggregateInputType
    _max?: MarketingCampaignMaxAggregateInputType
  }

  export type MarketingCampaignGroupByOutputType = {
    id: string
    _count: MarketingCampaignCountAggregateOutputType | null
    _min: MarketingCampaignMinAggregateOutputType | null
    _max: MarketingCampaignMaxAggregateOutputType | null
  }

  type GetMarketingCampaignGroupByPayload<T extends MarketingCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingCampaignGroupByOutputType[P]>
        }
      >
    >


  export type MarketingCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["marketingCampaign"]>



  export type MarketingCampaignSelectScalar = {
    id?: boolean
  }

  export type MarketingCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["marketingCampaign"]>

  export type $MarketingCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingCampaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["marketingCampaign"]>
    composites: {}
  }

  type MarketingCampaignGetPayload<S extends boolean | null | undefined | MarketingCampaignDefaultArgs> = $Result.GetResult<Prisma.$MarketingCampaignPayload, S>

  type MarketingCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingCampaignCountAggregateInputType | true
    }

  export interface MarketingCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingCampaign'], meta: { name: 'MarketingCampaign' } }
    /**
     * Find zero or one MarketingCampaign that matches the filter.
     * @param {MarketingCampaignFindUniqueArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingCampaignFindUniqueArgs>(args: SelectSubset<T, MarketingCampaignFindUniqueArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingCampaignFindUniqueOrThrowArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindFirstArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingCampaignFindFirstArgs>(args?: SelectSubset<T, MarketingCampaignFindFirstArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindFirstOrThrowArgs} args - Arguments to find a MarketingCampaign
     * @example
     * // Get one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingCampaigns
     * const marketingCampaigns = await prisma.marketingCampaign.findMany()
     * 
     * // Get first 10 MarketingCampaigns
     * const marketingCampaigns = await prisma.marketingCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingCampaignWithIdOnly = await prisma.marketingCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingCampaignFindManyArgs>(args?: SelectSubset<T, MarketingCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingCampaign.
     * @param {MarketingCampaignCreateArgs} args - Arguments to create a MarketingCampaign.
     * @example
     * // Create one MarketingCampaign
     * const MarketingCampaign = await prisma.marketingCampaign.create({
     *   data: {
     *     // ... data to create a MarketingCampaign
     *   }
     * })
     * 
     */
    create<T extends MarketingCampaignCreateArgs>(args: SelectSubset<T, MarketingCampaignCreateArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingCampaigns.
     * @param {MarketingCampaignCreateManyArgs} args - Arguments to create many MarketingCampaigns.
     * @example
     * // Create many MarketingCampaigns
     * const marketingCampaign = await prisma.marketingCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingCampaignCreateManyArgs>(args?: SelectSubset<T, MarketingCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketingCampaign.
     * @param {MarketingCampaignDeleteArgs} args - Arguments to delete one MarketingCampaign.
     * @example
     * // Delete one MarketingCampaign
     * const MarketingCampaign = await prisma.marketingCampaign.delete({
     *   where: {
     *     // ... filter to delete one MarketingCampaign
     *   }
     * })
     * 
     */
    delete<T extends MarketingCampaignDeleteArgs>(args: SelectSubset<T, MarketingCampaignDeleteArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingCampaign.
     * @param {MarketingCampaignUpdateArgs} args - Arguments to update one MarketingCampaign.
     * @example
     * // Update one MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingCampaignUpdateArgs>(args: SelectSubset<T, MarketingCampaignUpdateArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingCampaigns.
     * @param {MarketingCampaignDeleteManyArgs} args - Arguments to filter MarketingCampaigns to delete.
     * @example
     * // Delete a few MarketingCampaigns
     * const { count } = await prisma.marketingCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingCampaignDeleteManyArgs>(args?: SelectSubset<T, MarketingCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingCampaigns
     * const marketingCampaign = await prisma.marketingCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingCampaignUpdateManyArgs>(args: SelectSubset<T, MarketingCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketingCampaign.
     * @param {MarketingCampaignUpsertArgs} args - Arguments to update or create a MarketingCampaign.
     * @example
     * // Update or create a MarketingCampaign
     * const marketingCampaign = await prisma.marketingCampaign.upsert({
     *   create: {
     *     // ... data to create a MarketingCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingCampaign we want to update
     *   }
     * })
     */
    upsert<T extends MarketingCampaignUpsertArgs>(args: SelectSubset<T, MarketingCampaignUpsertArgs<ExtArgs>>): Prisma__MarketingCampaignClient<$Result.GetResult<Prisma.$MarketingCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingCampaigns that matches the filter.
     * @param {MarketingCampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketingCampaign = await prisma.marketingCampaign.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketingCampaignFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MarketingCampaign.
     * @param {MarketingCampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketingCampaign = await prisma.marketingCampaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketingCampaignAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MarketingCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignCountArgs} args - Arguments to filter MarketingCampaigns to count.
     * @example
     * // Count the number of MarketingCampaigns
     * const count = await prisma.marketingCampaign.count({
     *   where: {
     *     // ... the filter for the MarketingCampaigns we want to count
     *   }
     * })
    **/
    count<T extends MarketingCampaignCountArgs>(
      args?: Subset<T, MarketingCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingCampaignAggregateArgs>(args: Subset<T, MarketingCampaignAggregateArgs>): Prisma.PrismaPromise<GetMarketingCampaignAggregateType<T>>

    /**
     * Group by MarketingCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingCampaignGroupByArgs['orderBy'] }
        : { orderBy?: MarketingCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingCampaign model
   */
  readonly fields: MarketingCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingCampaign model
   */
  interface MarketingCampaignFieldRefs {
    readonly id: FieldRef<"MarketingCampaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MarketingCampaign findUnique
   */
  export type MarketingCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign findUniqueOrThrow
   */
  export type MarketingCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign findFirst
   */
  export type MarketingCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingCampaigns.
     */
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign findFirstOrThrow
   */
  export type MarketingCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter, which MarketingCampaign to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingCampaigns.
     */
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign findMany
   */
  export type MarketingCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter, which MarketingCampaigns to fetch.
     */
    where?: MarketingCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingCampaigns to fetch.
     */
    orderBy?: MarketingCampaignOrderByWithRelationInput | MarketingCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingCampaigns.
     */
    cursor?: MarketingCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingCampaigns.
     */
    skip?: number
    distinct?: MarketingCampaignScalarFieldEnum | MarketingCampaignScalarFieldEnum[]
  }

  /**
   * MarketingCampaign create
   */
  export type MarketingCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketingCampaign.
     */
    data?: XOR<MarketingCampaignCreateInput, MarketingCampaignUncheckedCreateInput>
  }

  /**
   * MarketingCampaign createMany
   */
  export type MarketingCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingCampaigns.
     */
    data: MarketingCampaignCreateManyInput | MarketingCampaignCreateManyInput[]
  }

  /**
   * MarketingCampaign update
   */
  export type MarketingCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketingCampaign.
     */
    data: XOR<MarketingCampaignUpdateInput, MarketingCampaignUncheckedUpdateInput>
    /**
     * Choose, which MarketingCampaign to update.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign updateMany
   */
  export type MarketingCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingCampaigns.
     */
    data: XOR<MarketingCampaignUpdateManyMutationInput, MarketingCampaignUncheckedUpdateManyInput>
    /**
     * Filter which MarketingCampaigns to update
     */
    where?: MarketingCampaignWhereInput
    /**
     * Limit how many MarketingCampaigns to update.
     */
    limit?: number
  }

  /**
   * MarketingCampaign upsert
   */
  export type MarketingCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketingCampaign to update in case it exists.
     */
    where: MarketingCampaignWhereUniqueInput
    /**
     * In case the MarketingCampaign found by the `where` argument doesn't exist, create a new MarketingCampaign with this data.
     */
    create: XOR<MarketingCampaignCreateInput, MarketingCampaignUncheckedCreateInput>
    /**
     * In case the MarketingCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingCampaignUpdateInput, MarketingCampaignUncheckedUpdateInput>
  }

  /**
   * MarketingCampaign delete
   */
  export type MarketingCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
    /**
     * Filter which MarketingCampaign to delete.
     */
    where: MarketingCampaignWhereUniqueInput
  }

  /**
   * MarketingCampaign deleteMany
   */
  export type MarketingCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingCampaigns to delete
     */
    where?: MarketingCampaignWhereInput
    /**
     * Limit how many MarketingCampaigns to delete.
     */
    limit?: number
  }

  /**
   * MarketingCampaign findRaw
   */
  export type MarketingCampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketingCampaign aggregateRaw
   */
  export type MarketingCampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketingCampaign without action
   */
  export type MarketingCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingCampaign
     */
    select?: MarketingCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingCampaign
     */
    omit?: MarketingCampaignOmit<ExtArgs> | null
  }


  /**
   * Model MediaPartner
   */

  export type AggregateMediaPartner = {
    _count: MediaPartnerCountAggregateOutputType | null
    _avg: MediaPartnerAvgAggregateOutputType | null
    _sum: MediaPartnerSumAggregateOutputType | null
    _min: MediaPartnerMinAggregateOutputType | null
    _max: MediaPartnerMaxAggregateOutputType | null
  }

  export type MediaPartnerAvgAggregateOutputType = {
    priority: number | null
  }

  export type MediaPartnerSumAggregateOutputType = {
    priority: bigint | null
  }

  export type MediaPartnerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    priority: bigint | null
    projectId: string | null
    type: string | null
    updatedAt: Date | null
    website: string | null
  }

  export type MediaPartnerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    priority: bigint | null
    projectId: string | null
    type: string | null
    updatedAt: Date | null
    website: string | null
  }

  export type MediaPartnerCountAggregateOutputType = {
    id: number
    createdAt: number
    image: number
    name: number
    priority: number
    projectId: number
    type: number
    updatedAt: number
    website: number
    _all: number
  }


  export type MediaPartnerAvgAggregateInputType = {
    priority?: true
  }

  export type MediaPartnerSumAggregateInputType = {
    priority?: true
  }

  export type MediaPartnerMinAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    priority?: true
    projectId?: true
    type?: true
    updatedAt?: true
    website?: true
  }

  export type MediaPartnerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    priority?: true
    projectId?: true
    type?: true
    updatedAt?: true
    website?: true
  }

  export type MediaPartnerCountAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    priority?: true
    projectId?: true
    type?: true
    updatedAt?: true
    website?: true
    _all?: true
  }

  export type MediaPartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPartner to aggregate.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaPartners
    **/
    _count?: true | MediaPartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaPartnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaPartnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaPartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaPartnerMaxAggregateInputType
  }

  export type GetMediaPartnerAggregateType<T extends MediaPartnerAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaPartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaPartner[P]>
      : GetScalarType<T[P], AggregateMediaPartner[P]>
  }




  export type MediaPartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaPartnerWhereInput
    orderBy?: MediaPartnerOrderByWithAggregationInput | MediaPartnerOrderByWithAggregationInput[]
    by: MediaPartnerScalarFieldEnum[] | MediaPartnerScalarFieldEnum
    having?: MediaPartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaPartnerCountAggregateInputType | true
    _avg?: MediaPartnerAvgAggregateInputType
    _sum?: MediaPartnerSumAggregateInputType
    _min?: MediaPartnerMinAggregateInputType
    _max?: MediaPartnerMaxAggregateInputType
  }

  export type MediaPartnerGroupByOutputType = {
    id: string
    createdAt: Date
    image: string
    name: string
    priority: bigint
    projectId: string
    type: string
    updatedAt: Date
    website: string
    _count: MediaPartnerCountAggregateOutputType | null
    _avg: MediaPartnerAvgAggregateOutputType | null
    _sum: MediaPartnerSumAggregateOutputType | null
    _min: MediaPartnerMinAggregateOutputType | null
    _max: MediaPartnerMaxAggregateOutputType | null
  }

  type GetMediaPartnerGroupByPayload<T extends MediaPartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaPartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaPartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaPartnerGroupByOutputType[P]>
            : GetScalarType<T[P], MediaPartnerGroupByOutputType[P]>
        }
      >
    >


  export type MediaPartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    priority?: boolean
    projectId?: boolean
    type?: boolean
    updatedAt?: boolean
    website?: boolean
  }, ExtArgs["result"]["mediaPartner"]>



  export type MediaPartnerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    priority?: boolean
    projectId?: boolean
    type?: boolean
    updatedAt?: boolean
    website?: boolean
  }

  export type MediaPartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "image" | "name" | "priority" | "projectId" | "type" | "updatedAt" | "website", ExtArgs["result"]["mediaPartner"]>

  export type $MediaPartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaPartner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      image: string
      name: string
      priority: bigint
      projectId: string
      type: string
      updatedAt: Date
      website: string
    }, ExtArgs["result"]["mediaPartner"]>
    composites: {}
  }

  type MediaPartnerGetPayload<S extends boolean | null | undefined | MediaPartnerDefaultArgs> = $Result.GetResult<Prisma.$MediaPartnerPayload, S>

  type MediaPartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaPartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaPartnerCountAggregateInputType | true
    }

  export interface MediaPartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaPartner'], meta: { name: 'MediaPartner' } }
    /**
     * Find zero or one MediaPartner that matches the filter.
     * @param {MediaPartnerFindUniqueArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaPartnerFindUniqueArgs>(args: SelectSubset<T, MediaPartnerFindUniqueArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaPartner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaPartnerFindUniqueOrThrowArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaPartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaPartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaPartner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindFirstArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaPartnerFindFirstArgs>(args?: SelectSubset<T, MediaPartnerFindFirstArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaPartner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindFirstOrThrowArgs} args - Arguments to find a MediaPartner
     * @example
     * // Get one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaPartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaPartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaPartners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaPartners
     * const mediaPartners = await prisma.mediaPartner.findMany()
     * 
     * // Get first 10 MediaPartners
     * const mediaPartners = await prisma.mediaPartner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaPartnerWithIdOnly = await prisma.mediaPartner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaPartnerFindManyArgs>(args?: SelectSubset<T, MediaPartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaPartner.
     * @param {MediaPartnerCreateArgs} args - Arguments to create a MediaPartner.
     * @example
     * // Create one MediaPartner
     * const MediaPartner = await prisma.mediaPartner.create({
     *   data: {
     *     // ... data to create a MediaPartner
     *   }
     * })
     * 
     */
    create<T extends MediaPartnerCreateArgs>(args: SelectSubset<T, MediaPartnerCreateArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaPartners.
     * @param {MediaPartnerCreateManyArgs} args - Arguments to create many MediaPartners.
     * @example
     * // Create many MediaPartners
     * const mediaPartner = await prisma.mediaPartner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaPartnerCreateManyArgs>(args?: SelectSubset<T, MediaPartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MediaPartner.
     * @param {MediaPartnerDeleteArgs} args - Arguments to delete one MediaPartner.
     * @example
     * // Delete one MediaPartner
     * const MediaPartner = await prisma.mediaPartner.delete({
     *   where: {
     *     // ... filter to delete one MediaPartner
     *   }
     * })
     * 
     */
    delete<T extends MediaPartnerDeleteArgs>(args: SelectSubset<T, MediaPartnerDeleteArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaPartner.
     * @param {MediaPartnerUpdateArgs} args - Arguments to update one MediaPartner.
     * @example
     * // Update one MediaPartner
     * const mediaPartner = await prisma.mediaPartner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaPartnerUpdateArgs>(args: SelectSubset<T, MediaPartnerUpdateArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaPartners.
     * @param {MediaPartnerDeleteManyArgs} args - Arguments to filter MediaPartners to delete.
     * @example
     * // Delete a few MediaPartners
     * const { count } = await prisma.mediaPartner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaPartnerDeleteManyArgs>(args?: SelectSubset<T, MediaPartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaPartners
     * const mediaPartner = await prisma.mediaPartner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaPartnerUpdateManyArgs>(args: SelectSubset<T, MediaPartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MediaPartner.
     * @param {MediaPartnerUpsertArgs} args - Arguments to update or create a MediaPartner.
     * @example
     * // Update or create a MediaPartner
     * const mediaPartner = await prisma.mediaPartner.upsert({
     *   create: {
     *     // ... data to create a MediaPartner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaPartner we want to update
     *   }
     * })
     */
    upsert<T extends MediaPartnerUpsertArgs>(args: SelectSubset<T, MediaPartnerUpsertArgs<ExtArgs>>): Prisma__MediaPartnerClient<$Result.GetResult<Prisma.$MediaPartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaPartners that matches the filter.
     * @param {MediaPartnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mediaPartner = await prisma.mediaPartner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MediaPartnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MediaPartner.
     * @param {MediaPartnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mediaPartner = await prisma.mediaPartner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MediaPartnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MediaPartners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerCountArgs} args - Arguments to filter MediaPartners to count.
     * @example
     * // Count the number of MediaPartners
     * const count = await prisma.mediaPartner.count({
     *   where: {
     *     // ... the filter for the MediaPartners we want to count
     *   }
     * })
    **/
    count<T extends MediaPartnerCountArgs>(
      args?: Subset<T, MediaPartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaPartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaPartnerAggregateArgs>(args: Subset<T, MediaPartnerAggregateArgs>): Prisma.PrismaPromise<GetMediaPartnerAggregateType<T>>

    /**
     * Group by MediaPartner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaPartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaPartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaPartnerGroupByArgs['orderBy'] }
        : { orderBy?: MediaPartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaPartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaPartner model
   */
  readonly fields: MediaPartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaPartner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaPartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaPartner model
   */
  interface MediaPartnerFieldRefs {
    readonly id: FieldRef<"MediaPartner", 'String'>
    readonly createdAt: FieldRef<"MediaPartner", 'DateTime'>
    readonly image: FieldRef<"MediaPartner", 'String'>
    readonly name: FieldRef<"MediaPartner", 'String'>
    readonly priority: FieldRef<"MediaPartner", 'BigInt'>
    readonly projectId: FieldRef<"MediaPartner", 'String'>
    readonly type: FieldRef<"MediaPartner", 'String'>
    readonly updatedAt: FieldRef<"MediaPartner", 'DateTime'>
    readonly website: FieldRef<"MediaPartner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MediaPartner findUnique
   */
  export type MediaPartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner findUniqueOrThrow
   */
  export type MediaPartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner findFirst
   */
  export type MediaPartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPartners.
     */
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner findFirstOrThrow
   */
  export type MediaPartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter, which MediaPartner to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaPartners.
     */
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner findMany
   */
  export type MediaPartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter, which MediaPartners to fetch.
     */
    where?: MediaPartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaPartners to fetch.
     */
    orderBy?: MediaPartnerOrderByWithRelationInput | MediaPartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaPartners.
     */
    cursor?: MediaPartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaPartners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaPartners.
     */
    skip?: number
    distinct?: MediaPartnerScalarFieldEnum | MediaPartnerScalarFieldEnum[]
  }

  /**
   * MediaPartner create
   */
  export type MediaPartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * The data needed to create a MediaPartner.
     */
    data: XOR<MediaPartnerCreateInput, MediaPartnerUncheckedCreateInput>
  }

  /**
   * MediaPartner createMany
   */
  export type MediaPartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaPartners.
     */
    data: MediaPartnerCreateManyInput | MediaPartnerCreateManyInput[]
  }

  /**
   * MediaPartner update
   */
  export type MediaPartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * The data needed to update a MediaPartner.
     */
    data: XOR<MediaPartnerUpdateInput, MediaPartnerUncheckedUpdateInput>
    /**
     * Choose, which MediaPartner to update.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner updateMany
   */
  export type MediaPartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaPartners.
     */
    data: XOR<MediaPartnerUpdateManyMutationInput, MediaPartnerUncheckedUpdateManyInput>
    /**
     * Filter which MediaPartners to update
     */
    where?: MediaPartnerWhereInput
    /**
     * Limit how many MediaPartners to update.
     */
    limit?: number
  }

  /**
   * MediaPartner upsert
   */
  export type MediaPartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * The filter to search for the MediaPartner to update in case it exists.
     */
    where: MediaPartnerWhereUniqueInput
    /**
     * In case the MediaPartner found by the `where` argument doesn't exist, create a new MediaPartner with this data.
     */
    create: XOR<MediaPartnerCreateInput, MediaPartnerUncheckedCreateInput>
    /**
     * In case the MediaPartner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaPartnerUpdateInput, MediaPartnerUncheckedUpdateInput>
  }

  /**
   * MediaPartner delete
   */
  export type MediaPartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
    /**
     * Filter which MediaPartner to delete.
     */
    where: MediaPartnerWhereUniqueInput
  }

  /**
   * MediaPartner deleteMany
   */
  export type MediaPartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaPartners to delete
     */
    where?: MediaPartnerWhereInput
    /**
     * Limit how many MediaPartners to delete.
     */
    limit?: number
  }

  /**
   * MediaPartner findRaw
   */
  export type MediaPartnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MediaPartner aggregateRaw
   */
  export type MediaPartnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MediaPartner without action
   */
  export type MediaPartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaPartner
     */
    select?: MediaPartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaPartner
     */
    omit?: MediaPartnerOmit<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["order"]>

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OrderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OrderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data?: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order findRaw
   */
  export type OrderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type PackageMinAggregateInputType = {
    id?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    _count: PackageCountAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["package"]>



  export type PackageSelectScalar = {
    id?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["package"]>

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * @param {PackageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const package = await prisma.package.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PackageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Package.
     * @param {PackageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const package = await prisma.package.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PackageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data?: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package findRaw
   */
  export type PackageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Package aggregateRaw
   */
  export type PackageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    contribution: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    projectId: string | null
    status: string | null
    type: string | null
    updatedAt: Date | null
    website: string | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    contribution: string | null
    createdAt: Date | null
    image: string | null
    name: string | null
    projectId: string | null
    status: string | null
    type: string | null
    updatedAt: Date | null
    website: string | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    contribution: number
    createdAt: number
    image: number
    name: number
    projectId: number
    status: number
    type: number
    updatedAt: number
    website: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    contribution?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
    website?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    contribution?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
    website?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    contribution?: true
    createdAt?: true
    image?: true
    name?: true
    projectId?: true
    status?: true
    type?: true
    updatedAt?: true
    website?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    contribution: string
    createdAt: Date
    image: string
    name: string
    projectId: string
    status: string
    type: string
    updatedAt: Date
    website: string
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contribution?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    projectId?: boolean
    status?: boolean
    type?: boolean
    updatedAt?: boolean
    website?: boolean
  }, ExtArgs["result"]["partner"]>



  export type PartnerSelectScalar = {
    id?: boolean
    contribution?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    projectId?: boolean
    status?: boolean
    type?: boolean
    updatedAt?: boolean
    website?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contribution" | "createdAt" | "image" | "name" | "projectId" | "status" | "type" | "updatedAt" | "website", ExtArgs["result"]["partner"]>

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contribution: string
      createdAt: Date
      image: string
      name: string
      projectId: string
      status: string
      type: string
      updatedAt: Date
      website: string
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * @param {PartnerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const partner = await prisma.partner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PartnerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Partner.
     * @param {PartnerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const partner = await prisma.partner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PartnerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly contribution: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly image: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly projectId: FieldRef<"Partner", 'String'>
    readonly status: FieldRef<"Partner", 'String'>
    readonly type: FieldRef<"Partner", 'String'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
    readonly website: FieldRef<"Partner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner findRaw
   */
  export type PartnerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partner aggregateRaw
   */
  export type PartnerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
  }


  /**
   * Model Partners
   */

  export type AggregatePartners = {
    _count: PartnersCountAggregateOutputType | null
    _min: PartnersMinAggregateOutputType | null
    _max: PartnersMaxAggregateOutputType | null
  }

  export type PartnersMinAggregateOutputType = {
    id: string | null
  }

  export type PartnersMaxAggregateOutputType = {
    id: string | null
  }

  export type PartnersCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type PartnersMinAggregateInputType = {
    id?: true
  }

  export type PartnersMaxAggregateInputType = {
    id?: true
  }

  export type PartnersCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type PartnersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to aggregate.
     */
    where?: PartnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnersOrderByWithRelationInput | PartnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnersMaxAggregateInputType
  }

  export type GetPartnersAggregateType<T extends PartnersAggregateArgs> = {
        [P in keyof T & keyof AggregatePartners]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartners[P]>
      : GetScalarType<T[P], AggregatePartners[P]>
  }




  export type PartnersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnersWhereInput
    orderBy?: PartnersOrderByWithAggregationInput | PartnersOrderByWithAggregationInput[]
    by: PartnersScalarFieldEnum[] | PartnersScalarFieldEnum
    having?: PartnersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnersCountAggregateInputType | true
    _min?: PartnersMinAggregateInputType
    _max?: PartnersMaxAggregateInputType
  }

  export type PartnersGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: PartnersCountAggregateOutputType | null
    _min: PartnersMinAggregateOutputType | null
    _max: PartnersMaxAggregateOutputType | null
  }

  type GetPartnersGroupByPayload<T extends PartnersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnersGroupByOutputType[P]>
            : GetScalarType<T[P], PartnersGroupByOutputType[P]>
        }
      >
    >


  export type PartnersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["partners"]>



  export type PartnersSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type PartnersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["partners"]>

  export type $PartnersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partners"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["partners"]>
    composites: {}
  }

  type PartnersGetPayload<S extends boolean | null | undefined | PartnersDefaultArgs> = $Result.GetResult<Prisma.$PartnersPayload, S>

  type PartnersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnersCountAggregateInputType | true
    }

  export interface PartnersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partners'], meta: { name: 'Partners' } }
    /**
     * Find zero or one Partners that matches the filter.
     * @param {PartnersFindUniqueArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnersFindUniqueArgs>(args: SelectSubset<T, PartnersFindUniqueArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partners that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnersFindUniqueOrThrowArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnersFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersFindFirstArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnersFindFirstArgs>(args?: SelectSubset<T, PartnersFindFirstArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersFindFirstOrThrowArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnersFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnersFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partners.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnersWithIdOnly = await prisma.partners.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnersFindManyArgs>(args?: SelectSubset<T, PartnersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partners.
     * @param {PartnersCreateArgs} args - Arguments to create a Partners.
     * @example
     * // Create one Partners
     * const Partners = await prisma.partners.create({
     *   data: {
     *     // ... data to create a Partners
     *   }
     * })
     * 
     */
    create<T extends PartnersCreateArgs>(args: SelectSubset<T, PartnersCreateArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnersCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partners = await prisma.partners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnersCreateManyArgs>(args?: SelectSubset<T, PartnersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Partners.
     * @param {PartnersDeleteArgs} args - Arguments to delete one Partners.
     * @example
     * // Delete one Partners
     * const Partners = await prisma.partners.delete({
     *   where: {
     *     // ... filter to delete one Partners
     *   }
     * })
     * 
     */
    delete<T extends PartnersDeleteArgs>(args: SelectSubset<T, PartnersDeleteArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partners.
     * @param {PartnersUpdateArgs} args - Arguments to update one Partners.
     * @example
     * // Update one Partners
     * const partners = await prisma.partners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnersUpdateArgs>(args: SelectSubset<T, PartnersUpdateArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnersDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnersDeleteManyArgs>(args?: SelectSubset<T, PartnersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partners = await prisma.partners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnersUpdateManyArgs>(args: SelectSubset<T, PartnersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partners.
     * @param {PartnersUpsertArgs} args - Arguments to update or create a Partners.
     * @example
     * // Update or create a Partners
     * const partners = await prisma.partners.upsert({
     *   create: {
     *     // ... data to create a Partners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partners we want to update
     *   }
     * })
     */
    upsert<T extends PartnersUpsertArgs>(args: SelectSubset<T, PartnersUpsertArgs<ExtArgs>>): Prisma__PartnersClient<$Result.GetResult<Prisma.$PartnersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * @param {PartnersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const partners = await prisma.partners.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PartnersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Partners.
     * @param {PartnersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const partners = await prisma.partners.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PartnersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partners.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnersCountArgs>(
      args?: Subset<T, PartnersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnersAggregateArgs>(args: Subset<T, PartnersAggregateArgs>): Prisma.PrismaPromise<GetPartnersAggregateType<T>>

    /**
     * Group by Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnersGroupByArgs['orderBy'] }
        : { orderBy?: PartnersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partners model
   */
  readonly fields: PartnersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partners model
   */
  interface PartnersFieldRefs {
    readonly id: FieldRef<"Partners", 'String'>
    readonly projectId: FieldRef<"Partners", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Partners findUnique
   */
  export type PartnersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where: PartnersWhereUniqueInput
  }

  /**
   * Partners findUniqueOrThrow
   */
  export type PartnersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where: PartnersWhereUniqueInput
  }

  /**
   * Partners findFirst
   */
  export type PartnersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnersOrderByWithRelationInput | PartnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnersScalarFieldEnum | PartnersScalarFieldEnum[]
  }

  /**
   * Partners findFirstOrThrow
   */
  export type PartnersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnersOrderByWithRelationInput | PartnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnersScalarFieldEnum | PartnersScalarFieldEnum[]
  }

  /**
   * Partners findMany
   */
  export type PartnersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnersOrderByWithRelationInput | PartnersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnersScalarFieldEnum | PartnersScalarFieldEnum[]
  }

  /**
   * Partners create
   */
  export type PartnersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * The data needed to create a Partners.
     */
    data?: XOR<PartnersCreateInput, PartnersUncheckedCreateInput>
  }

  /**
   * Partners createMany
   */
  export type PartnersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnersCreateManyInput | PartnersCreateManyInput[]
  }

  /**
   * Partners update
   */
  export type PartnersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * The data needed to update a Partners.
     */
    data: XOR<PartnersUpdateInput, PartnersUncheckedUpdateInput>
    /**
     * Choose, which Partners to update.
     */
    where: PartnersWhereUniqueInput
  }

  /**
   * Partners updateMany
   */
  export type PartnersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnersUpdateManyMutationInput, PartnersUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnersWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partners upsert
   */
  export type PartnersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * The filter to search for the Partners to update in case it exists.
     */
    where: PartnersWhereUniqueInput
    /**
     * In case the Partners found by the `where` argument doesn't exist, create a new Partners with this data.
     */
    create: XOR<PartnersCreateInput, PartnersUncheckedCreateInput>
    /**
     * In case the Partners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnersUpdateInput, PartnersUncheckedUpdateInput>
  }

  /**
   * Partners delete
   */
  export type PartnersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
    /**
     * Filter which Partners to delete.
     */
    where: PartnersWhereUniqueInput
  }

  /**
   * Partners deleteMany
   */
  export type PartnersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnersWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partners findRaw
   */
  export type PartnersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partners aggregateRaw
   */
  export type PartnersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Partners without action
   */
  export type PartnersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partners
     */
    select?: PartnersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partners
     */
    omit?: PartnersOmit<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    currency: string | null
    description: string | null
    endDate: Date | null
    name: string | null
    startDate: Date | null
    updatedAt: Date | null
    venue: string | null
    website: string | null
    year: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    currency: string | null
    description: string | null
    endDate: Date | null
    name: string | null
    startDate: Date | null
    updatedAt: Date | null
    venue: string | null
    website: string | null
    year: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    createdAt: number
    currency: number
    description: number
    endDate: number
    name: number
    startDate: number
    updatedAt: number
    venue: number
    website: number
    year: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    currency?: true
    description?: true
    endDate?: true
    name?: true
    startDate?: true
    updatedAt?: true
    venue?: true
    website?: true
    year?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    currency?: true
    description?: true
    endDate?: true
    name?: true
    startDate?: true
    updatedAt?: true
    venue?: true
    website?: true
    year?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    currency?: true
    description?: true
    endDate?: true
    name?: true
    startDate?: true
    updatedAt?: true
    venue?: true
    website?: true
    year?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    createdAt: Date
    currency: string
    description: string
    endDate: Date | null
    name: string
    startDate: Date | null
    updatedAt: Date
    venue: string
    website: string
    year: string
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    currency?: boolean
    description?: boolean
    endDate?: boolean
    name?: boolean
    startDate?: boolean
    updatedAt?: boolean
    venue?: boolean
    website?: boolean
    year?: boolean
  }, ExtArgs["result"]["project"]>



  export type ProjectSelectScalar = {
    id?: boolean
    createdAt?: boolean
    currency?: boolean
    description?: boolean
    endDate?: boolean
    name?: boolean
    startDate?: boolean
    updatedAt?: boolean
    venue?: boolean
    website?: boolean
    year?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "currency" | "description" | "endDate" | "name" | "startDate" | "updatedAt" | "venue" | "website" | "year", ExtArgs["result"]["project"]>

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      currency: string
      description: string
      endDate: Date | null
      name: string
      startDate: Date | null
      updatedAt: Date
      venue: string
      website: string
      year: string
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * @param {ProjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const project = await prisma.project.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Project.
     * @param {ProjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const project = await prisma.project.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly currency: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly name: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly venue: FieldRef<"Project", 'String'>
    readonly website: FieldRef<"Project", 'String'>
    readonly year: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project findRaw
   */
  export type ProjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Project aggregateRaw
   */
  export type ProjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
  }


  /**
   * Model ProjectStats
   */

  export type AggregateProjectStats = {
    _count: ProjectStatsCountAggregateOutputType | null
    _avg: ProjectStatsAvgAggregateOutputType | null
    _sum: ProjectStatsSumAggregateOutputType | null
    _min: ProjectStatsMinAggregateOutputType | null
    _max: ProjectStatsMaxAggregateOutputType | null
  }

  export type ProjectStatsAvgAggregateOutputType = {
    delegates: number | null
    exhibitors: number | null
    mediaPartners: number | null
    partners: number | null
    speakers: number | null
    sponsors: number | null
  }

  export type ProjectStatsSumAggregateOutputType = {
    delegates: bigint | null
    exhibitors: bigint | null
    mediaPartners: bigint | null
    partners: bigint | null
    speakers: bigint | null
    sponsors: bigint | null
  }

  export type ProjectStatsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    delegates: bigint | null
    exhibitors: bigint | null
    mediaPartners: bigint | null
    partners: bigint | null
    projectId: string | null
    speakers: bigint | null
    sponsors: bigint | null
    updatedAt: Date | null
  }

  export type ProjectStatsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    delegates: bigint | null
    exhibitors: bigint | null
    mediaPartners: bigint | null
    partners: bigint | null
    projectId: string | null
    speakers: bigint | null
    sponsors: bigint | null
    updatedAt: Date | null
  }

  export type ProjectStatsCountAggregateOutputType = {
    id: number
    createdAt: number
    delegates: number
    exhibitors: number
    mediaPartners: number
    partners: number
    projectId: number
    speakers: number
    sponsors: number
    updatedAt: number
    _all: number
  }


  export type ProjectStatsAvgAggregateInputType = {
    delegates?: true
    exhibitors?: true
    mediaPartners?: true
    partners?: true
    speakers?: true
    sponsors?: true
  }

  export type ProjectStatsSumAggregateInputType = {
    delegates?: true
    exhibitors?: true
    mediaPartners?: true
    partners?: true
    speakers?: true
    sponsors?: true
  }

  export type ProjectStatsMinAggregateInputType = {
    id?: true
    createdAt?: true
    delegates?: true
    exhibitors?: true
    mediaPartners?: true
    partners?: true
    projectId?: true
    speakers?: true
    sponsors?: true
    updatedAt?: true
  }

  export type ProjectStatsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    delegates?: true
    exhibitors?: true
    mediaPartners?: true
    partners?: true
    projectId?: true
    speakers?: true
    sponsors?: true
    updatedAt?: true
  }

  export type ProjectStatsCountAggregateInputType = {
    id?: true
    createdAt?: true
    delegates?: true
    exhibitors?: true
    mediaPartners?: true
    partners?: true
    projectId?: true
    speakers?: true
    sponsors?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStats to aggregate.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectStats
    **/
    _count?: true | ProjectStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectStatsMaxAggregateInputType
  }

  export type GetProjectStatsAggregateType<T extends ProjectStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectStats[P]>
      : GetScalarType<T[P], AggregateProjectStats[P]>
  }




  export type ProjectStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectStatsWhereInput
    orderBy?: ProjectStatsOrderByWithAggregationInput | ProjectStatsOrderByWithAggregationInput[]
    by: ProjectStatsScalarFieldEnum[] | ProjectStatsScalarFieldEnum
    having?: ProjectStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectStatsCountAggregateInputType | true
    _avg?: ProjectStatsAvgAggregateInputType
    _sum?: ProjectStatsSumAggregateInputType
    _min?: ProjectStatsMinAggregateInputType
    _max?: ProjectStatsMaxAggregateInputType
  }

  export type ProjectStatsGroupByOutputType = {
    id: string
    createdAt: Date
    delegates: bigint
    exhibitors: bigint
    mediaPartners: bigint
    partners: bigint
    projectId: string
    speakers: bigint
    sponsors: bigint
    updatedAt: Date
    _count: ProjectStatsCountAggregateOutputType | null
    _avg: ProjectStatsAvgAggregateOutputType | null
    _sum: ProjectStatsSumAggregateOutputType | null
    _min: ProjectStatsMinAggregateOutputType | null
    _max: ProjectStatsMaxAggregateOutputType | null
  }

  type GetProjectStatsGroupByPayload<T extends ProjectStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectStatsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectStatsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    delegates?: boolean
    exhibitors?: boolean
    mediaPartners?: boolean
    partners?: boolean
    projectId?: boolean
    speakers?: boolean
    sponsors?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["projectStats"]>



  export type ProjectStatsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    delegates?: boolean
    exhibitors?: boolean
    mediaPartners?: boolean
    partners?: boolean
    projectId?: boolean
    speakers?: boolean
    sponsors?: boolean
    updatedAt?: boolean
  }

  export type ProjectStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "delegates" | "exhibitors" | "mediaPartners" | "partners" | "projectId" | "speakers" | "sponsors" | "updatedAt", ExtArgs["result"]["projectStats"]>

  export type $ProjectStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      delegates: bigint
      exhibitors: bigint
      mediaPartners: bigint
      partners: bigint
      projectId: string
      speakers: bigint
      sponsors: bigint
      updatedAt: Date
    }, ExtArgs["result"]["projectStats"]>
    composites: {}
  }

  type ProjectStatsGetPayload<S extends boolean | null | undefined | ProjectStatsDefaultArgs> = $Result.GetResult<Prisma.$ProjectStatsPayload, S>

  type ProjectStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectStatsCountAggregateInputType | true
    }

  export interface ProjectStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectStats'], meta: { name: 'ProjectStats' } }
    /**
     * Find zero or one ProjectStats that matches the filter.
     * @param {ProjectStatsFindUniqueArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectStatsFindUniqueArgs>(args: SelectSubset<T, ProjectStatsFindUniqueArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectStatsFindUniqueOrThrowArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindFirstArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectStatsFindFirstArgs>(args?: SelectSubset<T, ProjectStatsFindFirstArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindFirstOrThrowArgs} args - Arguments to find a ProjectStats
     * @example
     * // Get one ProjectStats
     * const projectStats = await prisma.projectStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectStats
     * const projectStats = await prisma.projectStats.findMany()
     * 
     * // Get first 10 ProjectStats
     * const projectStats = await prisma.projectStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectStatsWithIdOnly = await prisma.projectStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectStatsFindManyArgs>(args?: SelectSubset<T, ProjectStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectStats.
     * @param {ProjectStatsCreateArgs} args - Arguments to create a ProjectStats.
     * @example
     * // Create one ProjectStats
     * const ProjectStats = await prisma.projectStats.create({
     *   data: {
     *     // ... data to create a ProjectStats
     *   }
     * })
     * 
     */
    create<T extends ProjectStatsCreateArgs>(args: SelectSubset<T, ProjectStatsCreateArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectStats.
     * @param {ProjectStatsCreateManyArgs} args - Arguments to create many ProjectStats.
     * @example
     * // Create many ProjectStats
     * const projectStats = await prisma.projectStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectStatsCreateManyArgs>(args?: SelectSubset<T, ProjectStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectStats.
     * @param {ProjectStatsDeleteArgs} args - Arguments to delete one ProjectStats.
     * @example
     * // Delete one ProjectStats
     * const ProjectStats = await prisma.projectStats.delete({
     *   where: {
     *     // ... filter to delete one ProjectStats
     *   }
     * })
     * 
     */
    delete<T extends ProjectStatsDeleteArgs>(args: SelectSubset<T, ProjectStatsDeleteArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectStats.
     * @param {ProjectStatsUpdateArgs} args - Arguments to update one ProjectStats.
     * @example
     * // Update one ProjectStats
     * const projectStats = await prisma.projectStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectStatsUpdateArgs>(args: SelectSubset<T, ProjectStatsUpdateArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectStats.
     * @param {ProjectStatsDeleteManyArgs} args - Arguments to filter ProjectStats to delete.
     * @example
     * // Delete a few ProjectStats
     * const { count } = await prisma.projectStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectStatsDeleteManyArgs>(args?: SelectSubset<T, ProjectStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectStats
     * const projectStats = await prisma.projectStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectStatsUpdateManyArgs>(args: SelectSubset<T, ProjectStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectStats.
     * @param {ProjectStatsUpsertArgs} args - Arguments to update or create a ProjectStats.
     * @example
     * // Update or create a ProjectStats
     * const projectStats = await prisma.projectStats.upsert({
     *   create: {
     *     // ... data to create a ProjectStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectStats we want to update
     *   }
     * })
     */
    upsert<T extends ProjectStatsUpsertArgs>(args: SelectSubset<T, ProjectStatsUpsertArgs<ExtArgs>>): Prisma__ProjectStatsClient<$Result.GetResult<Prisma.$ProjectStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectStats that matches the filter.
     * @param {ProjectStatsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const projectStats = await prisma.projectStats.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProjectStatsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProjectStats.
     * @param {ProjectStatsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const projectStats = await prisma.projectStats.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProjectStatsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsCountArgs} args - Arguments to filter ProjectStats to count.
     * @example
     * // Count the number of ProjectStats
     * const count = await prisma.projectStats.count({
     *   where: {
     *     // ... the filter for the ProjectStats we want to count
     *   }
     * })
    **/
    count<T extends ProjectStatsCountArgs>(
      args?: Subset<T, ProjectStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectStatsAggregateArgs>(args: Subset<T, ProjectStatsAggregateArgs>): Prisma.PrismaPromise<GetProjectStatsAggregateType<T>>

    /**
     * Group by ProjectStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectStatsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectStats model
   */
  readonly fields: ProjectStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectStats model
   */
  interface ProjectStatsFieldRefs {
    readonly id: FieldRef<"ProjectStats", 'String'>
    readonly createdAt: FieldRef<"ProjectStats", 'DateTime'>
    readonly delegates: FieldRef<"ProjectStats", 'BigInt'>
    readonly exhibitors: FieldRef<"ProjectStats", 'BigInt'>
    readonly mediaPartners: FieldRef<"ProjectStats", 'BigInt'>
    readonly partners: FieldRef<"ProjectStats", 'BigInt'>
    readonly projectId: FieldRef<"ProjectStats", 'String'>
    readonly speakers: FieldRef<"ProjectStats", 'BigInt'>
    readonly sponsors: FieldRef<"ProjectStats", 'BigInt'>
    readonly updatedAt: FieldRef<"ProjectStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectStats findUnique
   */
  export type ProjectStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats findUniqueOrThrow
   */
  export type ProjectStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats findFirst
   */
  export type ProjectStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStats.
     */
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats findFirstOrThrow
   */
  export type ProjectStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectStats.
     */
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats findMany
   */
  export type ProjectStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter, which ProjectStats to fetch.
     */
    where?: ProjectStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectStats to fetch.
     */
    orderBy?: ProjectStatsOrderByWithRelationInput | ProjectStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectStats.
     */
    cursor?: ProjectStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectStats.
     */
    skip?: number
    distinct?: ProjectStatsScalarFieldEnum | ProjectStatsScalarFieldEnum[]
  }

  /**
   * ProjectStats create
   */
  export type ProjectStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a ProjectStats.
     */
    data: XOR<ProjectStatsCreateInput, ProjectStatsUncheckedCreateInput>
  }

  /**
   * ProjectStats createMany
   */
  export type ProjectStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectStats.
     */
    data: ProjectStatsCreateManyInput | ProjectStatsCreateManyInput[]
  }

  /**
   * ProjectStats update
   */
  export type ProjectStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a ProjectStats.
     */
    data: XOR<ProjectStatsUpdateInput, ProjectStatsUncheckedUpdateInput>
    /**
     * Choose, which ProjectStats to update.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats updateMany
   */
  export type ProjectStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectStats.
     */
    data: XOR<ProjectStatsUpdateManyMutationInput, ProjectStatsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectStats to update
     */
    where?: ProjectStatsWhereInput
    /**
     * Limit how many ProjectStats to update.
     */
    limit?: number
  }

  /**
   * ProjectStats upsert
   */
  export type ProjectStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the ProjectStats to update in case it exists.
     */
    where: ProjectStatsWhereUniqueInput
    /**
     * In case the ProjectStats found by the `where` argument doesn't exist, create a new ProjectStats with this data.
     */
    create: XOR<ProjectStatsCreateInput, ProjectStatsUncheckedCreateInput>
    /**
     * In case the ProjectStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectStatsUpdateInput, ProjectStatsUncheckedUpdateInput>
  }

  /**
   * ProjectStats delete
   */
  export type ProjectStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
    /**
     * Filter which ProjectStats to delete.
     */
    where: ProjectStatsWhereUniqueInput
  }

  /**
   * ProjectStats deleteMany
   */
  export type ProjectStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectStats to delete
     */
    where?: ProjectStatsWhereInput
    /**
     * Limit how many ProjectStats to delete.
     */
    limit?: number
  }

  /**
   * ProjectStats findRaw
   */
  export type ProjectStatsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectStats aggregateRaw
   */
  export type ProjectStatsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProjectStats without action
   */
  export type ProjectStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectStats
     */
    select?: ProjectStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectStats
     */
    omit?: ProjectStatsOmit<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["session"]>

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data?: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
  }


  /**
   * Model Speaker
   */

  export type AggregateSpeaker = {
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  export type SpeakerMinAggregateOutputType = {
    id: string | null
  }

  export type SpeakerMaxAggregateOutputType = {
    id: string | null
  }

  export type SpeakerCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SpeakerMinAggregateInputType = {
    id?: true
  }

  export type SpeakerMaxAggregateInputType = {
    id?: true
  }

  export type SpeakerCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speaker to aggregate.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speakers
    **/
    _count?: true | SpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerMaxAggregateInputType
  }

  export type GetSpeakerAggregateType<T extends SpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeaker[P]>
      : GetScalarType<T[P], AggregateSpeaker[P]>
  }




  export type SpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerWhereInput
    orderBy?: SpeakerOrderByWithAggregationInput | SpeakerOrderByWithAggregationInput[]
    by: SpeakerScalarFieldEnum[] | SpeakerScalarFieldEnum
    having?: SpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerCountAggregateInputType | true
    _min?: SpeakerMinAggregateInputType
    _max?: SpeakerMaxAggregateInputType
  }

  export type SpeakerGroupByOutputType = {
    id: string
    _count: SpeakerCountAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  type GetSpeakerGroupByPayload<T extends SpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["speaker"]>



  export type SpeakerSelectScalar = {
    id?: boolean
  }

  export type SpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["speaker"]>

  export type $SpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Speaker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["speaker"]>
    composites: {}
  }

  type SpeakerGetPayload<S extends boolean | null | undefined | SpeakerDefaultArgs> = $Result.GetResult<Prisma.$SpeakerPayload, S>

  type SpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakerCountAggregateInputType | true
    }

  export interface SpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Speaker'], meta: { name: 'Speaker' } }
    /**
     * Find zero or one Speaker that matches the filter.
     * @param {SpeakerFindUniqueArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerFindUniqueArgs>(args: SelectSubset<T, SpeakerFindUniqueArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Speaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerFindUniqueOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerFindFirstArgs>(args?: SelectSubset<T, SpeakerFindFirstArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speaker.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakerWithIdOnly = await prisma.speaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakerFindManyArgs>(args?: SelectSubset<T, SpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Speaker.
     * @param {SpeakerCreateArgs} args - Arguments to create a Speaker.
     * @example
     * // Create one Speaker
     * const Speaker = await prisma.speaker.create({
     *   data: {
     *     // ... data to create a Speaker
     *   }
     * })
     * 
     */
    create<T extends SpeakerCreateArgs>(args: SelectSubset<T, SpeakerCreateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Speakers.
     * @param {SpeakerCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakerCreateManyArgs>(args?: SelectSubset<T, SpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Speaker.
     * @param {SpeakerDeleteArgs} args - Arguments to delete one Speaker.
     * @example
     * // Delete one Speaker
     * const Speaker = await prisma.speaker.delete({
     *   where: {
     *     // ... filter to delete one Speaker
     *   }
     * })
     * 
     */
    delete<T extends SpeakerDeleteArgs>(args: SelectSubset<T, SpeakerDeleteArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Speaker.
     * @param {SpeakerUpdateArgs} args - Arguments to update one Speaker.
     * @example
     * // Update one Speaker
     * const speaker = await prisma.speaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakerUpdateArgs>(args: SelectSubset<T, SpeakerUpdateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Speakers.
     * @param {SpeakerDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakerDeleteManyArgs>(args?: SelectSubset<T, SpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakerUpdateManyArgs>(args: SelectSubset<T, SpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Speaker.
     * @param {SpeakerUpsertArgs} args - Arguments to update or create a Speaker.
     * @example
     * // Update or create a Speaker
     * const speaker = await prisma.speaker.upsert({
     *   create: {
     *     // ... data to create a Speaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speaker we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerUpsertArgs>(args: SelectSubset<T, SpeakerUpsertArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * @param {SpeakerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speaker = await prisma.speaker.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SpeakerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Speaker.
     * @param {SpeakerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speaker = await prisma.speaker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpeakerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speaker.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends SpeakerCountArgs>(
      args?: Subset<T, SpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerAggregateArgs>(args: Subset<T, SpeakerAggregateArgs>): Prisma.PrismaPromise<GetSpeakerAggregateType<T>>

    /**
     * Group by Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Speaker model
   */
  readonly fields: SpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Speaker model
   */
  interface SpeakerFieldRefs {
    readonly id: FieldRef<"Speaker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Speaker findUnique
   */
  export type SpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findUniqueOrThrow
   */
  export type SpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findFirst
   */
  export type SpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findFirstOrThrow
   */
  export type SpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findMany
   */
  export type SpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker create
   */
  export type SpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * The data needed to create a Speaker.
     */
    data?: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
  }

  /**
   * Speaker createMany
   */
  export type SpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[]
  }

  /**
   * Speaker update
   */
  export type SpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * The data needed to update a Speaker.
     */
    data: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
    /**
     * Choose, which Speaker to update.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker updateMany
   */
  export type SpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to update.
     */
    limit?: number
  }

  /**
   * Speaker upsert
   */
  export type SpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * The filter to search for the Speaker to update in case it exists.
     */
    where: SpeakerWhereUniqueInput
    /**
     * In case the Speaker found by the `where` argument doesn't exist, create a new Speaker with this data.
     */
    create: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
    /**
     * In case the Speaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
  }

  /**
   * Speaker delete
   */
  export type SpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Filter which Speaker to delete.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker deleteMany
   */
  export type SpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speakers to delete
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to delete.
     */
    limit?: number
  }

  /**
   * Speaker findRaw
   */
  export type SpeakerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speaker aggregateRaw
   */
  export type SpeakerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speaker without action
   */
  export type SpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
  }


  /**
   * Model SpeakerSession
   */

  export type AggregateSpeakerSession = {
    _count: SpeakerSessionCountAggregateOutputType | null
    _min: SpeakerSessionMinAggregateOutputType | null
    _max: SpeakerSessionMaxAggregateOutputType | null
  }

  export type SpeakerSessionMinAggregateOutputType = {
    id: string | null
  }

  export type SpeakerSessionMaxAggregateOutputType = {
    id: string | null
  }

  export type SpeakerSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    speakerId: number
    _all: number
  }


  export type SpeakerSessionMinAggregateInputType = {
    id?: true
  }

  export type SpeakerSessionMaxAggregateInputType = {
    id?: true
  }

  export type SpeakerSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    speakerId?: true
    _all?: true
  }

  export type SpeakerSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakerSession to aggregate.
     */
    where?: SpeakerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerSessions to fetch.
     */
    orderBy?: SpeakerSessionOrderByWithRelationInput | SpeakerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakerSessions
    **/
    _count?: true | SpeakerSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerSessionMaxAggregateInputType
  }

  export type GetSpeakerSessionAggregateType<T extends SpeakerSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakerSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakerSession[P]>
      : GetScalarType<T[P], AggregateSpeakerSession[P]>
  }




  export type SpeakerSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerSessionWhereInput
    orderBy?: SpeakerSessionOrderByWithAggregationInput | SpeakerSessionOrderByWithAggregationInput[]
    by: SpeakerSessionScalarFieldEnum[] | SpeakerSessionScalarFieldEnum
    having?: SpeakerSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerSessionCountAggregateInputType | true
    _min?: SpeakerSessionMinAggregateInputType
    _max?: SpeakerSessionMaxAggregateInputType
  }

  export type SpeakerSessionGroupByOutputType = {
    id: string
    sessionId: JsonValue | null
    speakerId: JsonValue | null
    _count: SpeakerSessionCountAggregateOutputType | null
    _min: SpeakerSessionMinAggregateOutputType | null
    _max: SpeakerSessionMaxAggregateOutputType | null
  }

  type GetSpeakerSessionGroupByPayload<T extends SpeakerSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakerSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerSessionGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    speakerId?: boolean
  }, ExtArgs["result"]["speakerSession"]>



  export type SpeakerSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    speakerId?: boolean
  }

  export type SpeakerSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "speakerId", ExtArgs["result"]["speakerSession"]>

  export type $SpeakerSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakerSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      sessionId: Prisma.JsonValue | null
      /**
       * Field referred in an index, but found no data to define the type.
       */
      speakerId: Prisma.JsonValue | null
    }, ExtArgs["result"]["speakerSession"]>
    composites: {}
  }

  type SpeakerSessionGetPayload<S extends boolean | null | undefined | SpeakerSessionDefaultArgs> = $Result.GetResult<Prisma.$SpeakerSessionPayload, S>

  type SpeakerSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakerSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakerSessionCountAggregateInputType | true
    }

  export interface SpeakerSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakerSession'], meta: { name: 'SpeakerSession' } }
    /**
     * Find zero or one SpeakerSession that matches the filter.
     * @param {SpeakerSessionFindUniqueArgs} args - Arguments to find a SpeakerSession
     * @example
     * // Get one SpeakerSession
     * const speakerSession = await prisma.speakerSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerSessionFindUniqueArgs>(args: SelectSubset<T, SpeakerSessionFindUniqueArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpeakerSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerSessionFindUniqueOrThrowArgs} args - Arguments to find a SpeakerSession
     * @example
     * // Get one SpeakerSession
     * const speakerSession = await prisma.speakerSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakerSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeakerSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionFindFirstArgs} args - Arguments to find a SpeakerSession
     * @example
     * // Get one SpeakerSession
     * const speakerSession = await prisma.speakerSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerSessionFindFirstArgs>(args?: SelectSubset<T, SpeakerSessionFindFirstArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeakerSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionFindFirstOrThrowArgs} args - Arguments to find a SpeakerSession
     * @example
     * // Get one SpeakerSession
     * const speakerSession = await prisma.speakerSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakerSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeakerSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakerSessions
     * const speakerSessions = await prisma.speakerSession.findMany()
     * 
     * // Get first 10 SpeakerSessions
     * const speakerSessions = await prisma.speakerSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakerSessionWithIdOnly = await prisma.speakerSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakerSessionFindManyArgs>(args?: SelectSubset<T, SpeakerSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpeakerSession.
     * @param {SpeakerSessionCreateArgs} args - Arguments to create a SpeakerSession.
     * @example
     * // Create one SpeakerSession
     * const SpeakerSession = await prisma.speakerSession.create({
     *   data: {
     *     // ... data to create a SpeakerSession
     *   }
     * })
     * 
     */
    create<T extends SpeakerSessionCreateArgs>(args: SelectSubset<T, SpeakerSessionCreateArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpeakerSessions.
     * @param {SpeakerSessionCreateManyArgs} args - Arguments to create many SpeakerSessions.
     * @example
     * // Create many SpeakerSessions
     * const speakerSession = await prisma.speakerSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakerSessionCreateManyArgs>(args?: SelectSubset<T, SpeakerSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpeakerSession.
     * @param {SpeakerSessionDeleteArgs} args - Arguments to delete one SpeakerSession.
     * @example
     * // Delete one SpeakerSession
     * const SpeakerSession = await prisma.speakerSession.delete({
     *   where: {
     *     // ... filter to delete one SpeakerSession
     *   }
     * })
     * 
     */
    delete<T extends SpeakerSessionDeleteArgs>(args: SelectSubset<T, SpeakerSessionDeleteArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpeakerSession.
     * @param {SpeakerSessionUpdateArgs} args - Arguments to update one SpeakerSession.
     * @example
     * // Update one SpeakerSession
     * const speakerSession = await prisma.speakerSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakerSessionUpdateArgs>(args: SelectSubset<T, SpeakerSessionUpdateArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpeakerSessions.
     * @param {SpeakerSessionDeleteManyArgs} args - Arguments to filter SpeakerSessions to delete.
     * @example
     * // Delete a few SpeakerSessions
     * const { count } = await prisma.speakerSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakerSessionDeleteManyArgs>(args?: SelectSubset<T, SpeakerSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakerSessions
     * const speakerSession = await prisma.speakerSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakerSessionUpdateManyArgs>(args: SelectSubset<T, SpeakerSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeakerSession.
     * @param {SpeakerSessionUpsertArgs} args - Arguments to update or create a SpeakerSession.
     * @example
     * // Update or create a SpeakerSession
     * const speakerSession = await prisma.speakerSession.upsert({
     *   create: {
     *     // ... data to create a SpeakerSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakerSession we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerSessionUpsertArgs>(args: SelectSubset<T, SpeakerSessionUpsertArgs<ExtArgs>>): Prisma__SpeakerSessionClient<$Result.GetResult<Prisma.$SpeakerSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeakerSessions that matches the filter.
     * @param {SpeakerSessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speakerSession = await prisma.speakerSession.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SpeakerSessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SpeakerSession.
     * @param {SpeakerSessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speakerSession = await prisma.speakerSession.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpeakerSessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SpeakerSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionCountArgs} args - Arguments to filter SpeakerSessions to count.
     * @example
     * // Count the number of SpeakerSessions
     * const count = await prisma.speakerSession.count({
     *   where: {
     *     // ... the filter for the SpeakerSessions we want to count
     *   }
     * })
    **/
    count<T extends SpeakerSessionCountArgs>(
      args?: Subset<T, SpeakerSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerSessionAggregateArgs>(args: Subset<T, SpeakerSessionAggregateArgs>): Prisma.PrismaPromise<GetSpeakerSessionAggregateType<T>>

    /**
     * Group by SpeakerSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerSessionGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakerSession model
   */
  readonly fields: SpeakerSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakerSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakerSession model
   */
  interface SpeakerSessionFieldRefs {
    readonly id: FieldRef<"SpeakerSession", 'String'>
    readonly sessionId: FieldRef<"SpeakerSession", 'Json'>
    readonly speakerId: FieldRef<"SpeakerSession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SpeakerSession findUnique
   */
  export type SpeakerSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter, which SpeakerSession to fetch.
     */
    where: SpeakerSessionWhereUniqueInput
  }

  /**
   * SpeakerSession findUniqueOrThrow
   */
  export type SpeakerSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter, which SpeakerSession to fetch.
     */
    where: SpeakerSessionWhereUniqueInput
  }

  /**
   * SpeakerSession findFirst
   */
  export type SpeakerSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter, which SpeakerSession to fetch.
     */
    where?: SpeakerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerSessions to fetch.
     */
    orderBy?: SpeakerSessionOrderByWithRelationInput | SpeakerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakerSessions.
     */
    cursor?: SpeakerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakerSessions.
     */
    distinct?: SpeakerSessionScalarFieldEnum | SpeakerSessionScalarFieldEnum[]
  }

  /**
   * SpeakerSession findFirstOrThrow
   */
  export type SpeakerSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter, which SpeakerSession to fetch.
     */
    where?: SpeakerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerSessions to fetch.
     */
    orderBy?: SpeakerSessionOrderByWithRelationInput | SpeakerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakerSessions.
     */
    cursor?: SpeakerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakerSessions.
     */
    distinct?: SpeakerSessionScalarFieldEnum | SpeakerSessionScalarFieldEnum[]
  }

  /**
   * SpeakerSession findMany
   */
  export type SpeakerSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter, which SpeakerSessions to fetch.
     */
    where?: SpeakerSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerSessions to fetch.
     */
    orderBy?: SpeakerSessionOrderByWithRelationInput | SpeakerSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakerSessions.
     */
    cursor?: SpeakerSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerSessions.
     */
    skip?: number
    distinct?: SpeakerSessionScalarFieldEnum | SpeakerSessionScalarFieldEnum[]
  }

  /**
   * SpeakerSession create
   */
  export type SpeakerSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * The data needed to create a SpeakerSession.
     */
    data?: XOR<SpeakerSessionCreateInput, SpeakerSessionUncheckedCreateInput>
  }

  /**
   * SpeakerSession createMany
   */
  export type SpeakerSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakerSessions.
     */
    data: SpeakerSessionCreateManyInput | SpeakerSessionCreateManyInput[]
  }

  /**
   * SpeakerSession update
   */
  export type SpeakerSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * The data needed to update a SpeakerSession.
     */
    data: XOR<SpeakerSessionUpdateInput, SpeakerSessionUncheckedUpdateInput>
    /**
     * Choose, which SpeakerSession to update.
     */
    where: SpeakerSessionWhereUniqueInput
  }

  /**
   * SpeakerSession updateMany
   */
  export type SpeakerSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakerSessions.
     */
    data: XOR<SpeakerSessionUpdateManyMutationInput, SpeakerSessionUncheckedUpdateManyInput>
    /**
     * Filter which SpeakerSessions to update
     */
    where?: SpeakerSessionWhereInput
    /**
     * Limit how many SpeakerSessions to update.
     */
    limit?: number
  }

  /**
   * SpeakerSession upsert
   */
  export type SpeakerSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * The filter to search for the SpeakerSession to update in case it exists.
     */
    where: SpeakerSessionWhereUniqueInput
    /**
     * In case the SpeakerSession found by the `where` argument doesn't exist, create a new SpeakerSession with this data.
     */
    create: XOR<SpeakerSessionCreateInput, SpeakerSessionUncheckedCreateInput>
    /**
     * In case the SpeakerSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerSessionUpdateInput, SpeakerSessionUncheckedUpdateInput>
  }

  /**
   * SpeakerSession delete
   */
  export type SpeakerSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
    /**
     * Filter which SpeakerSession to delete.
     */
    where: SpeakerSessionWhereUniqueInput
  }

  /**
   * SpeakerSession deleteMany
   */
  export type SpeakerSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakerSessions to delete
     */
    where?: SpeakerSessionWhereInput
    /**
     * Limit how many SpeakerSessions to delete.
     */
    limit?: number
  }

  /**
   * SpeakerSession findRaw
   */
  export type SpeakerSessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpeakerSession aggregateRaw
   */
  export type SpeakerSessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SpeakerSession without action
   */
  export type SpeakerSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerSession
     */
    select?: SpeakerSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerSession
     */
    omit?: SpeakerSessionOmit<ExtArgs> | null
  }


  /**
   * Model Speakers
   */

  export type AggregateSpeakers = {
    _count: SpeakersCountAggregateOutputType | null
    _min: SpeakersMinAggregateOutputType | null
    _max: SpeakersMaxAggregateOutputType | null
  }

  export type SpeakersMinAggregateOutputType = {
    id: string | null
  }

  export type SpeakersMaxAggregateOutputType = {
    id: string | null
  }

  export type SpeakersCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type SpeakersMinAggregateInputType = {
    id?: true
  }

  export type SpeakersMaxAggregateInputType = {
    id?: true
  }

  export type SpeakersCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type SpeakersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speakers to aggregate.
     */
    where?: SpeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakersOrderByWithRelationInput | SpeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speakers
    **/
    _count?: true | SpeakersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakersMaxAggregateInputType
  }

  export type GetSpeakersAggregateType<T extends SpeakersAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakers[P]>
      : GetScalarType<T[P], AggregateSpeakers[P]>
  }




  export type SpeakersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakersWhereInput
    orderBy?: SpeakersOrderByWithAggregationInput | SpeakersOrderByWithAggregationInput[]
    by: SpeakersScalarFieldEnum[] | SpeakersScalarFieldEnum
    having?: SpeakersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakersCountAggregateInputType | true
    _min?: SpeakersMinAggregateInputType
    _max?: SpeakersMaxAggregateInputType
  }

  export type SpeakersGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: SpeakersCountAggregateOutputType | null
    _min: SpeakersMinAggregateOutputType | null
    _max: SpeakersMaxAggregateOutputType | null
  }

  type GetSpeakersGroupByPayload<T extends SpeakersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakersGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakersGroupByOutputType[P]>
        }
      >
    >


  export type SpeakersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["speakers"]>



  export type SpeakersSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type SpeakersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["speakers"]>

  export type $SpeakersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Speakers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["speakers"]>
    composites: {}
  }

  type SpeakersGetPayload<S extends boolean | null | undefined | SpeakersDefaultArgs> = $Result.GetResult<Prisma.$SpeakersPayload, S>

  type SpeakersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakersCountAggregateInputType | true
    }

  export interface SpeakersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Speakers'], meta: { name: 'Speakers' } }
    /**
     * Find zero or one Speakers that matches the filter.
     * @param {SpeakersFindUniqueArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakersFindUniqueArgs>(args: SelectSubset<T, SpeakersFindUniqueArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Speakers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakersFindUniqueOrThrowArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakersFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersFindFirstArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakersFindFirstArgs>(args?: SelectSubset<T, SpeakersFindFirstArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speakers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersFindFirstOrThrowArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakersFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakersFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speakers.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speakers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakersWithIdOnly = await prisma.speakers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakersFindManyArgs>(args?: SelectSubset<T, SpeakersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Speakers.
     * @param {SpeakersCreateArgs} args - Arguments to create a Speakers.
     * @example
     * // Create one Speakers
     * const Speakers = await prisma.speakers.create({
     *   data: {
     *     // ... data to create a Speakers
     *   }
     * })
     * 
     */
    create<T extends SpeakersCreateArgs>(args: SelectSubset<T, SpeakersCreateArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Speakers.
     * @param {SpeakersCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speakers = await prisma.speakers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakersCreateManyArgs>(args?: SelectSubset<T, SpeakersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Speakers.
     * @param {SpeakersDeleteArgs} args - Arguments to delete one Speakers.
     * @example
     * // Delete one Speakers
     * const Speakers = await prisma.speakers.delete({
     *   where: {
     *     // ... filter to delete one Speakers
     *   }
     * })
     * 
     */
    delete<T extends SpeakersDeleteArgs>(args: SelectSubset<T, SpeakersDeleteArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Speakers.
     * @param {SpeakersUpdateArgs} args - Arguments to update one Speakers.
     * @example
     * // Update one Speakers
     * const speakers = await prisma.speakers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakersUpdateArgs>(args: SelectSubset<T, SpeakersUpdateArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Speakers.
     * @param {SpeakersDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speakers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakersDeleteManyArgs>(args?: SelectSubset<T, SpeakersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speakers = await prisma.speakers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakersUpdateManyArgs>(args: SelectSubset<T, SpeakersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Speakers.
     * @param {SpeakersUpsertArgs} args - Arguments to update or create a Speakers.
     * @example
     * // Update or create a Speakers
     * const speakers = await prisma.speakers.upsert({
     *   create: {
     *     // ... data to create a Speakers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speakers we want to update
     *   }
     * })
     */
    upsert<T extends SpeakersUpsertArgs>(args: SelectSubset<T, SpeakersUpsertArgs<ExtArgs>>): Prisma__SpeakersClient<$Result.GetResult<Prisma.$SpeakersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * @param {SpeakersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speakers = await prisma.speakers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SpeakersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Speakers.
     * @param {SpeakersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speakers = await prisma.speakers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SpeakersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speakers.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends SpeakersCountArgs>(
      args?: Subset<T, SpeakersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakersAggregateArgs>(args: Subset<T, SpeakersAggregateArgs>): Prisma.PrismaPromise<GetSpeakersAggregateType<T>>

    /**
     * Group by Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakersGroupByArgs['orderBy'] }
        : { orderBy?: SpeakersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Speakers model
   */
  readonly fields: SpeakersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speakers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Speakers model
   */
  interface SpeakersFieldRefs {
    readonly id: FieldRef<"Speakers", 'String'>
    readonly projectId: FieldRef<"Speakers", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Speakers findUnique
   */
  export type SpeakersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where: SpeakersWhereUniqueInput
  }

  /**
   * Speakers findUniqueOrThrow
   */
  export type SpeakersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where: SpeakersWhereUniqueInput
  }

  /**
   * Speakers findFirst
   */
  export type SpeakersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakersOrderByWithRelationInput | SpeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * Speakers findFirstOrThrow
   */
  export type SpeakersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakersOrderByWithRelationInput | SpeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * Speakers findMany
   */
  export type SpeakersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakersOrderByWithRelationInput | SpeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speakers.
     */
    cursor?: SpeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * Speakers create
   */
  export type SpeakersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * The data needed to create a Speakers.
     */
    data?: XOR<SpeakersCreateInput, SpeakersUncheckedCreateInput>
  }

  /**
   * Speakers createMany
   */
  export type SpeakersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Speakers.
     */
    data: SpeakersCreateManyInput | SpeakersCreateManyInput[]
  }

  /**
   * Speakers update
   */
  export type SpeakersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * The data needed to update a Speakers.
     */
    data: XOR<SpeakersUpdateInput, SpeakersUncheckedUpdateInput>
    /**
     * Choose, which Speakers to update.
     */
    where: SpeakersWhereUniqueInput
  }

  /**
   * Speakers updateMany
   */
  export type SpeakersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakersUpdateManyMutationInput, SpeakersUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     */
    where?: SpeakersWhereInput
    /**
     * Limit how many Speakers to update.
     */
    limit?: number
  }

  /**
   * Speakers upsert
   */
  export type SpeakersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * The filter to search for the Speakers to update in case it exists.
     */
    where: SpeakersWhereUniqueInput
    /**
     * In case the Speakers found by the `where` argument doesn't exist, create a new Speakers with this data.
     */
    create: XOR<SpeakersCreateInput, SpeakersUncheckedCreateInput>
    /**
     * In case the Speakers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakersUpdateInput, SpeakersUncheckedUpdateInput>
  }

  /**
   * Speakers delete
   */
  export type SpeakersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
    /**
     * Filter which Speakers to delete.
     */
    where: SpeakersWhereUniqueInput
  }

  /**
   * Speakers deleteMany
   */
  export type SpeakersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speakers to delete
     */
    where?: SpeakersWhereInput
    /**
     * Limit how many Speakers to delete.
     */
    limit?: number
  }

  /**
   * Speakers findRaw
   */
  export type SpeakersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speakers aggregateRaw
   */
  export type SpeakersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Speakers without action
   */
  export type SpeakersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speakers
     */
    select?: SpeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speakers
     */
    omit?: SpeakersOmit<ExtArgs> | null
  }


  /**
   * Model Sponsor
   */

  export type AggregateSponsor = {
    _count: SponsorCountAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  export type SponsorMinAggregateOutputType = {
    id: string | null
  }

  export type SponsorMaxAggregateOutputType = {
    id: string | null
  }

  export type SponsorCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SponsorMinAggregateInputType = {
    id?: true
  }

  export type SponsorMaxAggregateInputType = {
    id?: true
  }

  export type SponsorCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SponsorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsor to aggregate.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorMaxAggregateInputType
  }

  export type GetSponsorAggregateType<T extends SponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsor[P]>
      : GetScalarType<T[P], AggregateSponsor[P]>
  }




  export type SponsorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorWhereInput
    orderBy?: SponsorOrderByWithAggregationInput | SponsorOrderByWithAggregationInput[]
    by: SponsorScalarFieldEnum[] | SponsorScalarFieldEnum
    having?: SponsorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorCountAggregateInputType | true
    _min?: SponsorMinAggregateInputType
    _max?: SponsorMaxAggregateInputType
  }

  export type SponsorGroupByOutputType = {
    id: string
    _count: SponsorCountAggregateOutputType | null
    _min: SponsorMinAggregateOutputType | null
    _max: SponsorMaxAggregateOutputType | null
  }

  type GetSponsorGroupByPayload<T extends SponsorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorGroupByOutputType[P]>
        }
      >
    >


  export type SponsorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["sponsor"]>



  export type SponsorSelectScalar = {
    id?: boolean
  }

  export type SponsorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["sponsor"]>

  export type $SponsorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsor"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["sponsor"]>
    composites: {}
  }

  type SponsorGetPayload<S extends boolean | null | undefined | SponsorDefaultArgs> = $Result.GetResult<Prisma.$SponsorPayload, S>

  type SponsorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorCountAggregateInputType | true
    }

  export interface SponsorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsor'], meta: { name: 'Sponsor' } }
    /**
     * Find zero or one Sponsor that matches the filter.
     * @param {SponsorFindUniqueArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorFindUniqueArgs>(args: SelectSubset<T, SponsorFindUniqueArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorFindUniqueOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorFindFirstArgs>(args?: SelectSubset<T, SponsorFindFirstArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindFirstOrThrowArgs} args - Arguments to find a Sponsor
     * @example
     * // Get one Sponsor
     * const sponsor = await prisma.sponsor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsor.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsorWithIdOnly = await prisma.sponsor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsorFindManyArgs>(args?: SelectSubset<T, SponsorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsor.
     * @param {SponsorCreateArgs} args - Arguments to create a Sponsor.
     * @example
     * // Create one Sponsor
     * const Sponsor = await prisma.sponsor.create({
     *   data: {
     *     // ... data to create a Sponsor
     *   }
     * })
     * 
     */
    create<T extends SponsorCreateArgs>(args: SelectSubset<T, SponsorCreateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsors.
     * @param {SponsorCreateManyArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsor = await prisma.sponsor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorCreateManyArgs>(args?: SelectSubset<T, SponsorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sponsor.
     * @param {SponsorDeleteArgs} args - Arguments to delete one Sponsor.
     * @example
     * // Delete one Sponsor
     * const Sponsor = await prisma.sponsor.delete({
     *   where: {
     *     // ... filter to delete one Sponsor
     *   }
     * })
     * 
     */
    delete<T extends SponsorDeleteArgs>(args: SelectSubset<T, SponsorDeleteArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsor.
     * @param {SponsorUpdateArgs} args - Arguments to update one Sponsor.
     * @example
     * // Update one Sponsor
     * const sponsor = await prisma.sponsor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorUpdateArgs>(args: SelectSubset<T, SponsorUpdateArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorDeleteManyArgs>(args?: SelectSubset<T, SponsorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsor = await prisma.sponsor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorUpdateManyArgs>(args: SelectSubset<T, SponsorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sponsor.
     * @param {SponsorUpsertArgs} args - Arguments to update or create a Sponsor.
     * @example
     * // Update or create a Sponsor
     * const sponsor = await prisma.sponsor.upsert({
     *   create: {
     *     // ... data to create a Sponsor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsor we want to update
     *   }
     * })
     */
    upsert<T extends SponsorUpsertArgs>(args: SelectSubset<T, SponsorUpsertArgs<ExtArgs>>): Prisma__SponsorClient<$Result.GetResult<Prisma.$SponsorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * @param {SponsorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sponsor = await prisma.sponsor.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SponsorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sponsor.
     * @param {SponsorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sponsor = await prisma.sponsor.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SponsorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsor.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorCountArgs>(
      args?: Subset<T, SponsorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorAggregateArgs>(args: Subset<T, SponsorAggregateArgs>): Prisma.PrismaPromise<GetSponsorAggregateType<T>>

    /**
     * Group by Sponsor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorGroupByArgs['orderBy'] }
        : { orderBy?: SponsorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsor model
   */
  readonly fields: SponsorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsor model
   */
  interface SponsorFieldRefs {
    readonly id: FieldRef<"Sponsor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sponsor findUnique
   */
  export type SponsorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findUniqueOrThrow
   */
  export type SponsorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor findFirst
   */
  export type SponsorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findFirstOrThrow
   */
  export type SponsorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter, which Sponsor to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor findMany
   */
  export type SponsorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorOrderByWithRelationInput | SponsorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorScalarFieldEnum | SponsorScalarFieldEnum[]
  }

  /**
   * Sponsor create
   */
  export type SponsorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data needed to create a Sponsor.
     */
    data?: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
  }

  /**
   * Sponsor createMany
   */
  export type SponsorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorCreateManyInput | SponsorCreateManyInput[]
  }

  /**
   * Sponsor update
   */
  export type SponsorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The data needed to update a Sponsor.
     */
    data: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
    /**
     * Choose, which Sponsor to update.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor updateMany
   */
  export type SponsorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorUpdateManyMutationInput, SponsorUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsor upsert
   */
  export type SponsorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * The filter to search for the Sponsor to update in case it exists.
     */
    where: SponsorWhereUniqueInput
    /**
     * In case the Sponsor found by the `where` argument doesn't exist, create a new Sponsor with this data.
     */
    create: XOR<SponsorCreateInput, SponsorUncheckedCreateInput>
    /**
     * In case the Sponsor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorUpdateInput, SponsorUncheckedUpdateInput>
  }

  /**
   * Sponsor delete
   */
  export type SponsorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
    /**
     * Filter which Sponsor to delete.
     */
    where: SponsorWhereUniqueInput
  }

  /**
   * Sponsor deleteMany
   */
  export type SponsorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorWhereInput
    /**
     * Limit how many Sponsors to delete.
     */
    limit?: number
  }

  /**
   * Sponsor findRaw
   */
  export type SponsorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsor aggregateRaw
   */
  export type SponsorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsor without action
   */
  export type SponsorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsor
     */
    select?: SponsorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsor
     */
    omit?: SponsorOmit<ExtArgs> | null
  }


  /**
   * Model Sponsors
   */

  export type AggregateSponsors = {
    _count: SponsorsCountAggregateOutputType | null
    _min: SponsorsMinAggregateOutputType | null
    _max: SponsorsMaxAggregateOutputType | null
  }

  export type SponsorsMinAggregateOutputType = {
    id: string | null
  }

  export type SponsorsMaxAggregateOutputType = {
    id: string | null
  }

  export type SponsorsCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type SponsorsMinAggregateInputType = {
    id?: true
  }

  export type SponsorsMaxAggregateInputType = {
    id?: true
  }

  export type SponsorsCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type SponsorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to aggregate.
     */
    where?: SponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorsOrderByWithRelationInput | SponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sponsors
    **/
    _count?: true | SponsorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SponsorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SponsorsMaxAggregateInputType
  }

  export type GetSponsorsAggregateType<T extends SponsorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSponsors[P]>
      : GetScalarType<T[P], AggregateSponsors[P]>
  }




  export type SponsorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SponsorsWhereInput
    orderBy?: SponsorsOrderByWithAggregationInput | SponsorsOrderByWithAggregationInput[]
    by: SponsorsScalarFieldEnum[] | SponsorsScalarFieldEnum
    having?: SponsorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SponsorsCountAggregateInputType | true
    _min?: SponsorsMinAggregateInputType
    _max?: SponsorsMaxAggregateInputType
  }

  export type SponsorsGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: SponsorsCountAggregateOutputType | null
    _min: SponsorsMinAggregateOutputType | null
    _max: SponsorsMaxAggregateOutputType | null
  }

  type GetSponsorsGroupByPayload<T extends SponsorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SponsorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SponsorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
            : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
        }
      >
    >


  export type SponsorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["sponsors"]>



  export type SponsorsSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type SponsorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["sponsors"]>

  export type $SponsorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sponsors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["sponsors"]>
    composites: {}
  }

  type SponsorsGetPayload<S extends boolean | null | undefined | SponsorsDefaultArgs> = $Result.GetResult<Prisma.$SponsorsPayload, S>

  type SponsorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SponsorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SponsorsCountAggregateInputType | true
    }

  export interface SponsorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sponsors'], meta: { name: 'Sponsors' } }
    /**
     * Find zero or one Sponsors that matches the filter.
     * @param {SponsorsFindUniqueArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SponsorsFindUniqueArgs>(args: SelectSubset<T, SponsorsFindUniqueArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sponsors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SponsorsFindUniqueOrThrowArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SponsorsFindUniqueOrThrowArgs>(args: SelectSubset<T, SponsorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsFindFirstArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SponsorsFindFirstArgs>(args?: SelectSubset<T, SponsorsFindFirstArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sponsors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsFindFirstOrThrowArgs} args - Arguments to find a Sponsors
     * @example
     * // Get one Sponsors
     * const sponsors = await prisma.sponsors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SponsorsFindFirstOrThrowArgs>(args?: SelectSubset<T, SponsorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sponsors
     * const sponsors = await prisma.sponsors.findMany()
     * 
     * // Get first 10 Sponsors
     * const sponsors = await prisma.sponsors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sponsorsWithIdOnly = await prisma.sponsors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SponsorsFindManyArgs>(args?: SelectSubset<T, SponsorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sponsors.
     * @param {SponsorsCreateArgs} args - Arguments to create a Sponsors.
     * @example
     * // Create one Sponsors
     * const Sponsors = await prisma.sponsors.create({
     *   data: {
     *     // ... data to create a Sponsors
     *   }
     * })
     * 
     */
    create<T extends SponsorsCreateArgs>(args: SelectSubset<T, SponsorsCreateArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sponsors.
     * @param {SponsorsCreateManyArgs} args - Arguments to create many Sponsors.
     * @example
     * // Create many Sponsors
     * const sponsors = await prisma.sponsors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SponsorsCreateManyArgs>(args?: SelectSubset<T, SponsorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sponsors.
     * @param {SponsorsDeleteArgs} args - Arguments to delete one Sponsors.
     * @example
     * // Delete one Sponsors
     * const Sponsors = await prisma.sponsors.delete({
     *   where: {
     *     // ... filter to delete one Sponsors
     *   }
     * })
     * 
     */
    delete<T extends SponsorsDeleteArgs>(args: SelectSubset<T, SponsorsDeleteArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sponsors.
     * @param {SponsorsUpdateArgs} args - Arguments to update one Sponsors.
     * @example
     * // Update one Sponsors
     * const sponsors = await prisma.sponsors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SponsorsUpdateArgs>(args: SelectSubset<T, SponsorsUpdateArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sponsors.
     * @param {SponsorsDeleteManyArgs} args - Arguments to filter Sponsors to delete.
     * @example
     * // Delete a few Sponsors
     * const { count } = await prisma.sponsors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SponsorsDeleteManyArgs>(args?: SelectSubset<T, SponsorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sponsors
     * const sponsors = await prisma.sponsors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SponsorsUpdateManyArgs>(args: SelectSubset<T, SponsorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sponsors.
     * @param {SponsorsUpsertArgs} args - Arguments to update or create a Sponsors.
     * @example
     * // Update or create a Sponsors
     * const sponsors = await prisma.sponsors.upsert({
     *   create: {
     *     // ... data to create a Sponsors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sponsors we want to update
     *   }
     * })
     */
    upsert<T extends SponsorsUpsertArgs>(args: SelectSubset<T, SponsorsUpsertArgs<ExtArgs>>): Prisma__SponsorsClient<$Result.GetResult<Prisma.$SponsorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sponsors that matches the filter.
     * @param {SponsorsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sponsors = await prisma.sponsors.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SponsorsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sponsors.
     * @param {SponsorsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sponsors = await prisma.sponsors.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SponsorsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsCountArgs} args - Arguments to filter Sponsors to count.
     * @example
     * // Count the number of Sponsors
     * const count = await prisma.sponsors.count({
     *   where: {
     *     // ... the filter for the Sponsors we want to count
     *   }
     * })
    **/
    count<T extends SponsorsCountArgs>(
      args?: Subset<T, SponsorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SponsorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SponsorsAggregateArgs>(args: Subset<T, SponsorsAggregateArgs>): Prisma.PrismaPromise<GetSponsorsAggregateType<T>>

    /**
     * Group by Sponsors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SponsorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SponsorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SponsorsGroupByArgs['orderBy'] }
        : { orderBy?: SponsorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SponsorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSponsorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sponsors model
   */
  readonly fields: SponsorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sponsors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SponsorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sponsors model
   */
  interface SponsorsFieldRefs {
    readonly id: FieldRef<"Sponsors", 'String'>
    readonly projectId: FieldRef<"Sponsors", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Sponsors findUnique
   */
  export type SponsorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where: SponsorsWhereUniqueInput
  }

  /**
   * Sponsors findUniqueOrThrow
   */
  export type SponsorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where: SponsorsWhereUniqueInput
  }

  /**
   * Sponsors findFirst
   */
  export type SponsorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorsOrderByWithRelationInput | SponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }

  /**
   * Sponsors findFirstOrThrow
   */
  export type SponsorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorsOrderByWithRelationInput | SponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sponsors.
     */
    cursor?: SponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sponsors.
     */
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }

  /**
   * Sponsors findMany
   */
  export type SponsorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter, which Sponsors to fetch.
     */
    where?: SponsorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sponsors to fetch.
     */
    orderBy?: SponsorsOrderByWithRelationInput | SponsorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sponsors.
     */
    cursor?: SponsorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sponsors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sponsors.
     */
    skip?: number
    distinct?: SponsorsScalarFieldEnum | SponsorsScalarFieldEnum[]
  }

  /**
   * Sponsors create
   */
  export type SponsorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * The data needed to create a Sponsors.
     */
    data?: XOR<SponsorsCreateInput, SponsorsUncheckedCreateInput>
  }

  /**
   * Sponsors createMany
   */
  export type SponsorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sponsors.
     */
    data: SponsorsCreateManyInput | SponsorsCreateManyInput[]
  }

  /**
   * Sponsors update
   */
  export type SponsorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * The data needed to update a Sponsors.
     */
    data: XOR<SponsorsUpdateInput, SponsorsUncheckedUpdateInput>
    /**
     * Choose, which Sponsors to update.
     */
    where: SponsorsWhereUniqueInput
  }

  /**
   * Sponsors updateMany
   */
  export type SponsorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sponsors.
     */
    data: XOR<SponsorsUpdateManyMutationInput, SponsorsUncheckedUpdateManyInput>
    /**
     * Filter which Sponsors to update
     */
    where?: SponsorsWhereInput
    /**
     * Limit how many Sponsors to update.
     */
    limit?: number
  }

  /**
   * Sponsors upsert
   */
  export type SponsorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * The filter to search for the Sponsors to update in case it exists.
     */
    where: SponsorsWhereUniqueInput
    /**
     * In case the Sponsors found by the `where` argument doesn't exist, create a new Sponsors with this data.
     */
    create: XOR<SponsorsCreateInput, SponsorsUncheckedCreateInput>
    /**
     * In case the Sponsors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SponsorsUpdateInput, SponsorsUncheckedUpdateInput>
  }

  /**
   * Sponsors delete
   */
  export type SponsorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
    /**
     * Filter which Sponsors to delete.
     */
    where: SponsorsWhereUniqueInput
  }

  /**
   * Sponsors deleteMany
   */
  export type SponsorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sponsors to delete
     */
    where?: SponsorsWhereInput
    /**
     * Limit how many Sponsors to delete.
     */
    limit?: number
  }

  /**
   * Sponsors findRaw
   */
  export type SponsorsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsors aggregateRaw
   */
  export type SponsorsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Sponsors without action
   */
  export type SponsorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sponsors
     */
    select?: SponsorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sponsors
     */
    omit?: SponsorsOmit<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["ticket"]>



  export type TicketSelectScalar = {
    id?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["ticket"]>

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * @param {TicketFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticket = await prisma.ticket.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ticket.
     * @param {TicketAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticket = await prisma.ticket.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data?: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket findRaw
   */
  export type TicketFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ticket aggregateRaw
   */
  export type TicketAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
  }


  /**
   * Model Ticketing
   */

  export type AggregateTicketing = {
    _count: TicketingCountAggregateOutputType | null
    _min: TicketingMinAggregateOutputType | null
    _max: TicketingMaxAggregateOutputType | null
  }

  export type TicketingMinAggregateOutputType = {
    id: string | null
  }

  export type TicketingMaxAggregateOutputType = {
    id: string | null
  }

  export type TicketingCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type TicketingMinAggregateInputType = {
    id?: true
  }

  export type TicketingMaxAggregateInputType = {
    id?: true
  }

  export type TicketingCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type TicketingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticketing to aggregate.
     */
    where?: TicketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticketings to fetch.
     */
    orderBy?: TicketingOrderByWithRelationInput | TicketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ticketings
    **/
    _count?: true | TicketingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketingMaxAggregateInputType
  }

  export type GetTicketingAggregateType<T extends TicketingAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketing[P]>
      : GetScalarType<T[P], AggregateTicketing[P]>
  }




  export type TicketingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketingWhereInput
    orderBy?: TicketingOrderByWithAggregationInput | TicketingOrderByWithAggregationInput[]
    by: TicketingScalarFieldEnum[] | TicketingScalarFieldEnum
    having?: TicketingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketingCountAggregateInputType | true
    _min?: TicketingMinAggregateInputType
    _max?: TicketingMaxAggregateInputType
  }

  export type TicketingGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: TicketingCountAggregateOutputType | null
    _min: TicketingMinAggregateOutputType | null
    _max: TicketingMaxAggregateOutputType | null
  }

  type GetTicketingGroupByPayload<T extends TicketingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketingGroupByOutputType[P]>
            : GetScalarType<T[P], TicketingGroupByOutputType[P]>
        }
      >
    >


  export type TicketingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
  }, ExtArgs["result"]["ticketing"]>



  export type TicketingSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type TicketingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["ticketing"]>

  export type $TicketingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticketing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      projectId: Prisma.JsonValue | null
    }, ExtArgs["result"]["ticketing"]>
    composites: {}
  }

  type TicketingGetPayload<S extends boolean | null | undefined | TicketingDefaultArgs> = $Result.GetResult<Prisma.$TicketingPayload, S>

  type TicketingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketingCountAggregateInputType | true
    }

  export interface TicketingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticketing'], meta: { name: 'Ticketing' } }
    /**
     * Find zero or one Ticketing that matches the filter.
     * @param {TicketingFindUniqueArgs} args - Arguments to find a Ticketing
     * @example
     * // Get one Ticketing
     * const ticketing = await prisma.ticketing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketingFindUniqueArgs>(args: SelectSubset<T, TicketingFindUniqueArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticketing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketingFindUniqueOrThrowArgs} args - Arguments to find a Ticketing
     * @example
     * // Get one Ticketing
     * const ticketing = await prisma.ticketing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketingFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticketing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingFindFirstArgs} args - Arguments to find a Ticketing
     * @example
     * // Get one Ticketing
     * const ticketing = await prisma.ticketing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketingFindFirstArgs>(args?: SelectSubset<T, TicketingFindFirstArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticketing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingFindFirstOrThrowArgs} args - Arguments to find a Ticketing
     * @example
     * // Get one Ticketing
     * const ticketing = await prisma.ticketing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketingFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ticketings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ticketings
     * const ticketings = await prisma.ticketing.findMany()
     * 
     * // Get first 10 Ticketings
     * const ticketings = await prisma.ticketing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketingWithIdOnly = await prisma.ticketing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketingFindManyArgs>(args?: SelectSubset<T, TicketingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticketing.
     * @param {TicketingCreateArgs} args - Arguments to create a Ticketing.
     * @example
     * // Create one Ticketing
     * const Ticketing = await prisma.ticketing.create({
     *   data: {
     *     // ... data to create a Ticketing
     *   }
     * })
     * 
     */
    create<T extends TicketingCreateArgs>(args: SelectSubset<T, TicketingCreateArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ticketings.
     * @param {TicketingCreateManyArgs} args - Arguments to create many Ticketings.
     * @example
     * // Create many Ticketings
     * const ticketing = await prisma.ticketing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketingCreateManyArgs>(args?: SelectSubset<T, TicketingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ticketing.
     * @param {TicketingDeleteArgs} args - Arguments to delete one Ticketing.
     * @example
     * // Delete one Ticketing
     * const Ticketing = await prisma.ticketing.delete({
     *   where: {
     *     // ... filter to delete one Ticketing
     *   }
     * })
     * 
     */
    delete<T extends TicketingDeleteArgs>(args: SelectSubset<T, TicketingDeleteArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticketing.
     * @param {TicketingUpdateArgs} args - Arguments to update one Ticketing.
     * @example
     * // Update one Ticketing
     * const ticketing = await prisma.ticketing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketingUpdateArgs>(args: SelectSubset<T, TicketingUpdateArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ticketings.
     * @param {TicketingDeleteManyArgs} args - Arguments to filter Ticketings to delete.
     * @example
     * // Delete a few Ticketings
     * const { count } = await prisma.ticketing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketingDeleteManyArgs>(args?: SelectSubset<T, TicketingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ticketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ticketings
     * const ticketing = await prisma.ticketing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketingUpdateManyArgs>(args: SelectSubset<T, TicketingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ticketing.
     * @param {TicketingUpsertArgs} args - Arguments to update or create a Ticketing.
     * @example
     * // Update or create a Ticketing
     * const ticketing = await prisma.ticketing.upsert({
     *   create: {
     *     // ... data to create a Ticketing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticketing we want to update
     *   }
     * })
     */
    upsert<T extends TicketingUpsertArgs>(args: SelectSubset<T, TicketingUpsertArgs<ExtArgs>>): Prisma__TicketingClient<$Result.GetResult<Prisma.$TicketingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ticketings that matches the filter.
     * @param {TicketingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const ticketing = await prisma.ticketing.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TicketingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Ticketing.
     * @param {TicketingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const ticketing = await prisma.ticketing.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TicketingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Ticketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingCountArgs} args - Arguments to filter Ticketings to count.
     * @example
     * // Count the number of Ticketings
     * const count = await prisma.ticketing.count({
     *   where: {
     *     // ... the filter for the Ticketings we want to count
     *   }
     * })
    **/
    count<T extends TicketingCountArgs>(
      args?: Subset<T, TicketingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketingAggregateArgs>(args: Subset<T, TicketingAggregateArgs>): Prisma.PrismaPromise<GetTicketingAggregateType<T>>

    /**
     * Group by Ticketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketingGroupByArgs['orderBy'] }
        : { orderBy?: TicketingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticketing model
   */
  readonly fields: TicketingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticketing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticketing model
   */
  interface TicketingFieldRefs {
    readonly id: FieldRef<"Ticketing", 'String'>
    readonly projectId: FieldRef<"Ticketing", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Ticketing findUnique
   */
  export type TicketingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter, which Ticketing to fetch.
     */
    where: TicketingWhereUniqueInput
  }

  /**
   * Ticketing findUniqueOrThrow
   */
  export type TicketingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter, which Ticketing to fetch.
     */
    where: TicketingWhereUniqueInput
  }

  /**
   * Ticketing findFirst
   */
  export type TicketingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter, which Ticketing to fetch.
     */
    where?: TicketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticketings to fetch.
     */
    orderBy?: TicketingOrderByWithRelationInput | TicketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ticketings.
     */
    cursor?: TicketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ticketings.
     */
    distinct?: TicketingScalarFieldEnum | TicketingScalarFieldEnum[]
  }

  /**
   * Ticketing findFirstOrThrow
   */
  export type TicketingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter, which Ticketing to fetch.
     */
    where?: TicketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticketings to fetch.
     */
    orderBy?: TicketingOrderByWithRelationInput | TicketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ticketings.
     */
    cursor?: TicketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ticketings.
     */
    distinct?: TicketingScalarFieldEnum | TicketingScalarFieldEnum[]
  }

  /**
   * Ticketing findMany
   */
  export type TicketingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter, which Ticketings to fetch.
     */
    where?: TicketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ticketings to fetch.
     */
    orderBy?: TicketingOrderByWithRelationInput | TicketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ticketings.
     */
    cursor?: TicketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ticketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ticketings.
     */
    skip?: number
    distinct?: TicketingScalarFieldEnum | TicketingScalarFieldEnum[]
  }

  /**
   * Ticketing create
   */
  export type TicketingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * The data needed to create a Ticketing.
     */
    data?: XOR<TicketingCreateInput, TicketingUncheckedCreateInput>
  }

  /**
   * Ticketing createMany
   */
  export type TicketingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ticketings.
     */
    data: TicketingCreateManyInput | TicketingCreateManyInput[]
  }

  /**
   * Ticketing update
   */
  export type TicketingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * The data needed to update a Ticketing.
     */
    data: XOR<TicketingUpdateInput, TicketingUncheckedUpdateInput>
    /**
     * Choose, which Ticketing to update.
     */
    where: TicketingWhereUniqueInput
  }

  /**
   * Ticketing updateMany
   */
  export type TicketingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ticketings.
     */
    data: XOR<TicketingUpdateManyMutationInput, TicketingUncheckedUpdateManyInput>
    /**
     * Filter which Ticketings to update
     */
    where?: TicketingWhereInput
    /**
     * Limit how many Ticketings to update.
     */
    limit?: number
  }

  /**
   * Ticketing upsert
   */
  export type TicketingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * The filter to search for the Ticketing to update in case it exists.
     */
    where: TicketingWhereUniqueInput
    /**
     * In case the Ticketing found by the `where` argument doesn't exist, create a new Ticketing with this data.
     */
    create: XOR<TicketingCreateInput, TicketingUncheckedCreateInput>
    /**
     * In case the Ticketing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketingUpdateInput, TicketingUncheckedUpdateInput>
  }

  /**
   * Ticketing delete
   */
  export type TicketingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
    /**
     * Filter which Ticketing to delete.
     */
    where: TicketingWhereUniqueInput
  }

  /**
   * Ticketing deleteMany
   */
  export type TicketingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticketings to delete
     */
    where?: TicketingWhereInput
    /**
     * Limit how many Ticketings to delete.
     */
    limit?: number
  }

  /**
   * Ticketing findRaw
   */
  export type TicketingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ticketing aggregateRaw
   */
  export type TicketingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Ticketing without action
   */
  export type TicketingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticketing
     */
    select?: TicketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticketing
     */
    omit?: TicketingOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Field referred in an index, but found no data to define the type.
       */
      email: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model UtmData
   */

  export type AggregateUtmData = {
    _count: UtmDataCountAggregateOutputType | null
    _avg: UtmDataAvgAggregateOutputType | null
    _sum: UtmDataSumAggregateOutputType | null
    _min: UtmDataMinAggregateOutputType | null
    _max: UtmDataMaxAggregateOutputType | null
  }

  export type UtmDataAvgAggregateOutputType = {
    conversions: number | null
    visits: number | null
  }

  export type UtmDataSumAggregateOutputType = {
    conversions: bigint | null
    visits: bigint | null
  }

  export type UtmDataMinAggregateOutputType = {
    id: string | null
    campaign: string | null
    content: string | null
    conversions: bigint | null
    createdAt: Date | null
    medium: string | null
    name: string | null
    projectId: string | null
    source: string | null
    term: string | null
    updatedAt: Date | null
    visits: bigint | null
    websiteUrl: string | null
  }

  export type UtmDataMaxAggregateOutputType = {
    id: string | null
    campaign: string | null
    content: string | null
    conversions: bigint | null
    createdAt: Date | null
    medium: string | null
    name: string | null
    projectId: string | null
    source: string | null
    term: string | null
    updatedAt: Date | null
    visits: bigint | null
    websiteUrl: string | null
  }

  export type UtmDataCountAggregateOutputType = {
    id: number
    campaign: number
    content: number
    conversions: number
    createdAt: number
    medium: number
    name: number
    projectId: number
    source: number
    term: number
    updatedAt: number
    visits: number
    websiteUrl: number
    _all: number
  }


  export type UtmDataAvgAggregateInputType = {
    conversions?: true
    visits?: true
  }

  export type UtmDataSumAggregateInputType = {
    conversions?: true
    visits?: true
  }

  export type UtmDataMinAggregateInputType = {
    id?: true
    campaign?: true
    content?: true
    conversions?: true
    createdAt?: true
    medium?: true
    name?: true
    projectId?: true
    source?: true
    term?: true
    updatedAt?: true
    visits?: true
    websiteUrl?: true
  }

  export type UtmDataMaxAggregateInputType = {
    id?: true
    campaign?: true
    content?: true
    conversions?: true
    createdAt?: true
    medium?: true
    name?: true
    projectId?: true
    source?: true
    term?: true
    updatedAt?: true
    visits?: true
    websiteUrl?: true
  }

  export type UtmDataCountAggregateInputType = {
    id?: true
    campaign?: true
    content?: true
    conversions?: true
    createdAt?: true
    medium?: true
    name?: true
    projectId?: true
    source?: true
    term?: true
    updatedAt?: true
    visits?: true
    websiteUrl?: true
    _all?: true
  }

  export type UtmDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtmData to aggregate.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UtmData
    **/
    _count?: true | UtmDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtmDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtmDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtmDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtmDataMaxAggregateInputType
  }

  export type GetUtmDataAggregateType<T extends UtmDataAggregateArgs> = {
        [P in keyof T & keyof AggregateUtmData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtmData[P]>
      : GetScalarType<T[P], AggregateUtmData[P]>
  }




  export type UtmDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtmDataWhereInput
    orderBy?: UtmDataOrderByWithAggregationInput | UtmDataOrderByWithAggregationInput[]
    by: UtmDataScalarFieldEnum[] | UtmDataScalarFieldEnum
    having?: UtmDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtmDataCountAggregateInputType | true
    _avg?: UtmDataAvgAggregateInputType
    _sum?: UtmDataSumAggregateInputType
    _min?: UtmDataMinAggregateInputType
    _max?: UtmDataMaxAggregateInputType
  }

  export type UtmDataGroupByOutputType = {
    id: string
    campaign: string
    content: string
    conversions: bigint
    createdAt: Date
    medium: string
    name: string
    projectId: string
    source: string
    term: string
    updatedAt: Date
    visits: bigint
    websiteUrl: string
    _count: UtmDataCountAggregateOutputType | null
    _avg: UtmDataAvgAggregateOutputType | null
    _sum: UtmDataSumAggregateOutputType | null
    _min: UtmDataMinAggregateOutputType | null
    _max: UtmDataMaxAggregateOutputType | null
  }

  type GetUtmDataGroupByPayload<T extends UtmDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtmDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtmDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtmDataGroupByOutputType[P]>
            : GetScalarType<T[P], UtmDataGroupByOutputType[P]>
        }
      >
    >


  export type UtmDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign?: boolean
    content?: boolean
    conversions?: boolean
    createdAt?: boolean
    medium?: boolean
    name?: boolean
    projectId?: boolean
    source?: boolean
    term?: boolean
    updatedAt?: boolean
    visits?: boolean
    websiteUrl?: boolean
  }, ExtArgs["result"]["utmData"]>



  export type UtmDataSelectScalar = {
    id?: boolean
    campaign?: boolean
    content?: boolean
    conversions?: boolean
    createdAt?: boolean
    medium?: boolean
    name?: boolean
    projectId?: boolean
    source?: boolean
    term?: boolean
    updatedAt?: boolean
    visits?: boolean
    websiteUrl?: boolean
  }

  export type UtmDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaign" | "content" | "conversions" | "createdAt" | "medium" | "name" | "projectId" | "source" | "term" | "updatedAt" | "visits" | "websiteUrl", ExtArgs["result"]["utmData"]>

  export type $UtmDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UtmData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaign: string
      content: string
      conversions: bigint
      createdAt: Date
      medium: string
      name: string
      projectId: string
      source: string
      term: string
      updatedAt: Date
      visits: bigint
      websiteUrl: string
    }, ExtArgs["result"]["utmData"]>
    composites: {}
  }

  type UtmDataGetPayload<S extends boolean | null | undefined | UtmDataDefaultArgs> = $Result.GetResult<Prisma.$UtmDataPayload, S>

  type UtmDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtmDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtmDataCountAggregateInputType | true
    }

  export interface UtmDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UtmData'], meta: { name: 'UtmData' } }
    /**
     * Find zero or one UtmData that matches the filter.
     * @param {UtmDataFindUniqueArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtmDataFindUniqueArgs>(args: SelectSubset<T, UtmDataFindUniqueArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UtmData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtmDataFindUniqueOrThrowArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtmDataFindUniqueOrThrowArgs>(args: SelectSubset<T, UtmDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtmData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindFirstArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtmDataFindFirstArgs>(args?: SelectSubset<T, UtmDataFindFirstArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UtmData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindFirstOrThrowArgs} args - Arguments to find a UtmData
     * @example
     * // Get one UtmData
     * const utmData = await prisma.utmData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtmDataFindFirstOrThrowArgs>(args?: SelectSubset<T, UtmDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UtmData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UtmData
     * const utmData = await prisma.utmData.findMany()
     * 
     * // Get first 10 UtmData
     * const utmData = await prisma.utmData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utmDataWithIdOnly = await prisma.utmData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UtmDataFindManyArgs>(args?: SelectSubset<T, UtmDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UtmData.
     * @param {UtmDataCreateArgs} args - Arguments to create a UtmData.
     * @example
     * // Create one UtmData
     * const UtmData = await prisma.utmData.create({
     *   data: {
     *     // ... data to create a UtmData
     *   }
     * })
     * 
     */
    create<T extends UtmDataCreateArgs>(args: SelectSubset<T, UtmDataCreateArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UtmData.
     * @param {UtmDataCreateManyArgs} args - Arguments to create many UtmData.
     * @example
     * // Create many UtmData
     * const utmData = await prisma.utmData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtmDataCreateManyArgs>(args?: SelectSubset<T, UtmDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UtmData.
     * @param {UtmDataDeleteArgs} args - Arguments to delete one UtmData.
     * @example
     * // Delete one UtmData
     * const UtmData = await prisma.utmData.delete({
     *   where: {
     *     // ... filter to delete one UtmData
     *   }
     * })
     * 
     */
    delete<T extends UtmDataDeleteArgs>(args: SelectSubset<T, UtmDataDeleteArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UtmData.
     * @param {UtmDataUpdateArgs} args - Arguments to update one UtmData.
     * @example
     * // Update one UtmData
     * const utmData = await prisma.utmData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtmDataUpdateArgs>(args: SelectSubset<T, UtmDataUpdateArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UtmData.
     * @param {UtmDataDeleteManyArgs} args - Arguments to filter UtmData to delete.
     * @example
     * // Delete a few UtmData
     * const { count } = await prisma.utmData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtmDataDeleteManyArgs>(args?: SelectSubset<T, UtmDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UtmData
     * const utmData = await prisma.utmData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtmDataUpdateManyArgs>(args: SelectSubset<T, UtmDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UtmData.
     * @param {UtmDataUpsertArgs} args - Arguments to update or create a UtmData.
     * @example
     * // Update or create a UtmData
     * const utmData = await prisma.utmData.upsert({
     *   create: {
     *     // ... data to create a UtmData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UtmData we want to update
     *   }
     * })
     */
    upsert<T extends UtmDataUpsertArgs>(args: SelectSubset<T, UtmDataUpsertArgs<ExtArgs>>): Prisma__UtmDataClient<$Result.GetResult<Prisma.$UtmDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UtmData that matches the filter.
     * @param {UtmDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const utmData = await prisma.utmData.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UtmDataFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UtmData.
     * @param {UtmDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const utmData = await prisma.utmData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UtmDataAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataCountArgs} args - Arguments to filter UtmData to count.
     * @example
     * // Count the number of UtmData
     * const count = await prisma.utmData.count({
     *   where: {
     *     // ... the filter for the UtmData we want to count
     *   }
     * })
    **/
    count<T extends UtmDataCountArgs>(
      args?: Subset<T, UtmDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtmDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtmDataAggregateArgs>(args: Subset<T, UtmDataAggregateArgs>): Prisma.PrismaPromise<GetUtmDataAggregateType<T>>

    /**
     * Group by UtmData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtmDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtmDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtmDataGroupByArgs['orderBy'] }
        : { orderBy?: UtmDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtmDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtmDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UtmData model
   */
  readonly fields: UtmDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UtmData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtmDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UtmData model
   */
  interface UtmDataFieldRefs {
    readonly id: FieldRef<"UtmData", 'String'>
    readonly campaign: FieldRef<"UtmData", 'String'>
    readonly content: FieldRef<"UtmData", 'String'>
    readonly conversions: FieldRef<"UtmData", 'BigInt'>
    readonly createdAt: FieldRef<"UtmData", 'DateTime'>
    readonly medium: FieldRef<"UtmData", 'String'>
    readonly name: FieldRef<"UtmData", 'String'>
    readonly projectId: FieldRef<"UtmData", 'String'>
    readonly source: FieldRef<"UtmData", 'String'>
    readonly term: FieldRef<"UtmData", 'String'>
    readonly updatedAt: FieldRef<"UtmData", 'DateTime'>
    readonly visits: FieldRef<"UtmData", 'BigInt'>
    readonly websiteUrl: FieldRef<"UtmData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UtmData findUnique
   */
  export type UtmDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData findUniqueOrThrow
   */
  export type UtmDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData findFirst
   */
  export type UtmDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtmData.
     */
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData findFirstOrThrow
   */
  export type UtmDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UtmData.
     */
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData findMany
   */
  export type UtmDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter, which UtmData to fetch.
     */
    where?: UtmDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UtmData to fetch.
     */
    orderBy?: UtmDataOrderByWithRelationInput | UtmDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UtmData.
     */
    cursor?: UtmDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UtmData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UtmData.
     */
    skip?: number
    distinct?: UtmDataScalarFieldEnum | UtmDataScalarFieldEnum[]
  }

  /**
   * UtmData create
   */
  export type UtmDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * The data needed to create a UtmData.
     */
    data: XOR<UtmDataCreateInput, UtmDataUncheckedCreateInput>
  }

  /**
   * UtmData createMany
   */
  export type UtmDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UtmData.
     */
    data: UtmDataCreateManyInput | UtmDataCreateManyInput[]
  }

  /**
   * UtmData update
   */
  export type UtmDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * The data needed to update a UtmData.
     */
    data: XOR<UtmDataUpdateInput, UtmDataUncheckedUpdateInput>
    /**
     * Choose, which UtmData to update.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData updateMany
   */
  export type UtmDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UtmData.
     */
    data: XOR<UtmDataUpdateManyMutationInput, UtmDataUncheckedUpdateManyInput>
    /**
     * Filter which UtmData to update
     */
    where?: UtmDataWhereInput
    /**
     * Limit how many UtmData to update.
     */
    limit?: number
  }

  /**
   * UtmData upsert
   */
  export type UtmDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * The filter to search for the UtmData to update in case it exists.
     */
    where: UtmDataWhereUniqueInput
    /**
     * In case the UtmData found by the `where` argument doesn't exist, create a new UtmData with this data.
     */
    create: XOR<UtmDataCreateInput, UtmDataUncheckedCreateInput>
    /**
     * In case the UtmData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtmDataUpdateInput, UtmDataUncheckedUpdateInput>
  }

  /**
   * UtmData delete
   */
  export type UtmDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
    /**
     * Filter which UtmData to delete.
     */
    where: UtmDataWhereUniqueInput
  }

  /**
   * UtmData deleteMany
   */
  export type UtmDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UtmData to delete
     */
    where?: UtmDataWhereInput
    /**
     * Limit how many UtmData to delete.
     */
    limit?: number
  }

  /**
   * UtmData findRaw
   */
  export type UtmDataFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UtmData aggregateRaw
   */
  export type UtmDataAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UtmData without action
   */
  export type UtmDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtmData
     */
    select?: UtmDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UtmData
     */
    omit?: UtmDataOmit<ExtArgs> | null
  }


  /**
   * Model agendadays
   */

  export type AggregateAgendadays = {
    _count: AgendadaysCountAggregateOutputType | null
    _avg: AgendadaysAvgAggregateOutputType | null
    _sum: AgendadaysSumAggregateOutputType | null
    _min: AgendadaysMinAggregateOutputType | null
    _max: AgendadaysMaxAggregateOutputType | null
  }

  export type AgendadaysAvgAggregateOutputType = {
    v: number | null
    dayNumber: number | null
  }

  export type AgendadaysSumAggregateOutputType = {
    v: number | null
    dayNumber: number | null
  }

  export type AgendadaysMinAggregateOutputType = {
    id: string | null
    v: number | null
    date: Date | null
    dayNumber: number | null
    name: string | null
  }

  export type AgendadaysMaxAggregateOutputType = {
    id: string | null
    v: number | null
    date: Date | null
    dayNumber: number | null
    name: string | null
  }

  export type AgendadaysCountAggregateOutputType = {
    id: number
    v: number
    date: number
    dayNumber: number
    name: number
    _all: number
  }


  export type AgendadaysAvgAggregateInputType = {
    v?: true
    dayNumber?: true
  }

  export type AgendadaysSumAggregateInputType = {
    v?: true
    dayNumber?: true
  }

  export type AgendadaysMinAggregateInputType = {
    id?: true
    v?: true
    date?: true
    dayNumber?: true
    name?: true
  }

  export type AgendadaysMaxAggregateInputType = {
    id?: true
    v?: true
    date?: true
    dayNumber?: true
    name?: true
  }

  export type AgendadaysCountAggregateInputType = {
    id?: true
    v?: true
    date?: true
    dayNumber?: true
    name?: true
    _all?: true
  }

  export type AgendadaysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendadays to aggregate.
     */
    where?: agendadaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendadays to fetch.
     */
    orderBy?: agendadaysOrderByWithRelationInput | agendadaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agendadaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendadays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendadays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agendadays
    **/
    _count?: true | AgendadaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgendadaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgendadaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendadaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendadaysMaxAggregateInputType
  }

  export type GetAgendadaysAggregateType<T extends AgendadaysAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendadays]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendadays[P]>
      : GetScalarType<T[P], AggregateAgendadays[P]>
  }




  export type agendadaysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendadaysWhereInput
    orderBy?: agendadaysOrderByWithAggregationInput | agendadaysOrderByWithAggregationInput[]
    by: AgendadaysScalarFieldEnum[] | AgendadaysScalarFieldEnum
    having?: agendadaysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendadaysCountAggregateInputType | true
    _avg?: AgendadaysAvgAggregateInputType
    _sum?: AgendadaysSumAggregateInputType
    _min?: AgendadaysMinAggregateInputType
    _max?: AgendadaysMaxAggregateInputType
  }

  export type AgendadaysGroupByOutputType = {
    id: string
    v: number
    date: Date
    dayNumber: number
    name: string
    _count: AgendadaysCountAggregateOutputType | null
    _avg: AgendadaysAvgAggregateOutputType | null
    _sum: AgendadaysSumAggregateOutputType | null
    _min: AgendadaysMinAggregateOutputType | null
    _max: AgendadaysMaxAggregateOutputType | null
  }

  type GetAgendadaysGroupByPayload<T extends agendadaysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendadaysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendadaysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendadaysGroupByOutputType[P]>
            : GetScalarType<T[P], AgendadaysGroupByOutputType[P]>
        }
      >
    >


  export type agendadaysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    v?: boolean
    date?: boolean
    dayNumber?: boolean
    name?: boolean
  }, ExtArgs["result"]["agendadays"]>



  export type agendadaysSelectScalar = {
    id?: boolean
    v?: boolean
    date?: boolean
    dayNumber?: boolean
    name?: boolean
  }

  export type agendadaysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "v" | "date" | "dayNumber" | "name", ExtArgs["result"]["agendadays"]>

  export type $agendadaysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agendadays"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      v: number
      date: Date
      dayNumber: number
      name: string
    }, ExtArgs["result"]["agendadays"]>
    composites: {}
  }

  type agendadaysGetPayload<S extends boolean | null | undefined | agendadaysDefaultArgs> = $Result.GetResult<Prisma.$agendadaysPayload, S>

  type agendadaysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agendadaysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendadaysCountAggregateInputType | true
    }

  export interface agendadaysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agendadays'], meta: { name: 'agendadays' } }
    /**
     * Find zero or one Agendadays that matches the filter.
     * @param {agendadaysFindUniqueArgs} args - Arguments to find a Agendadays
     * @example
     * // Get one Agendadays
     * const agendadays = await prisma.agendadays.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agendadaysFindUniqueArgs>(args: SelectSubset<T, agendadaysFindUniqueArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agendadays that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agendadaysFindUniqueOrThrowArgs} args - Arguments to find a Agendadays
     * @example
     * // Get one Agendadays
     * const agendadays = await prisma.agendadays.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agendadaysFindUniqueOrThrowArgs>(args: SelectSubset<T, agendadaysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendadays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysFindFirstArgs} args - Arguments to find a Agendadays
     * @example
     * // Get one Agendadays
     * const agendadays = await prisma.agendadays.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agendadaysFindFirstArgs>(args?: SelectSubset<T, agendadaysFindFirstArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendadays that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysFindFirstOrThrowArgs} args - Arguments to find a Agendadays
     * @example
     * // Get one Agendadays
     * const agendadays = await prisma.agendadays.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agendadaysFindFirstOrThrowArgs>(args?: SelectSubset<T, agendadaysFindFirstOrThrowArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendadays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendadays
     * const agendadays = await prisma.agendadays.findMany()
     * 
     * // Get first 10 Agendadays
     * const agendadays = await prisma.agendadays.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendadaysWithIdOnly = await prisma.agendadays.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agendadaysFindManyArgs>(args?: SelectSubset<T, agendadaysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agendadays.
     * @param {agendadaysCreateArgs} args - Arguments to create a Agendadays.
     * @example
     * // Create one Agendadays
     * const Agendadays = await prisma.agendadays.create({
     *   data: {
     *     // ... data to create a Agendadays
     *   }
     * })
     * 
     */
    create<T extends agendadaysCreateArgs>(args: SelectSubset<T, agendadaysCreateArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agendadays.
     * @param {agendadaysCreateManyArgs} args - Arguments to create many Agendadays.
     * @example
     * // Create many Agendadays
     * const agendadays = await prisma.agendadays.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agendadaysCreateManyArgs>(args?: SelectSubset<T, agendadaysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agendadays.
     * @param {agendadaysDeleteArgs} args - Arguments to delete one Agendadays.
     * @example
     * // Delete one Agendadays
     * const Agendadays = await prisma.agendadays.delete({
     *   where: {
     *     // ... filter to delete one Agendadays
     *   }
     * })
     * 
     */
    delete<T extends agendadaysDeleteArgs>(args: SelectSubset<T, agendadaysDeleteArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agendadays.
     * @param {agendadaysUpdateArgs} args - Arguments to update one Agendadays.
     * @example
     * // Update one Agendadays
     * const agendadays = await prisma.agendadays.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agendadaysUpdateArgs>(args: SelectSubset<T, agendadaysUpdateArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agendadays.
     * @param {agendadaysDeleteManyArgs} args - Arguments to filter Agendadays to delete.
     * @example
     * // Delete a few Agendadays
     * const { count } = await prisma.agendadays.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agendadaysDeleteManyArgs>(args?: SelectSubset<T, agendadaysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendadays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendadays
     * const agendadays = await prisma.agendadays.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agendadaysUpdateManyArgs>(args: SelectSubset<T, agendadaysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agendadays.
     * @param {agendadaysUpsertArgs} args - Arguments to update or create a Agendadays.
     * @example
     * // Update or create a Agendadays
     * const agendadays = await prisma.agendadays.upsert({
     *   create: {
     *     // ... data to create a Agendadays
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendadays we want to update
     *   }
     * })
     */
    upsert<T extends agendadaysUpsertArgs>(args: SelectSubset<T, agendadaysUpsertArgs<ExtArgs>>): Prisma__agendadaysClient<$Result.GetResult<Prisma.$agendadaysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendadays that matches the filter.
     * @param {agendadaysFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendadays = await prisma.agendadays.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: agendadaysFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agendadays.
     * @param {agendadaysAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendadays = await prisma.agendadays.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: agendadaysAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agendadays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysCountArgs} args - Arguments to filter Agendadays to count.
     * @example
     * // Count the number of Agendadays
     * const count = await prisma.agendadays.count({
     *   where: {
     *     // ... the filter for the Agendadays we want to count
     *   }
     * })
    **/
    count<T extends agendadaysCountArgs>(
      args?: Subset<T, agendadaysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendadaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendadays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendadaysAggregateArgs>(args: Subset<T, AgendadaysAggregateArgs>): Prisma.PrismaPromise<GetAgendadaysAggregateType<T>>

    /**
     * Group by Agendadays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendadaysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agendadaysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agendadaysGroupByArgs['orderBy'] }
        : { orderBy?: agendadaysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agendadaysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendadaysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agendadays model
   */
  readonly fields: agendadaysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agendadays.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agendadaysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agendadays model
   */
  interface agendadaysFieldRefs {
    readonly id: FieldRef<"agendadays", 'String'>
    readonly v: FieldRef<"agendadays", 'Int'>
    readonly date: FieldRef<"agendadays", 'DateTime'>
    readonly dayNumber: FieldRef<"agendadays", 'Int'>
    readonly name: FieldRef<"agendadays", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agendadays findUnique
   */
  export type agendadaysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter, which agendadays to fetch.
     */
    where: agendadaysWhereUniqueInput
  }

  /**
   * agendadays findUniqueOrThrow
   */
  export type agendadaysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter, which agendadays to fetch.
     */
    where: agendadaysWhereUniqueInput
  }

  /**
   * agendadays findFirst
   */
  export type agendadaysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter, which agendadays to fetch.
     */
    where?: agendadaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendadays to fetch.
     */
    orderBy?: agendadaysOrderByWithRelationInput | agendadaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendadays.
     */
    cursor?: agendadaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendadays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendadays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendadays.
     */
    distinct?: AgendadaysScalarFieldEnum | AgendadaysScalarFieldEnum[]
  }

  /**
   * agendadays findFirstOrThrow
   */
  export type agendadaysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter, which agendadays to fetch.
     */
    where?: agendadaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendadays to fetch.
     */
    orderBy?: agendadaysOrderByWithRelationInput | agendadaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendadays.
     */
    cursor?: agendadaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendadays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendadays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendadays.
     */
    distinct?: AgendadaysScalarFieldEnum | AgendadaysScalarFieldEnum[]
  }

  /**
   * agendadays findMany
   */
  export type agendadaysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter, which agendadays to fetch.
     */
    where?: agendadaysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendadays to fetch.
     */
    orderBy?: agendadaysOrderByWithRelationInput | agendadaysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agendadays.
     */
    cursor?: agendadaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendadays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendadays.
     */
    skip?: number
    distinct?: AgendadaysScalarFieldEnum | AgendadaysScalarFieldEnum[]
  }

  /**
   * agendadays create
   */
  export type agendadaysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * The data needed to create a agendadays.
     */
    data: XOR<agendadaysCreateInput, agendadaysUncheckedCreateInput>
  }

  /**
   * agendadays createMany
   */
  export type agendadaysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agendadays.
     */
    data: agendadaysCreateManyInput | agendadaysCreateManyInput[]
  }

  /**
   * agendadays update
   */
  export type agendadaysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * The data needed to update a agendadays.
     */
    data: XOR<agendadaysUpdateInput, agendadaysUncheckedUpdateInput>
    /**
     * Choose, which agendadays to update.
     */
    where: agendadaysWhereUniqueInput
  }

  /**
   * agendadays updateMany
   */
  export type agendadaysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agendadays.
     */
    data: XOR<agendadaysUpdateManyMutationInput, agendadaysUncheckedUpdateManyInput>
    /**
     * Filter which agendadays to update
     */
    where?: agendadaysWhereInput
    /**
     * Limit how many agendadays to update.
     */
    limit?: number
  }

  /**
   * agendadays upsert
   */
  export type agendadaysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * The filter to search for the agendadays to update in case it exists.
     */
    where: agendadaysWhereUniqueInput
    /**
     * In case the agendadays found by the `where` argument doesn't exist, create a new agendadays with this data.
     */
    create: XOR<agendadaysCreateInput, agendadaysUncheckedCreateInput>
    /**
     * In case the agendadays was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agendadaysUpdateInput, agendadaysUncheckedUpdateInput>
  }

  /**
   * agendadays delete
   */
  export type agendadaysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
    /**
     * Filter which agendadays to delete.
     */
    where: agendadaysWhereUniqueInput
  }

  /**
   * agendadays deleteMany
   */
  export type agendadaysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendadays to delete
     */
    where?: agendadaysWhereInput
    /**
     * Limit how many agendadays to delete.
     */
    limit?: number
  }

  /**
   * agendadays findRaw
   */
  export type agendadaysFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendadays aggregateRaw
   */
  export type agendadaysAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendadays without action
   */
  export type agendadaysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendadays
     */
    select?: agendadaysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendadays
     */
    omit?: agendadaysOmit<ExtArgs> | null
  }


  /**
   * Model agendaitems
   */

  export type AggregateAgendaitems = {
    _count: AgendaitemsCountAggregateOutputType | null
    _min: AgendaitemsMinAggregateOutputType | null
    _max: AgendaitemsMaxAggregateOutputType | null
  }

  export type AgendaitemsMinAggregateOutputType = {
    id: string | null
  }

  export type AgendaitemsMaxAggregateOutputType = {
    id: string | null
  }

  export type AgendaitemsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AgendaitemsMinAggregateInputType = {
    id?: true
  }

  export type AgendaitemsMaxAggregateInputType = {
    id?: true
  }

  export type AgendaitemsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AgendaitemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendaitems to aggregate.
     */
    where?: agendaitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitems to fetch.
     */
    orderBy?: agendaitemsOrderByWithRelationInput | agendaitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agendaitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agendaitems
    **/
    _count?: true | AgendaitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaitemsMaxAggregateInputType
  }

  export type GetAgendaitemsAggregateType<T extends AgendaitemsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaitems[P]>
      : GetScalarType<T[P], AggregateAgendaitems[P]>
  }




  export type agendaitemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendaitemsWhereInput
    orderBy?: agendaitemsOrderByWithAggregationInput | agendaitemsOrderByWithAggregationInput[]
    by: AgendaitemsScalarFieldEnum[] | AgendaitemsScalarFieldEnum
    having?: agendaitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaitemsCountAggregateInputType | true
    _min?: AgendaitemsMinAggregateInputType
    _max?: AgendaitemsMaxAggregateInputType
  }

  export type AgendaitemsGroupByOutputType = {
    id: string
    _count: AgendaitemsCountAggregateOutputType | null
    _min: AgendaitemsMinAggregateOutputType | null
    _max: AgendaitemsMaxAggregateOutputType | null
  }

  type GetAgendaitemsGroupByPayload<T extends agendaitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaitemsGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaitemsGroupByOutputType[P]>
        }
      >
    >


  export type agendaitemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["agendaitems"]>



  export type agendaitemsSelectScalar = {
    id?: boolean
  }

  export type agendaitemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["agendaitems"]>

  export type $agendaitemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agendaitems"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["agendaitems"]>
    composites: {}
  }

  type agendaitemsGetPayload<S extends boolean | null | undefined | agendaitemsDefaultArgs> = $Result.GetResult<Prisma.$agendaitemsPayload, S>

  type agendaitemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agendaitemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaitemsCountAggregateInputType | true
    }

  export interface agendaitemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agendaitems'], meta: { name: 'agendaitems' } }
    /**
     * Find zero or one Agendaitems that matches the filter.
     * @param {agendaitemsFindUniqueArgs} args - Arguments to find a Agendaitems
     * @example
     * // Get one Agendaitems
     * const agendaitems = await prisma.agendaitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agendaitemsFindUniqueArgs>(args: SelectSubset<T, agendaitemsFindUniqueArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agendaitems that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agendaitemsFindUniqueOrThrowArgs} args - Arguments to find a Agendaitems
     * @example
     * // Get one Agendaitems
     * const agendaitems = await prisma.agendaitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agendaitemsFindUniqueOrThrowArgs>(args: SelectSubset<T, agendaitemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendaitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsFindFirstArgs} args - Arguments to find a Agendaitems
     * @example
     * // Get one Agendaitems
     * const agendaitems = await prisma.agendaitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agendaitemsFindFirstArgs>(args?: SelectSubset<T, agendaitemsFindFirstArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendaitems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsFindFirstOrThrowArgs} args - Arguments to find a Agendaitems
     * @example
     * // Get one Agendaitems
     * const agendaitems = await prisma.agendaitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agendaitemsFindFirstOrThrowArgs>(args?: SelectSubset<T, agendaitemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendaitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendaitems
     * const agendaitems = await prisma.agendaitems.findMany()
     * 
     * // Get first 10 Agendaitems
     * const agendaitems = await prisma.agendaitems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaitemsWithIdOnly = await prisma.agendaitems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agendaitemsFindManyArgs>(args?: SelectSubset<T, agendaitemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agendaitems.
     * @param {agendaitemsCreateArgs} args - Arguments to create a Agendaitems.
     * @example
     * // Create one Agendaitems
     * const Agendaitems = await prisma.agendaitems.create({
     *   data: {
     *     // ... data to create a Agendaitems
     *   }
     * })
     * 
     */
    create<T extends agendaitemsCreateArgs>(args: SelectSubset<T, agendaitemsCreateArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agendaitems.
     * @param {agendaitemsCreateManyArgs} args - Arguments to create many Agendaitems.
     * @example
     * // Create many Agendaitems
     * const agendaitems = await prisma.agendaitems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agendaitemsCreateManyArgs>(args?: SelectSubset<T, agendaitemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agendaitems.
     * @param {agendaitemsDeleteArgs} args - Arguments to delete one Agendaitems.
     * @example
     * // Delete one Agendaitems
     * const Agendaitems = await prisma.agendaitems.delete({
     *   where: {
     *     // ... filter to delete one Agendaitems
     *   }
     * })
     * 
     */
    delete<T extends agendaitemsDeleteArgs>(args: SelectSubset<T, agendaitemsDeleteArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agendaitems.
     * @param {agendaitemsUpdateArgs} args - Arguments to update one Agendaitems.
     * @example
     * // Update one Agendaitems
     * const agendaitems = await prisma.agendaitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agendaitemsUpdateArgs>(args: SelectSubset<T, agendaitemsUpdateArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agendaitems.
     * @param {agendaitemsDeleteManyArgs} args - Arguments to filter Agendaitems to delete.
     * @example
     * // Delete a few Agendaitems
     * const { count } = await prisma.agendaitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agendaitemsDeleteManyArgs>(args?: SelectSubset<T, agendaitemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendaitems
     * const agendaitems = await prisma.agendaitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agendaitemsUpdateManyArgs>(args: SelectSubset<T, agendaitemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agendaitems.
     * @param {agendaitemsUpsertArgs} args - Arguments to update or create a Agendaitems.
     * @example
     * // Update or create a Agendaitems
     * const agendaitems = await prisma.agendaitems.upsert({
     *   create: {
     *     // ... data to create a Agendaitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendaitems we want to update
     *   }
     * })
     */
    upsert<T extends agendaitemsUpsertArgs>(args: SelectSubset<T, agendaitemsUpsertArgs<ExtArgs>>): Prisma__agendaitemsClient<$Result.GetResult<Prisma.$agendaitemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendaitems that matches the filter.
     * @param {agendaitemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaitems = await prisma.agendaitems.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: agendaitemsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agendaitems.
     * @param {agendaitemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaitems = await prisma.agendaitems.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: agendaitemsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agendaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsCountArgs} args - Arguments to filter Agendaitems to count.
     * @example
     * // Count the number of Agendaitems
     * const count = await prisma.agendaitems.count({
     *   where: {
     *     // ... the filter for the Agendaitems we want to count
     *   }
     * })
    **/
    count<T extends agendaitemsCountArgs>(
      args?: Subset<T, agendaitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaitemsAggregateArgs>(args: Subset<T, AgendaitemsAggregateArgs>): Prisma.PrismaPromise<GetAgendaitemsAggregateType<T>>

    /**
     * Group by Agendaitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agendaitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agendaitemsGroupByArgs['orderBy'] }
        : { orderBy?: agendaitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agendaitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agendaitems model
   */
  readonly fields: agendaitemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agendaitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agendaitemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agendaitems model
   */
  interface agendaitemsFieldRefs {
    readonly id: FieldRef<"agendaitems", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agendaitems findUnique
   */
  export type agendaitemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter, which agendaitems to fetch.
     */
    where: agendaitemsWhereUniqueInput
  }

  /**
   * agendaitems findUniqueOrThrow
   */
  export type agendaitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter, which agendaitems to fetch.
     */
    where: agendaitemsWhereUniqueInput
  }

  /**
   * agendaitems findFirst
   */
  export type agendaitemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter, which agendaitems to fetch.
     */
    where?: agendaitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitems to fetch.
     */
    orderBy?: agendaitemsOrderByWithRelationInput | agendaitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendaitems.
     */
    cursor?: agendaitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendaitems.
     */
    distinct?: AgendaitemsScalarFieldEnum | AgendaitemsScalarFieldEnum[]
  }

  /**
   * agendaitems findFirstOrThrow
   */
  export type agendaitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter, which agendaitems to fetch.
     */
    where?: agendaitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitems to fetch.
     */
    orderBy?: agendaitemsOrderByWithRelationInput | agendaitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendaitems.
     */
    cursor?: agendaitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendaitems.
     */
    distinct?: AgendaitemsScalarFieldEnum | AgendaitemsScalarFieldEnum[]
  }

  /**
   * agendaitems findMany
   */
  export type agendaitemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter, which agendaitems to fetch.
     */
    where?: agendaitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitems to fetch.
     */
    orderBy?: agendaitemsOrderByWithRelationInput | agendaitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agendaitems.
     */
    cursor?: agendaitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitems.
     */
    skip?: number
    distinct?: AgendaitemsScalarFieldEnum | AgendaitemsScalarFieldEnum[]
  }

  /**
   * agendaitems create
   */
  export type agendaitemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * The data needed to create a agendaitems.
     */
    data?: XOR<agendaitemsCreateInput, agendaitemsUncheckedCreateInput>
  }

  /**
   * agendaitems createMany
   */
  export type agendaitemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agendaitems.
     */
    data: agendaitemsCreateManyInput | agendaitemsCreateManyInput[]
  }

  /**
   * agendaitems update
   */
  export type agendaitemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * The data needed to update a agendaitems.
     */
    data: XOR<agendaitemsUpdateInput, agendaitemsUncheckedUpdateInput>
    /**
     * Choose, which agendaitems to update.
     */
    where: agendaitemsWhereUniqueInput
  }

  /**
   * agendaitems updateMany
   */
  export type agendaitemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agendaitems.
     */
    data: XOR<agendaitemsUpdateManyMutationInput, agendaitemsUncheckedUpdateManyInput>
    /**
     * Filter which agendaitems to update
     */
    where?: agendaitemsWhereInput
    /**
     * Limit how many agendaitems to update.
     */
    limit?: number
  }

  /**
   * agendaitems upsert
   */
  export type agendaitemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * The filter to search for the agendaitems to update in case it exists.
     */
    where: agendaitemsWhereUniqueInput
    /**
     * In case the agendaitems found by the `where` argument doesn't exist, create a new agendaitems with this data.
     */
    create: XOR<agendaitemsCreateInput, agendaitemsUncheckedCreateInput>
    /**
     * In case the agendaitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agendaitemsUpdateInput, agendaitemsUncheckedUpdateInput>
  }

  /**
   * agendaitems delete
   */
  export type agendaitemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
    /**
     * Filter which agendaitems to delete.
     */
    where: agendaitemsWhereUniqueInput
  }

  /**
   * agendaitems deleteMany
   */
  export type agendaitemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendaitems to delete
     */
    where?: agendaitemsWhereInput
    /**
     * Limit how many agendaitems to delete.
     */
    limit?: number
  }

  /**
   * agendaitems findRaw
   */
  export type agendaitemsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendaitems aggregateRaw
   */
  export type agendaitemsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendaitems without action
   */
  export type agendaitemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitems
     */
    select?: agendaitemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitems
     */
    omit?: agendaitemsOmit<ExtArgs> | null
  }


  /**
   * Model agendaitemspeakers
   */

  export type AggregateAgendaitemspeakers = {
    _count: AgendaitemspeakersCountAggregateOutputType | null
    _min: AgendaitemspeakersMinAggregateOutputType | null
    _max: AgendaitemspeakersMaxAggregateOutputType | null
  }

  export type AgendaitemspeakersMinAggregateOutputType = {
    id: string | null
  }

  export type AgendaitemspeakersMaxAggregateOutputType = {
    id: string | null
  }

  export type AgendaitemspeakersCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AgendaitemspeakersMinAggregateInputType = {
    id?: true
  }

  export type AgendaitemspeakersMaxAggregateInputType = {
    id?: true
  }

  export type AgendaitemspeakersCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AgendaitemspeakersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendaitemspeakers to aggregate.
     */
    where?: agendaitemspeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitemspeakers to fetch.
     */
    orderBy?: agendaitemspeakersOrderByWithRelationInput | agendaitemspeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agendaitemspeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitemspeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitemspeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agendaitemspeakers
    **/
    _count?: true | AgendaitemspeakersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaitemspeakersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaitemspeakersMaxAggregateInputType
  }

  export type GetAgendaitemspeakersAggregateType<T extends AgendaitemspeakersAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaitemspeakers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaitemspeakers[P]>
      : GetScalarType<T[P], AggregateAgendaitemspeakers[P]>
  }




  export type agendaitemspeakersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendaitemspeakersWhereInput
    orderBy?: agendaitemspeakersOrderByWithAggregationInput | agendaitemspeakersOrderByWithAggregationInput[]
    by: AgendaitemspeakersScalarFieldEnum[] | AgendaitemspeakersScalarFieldEnum
    having?: agendaitemspeakersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaitemspeakersCountAggregateInputType | true
    _min?: AgendaitemspeakersMinAggregateInputType
    _max?: AgendaitemspeakersMaxAggregateInputType
  }

  export type AgendaitemspeakersGroupByOutputType = {
    id: string
    _count: AgendaitemspeakersCountAggregateOutputType | null
    _min: AgendaitemspeakersMinAggregateOutputType | null
    _max: AgendaitemspeakersMaxAggregateOutputType | null
  }

  type GetAgendaitemspeakersGroupByPayload<T extends agendaitemspeakersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendaitemspeakersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaitemspeakersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaitemspeakersGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaitemspeakersGroupByOutputType[P]>
        }
      >
    >


  export type agendaitemspeakersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["agendaitemspeakers"]>



  export type agendaitemspeakersSelectScalar = {
    id?: boolean
  }

  export type agendaitemspeakersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["agendaitemspeakers"]>

  export type $agendaitemspeakersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agendaitemspeakers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["agendaitemspeakers"]>
    composites: {}
  }

  type agendaitemspeakersGetPayload<S extends boolean | null | undefined | agendaitemspeakersDefaultArgs> = $Result.GetResult<Prisma.$agendaitemspeakersPayload, S>

  type agendaitemspeakersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agendaitemspeakersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendaitemspeakersCountAggregateInputType | true
    }

  export interface agendaitemspeakersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agendaitemspeakers'], meta: { name: 'agendaitemspeakers' } }
    /**
     * Find zero or one Agendaitemspeakers that matches the filter.
     * @param {agendaitemspeakersFindUniqueArgs} args - Arguments to find a Agendaitemspeakers
     * @example
     * // Get one Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agendaitemspeakersFindUniqueArgs>(args: SelectSubset<T, agendaitemspeakersFindUniqueArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agendaitemspeakers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agendaitemspeakersFindUniqueOrThrowArgs} args - Arguments to find a Agendaitemspeakers
     * @example
     * // Get one Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agendaitemspeakersFindUniqueOrThrowArgs>(args: SelectSubset<T, agendaitemspeakersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendaitemspeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersFindFirstArgs} args - Arguments to find a Agendaitemspeakers
     * @example
     * // Get one Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agendaitemspeakersFindFirstArgs>(args?: SelectSubset<T, agendaitemspeakersFindFirstArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendaitemspeakers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersFindFirstOrThrowArgs} args - Arguments to find a Agendaitemspeakers
     * @example
     * // Get one Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agendaitemspeakersFindFirstOrThrowArgs>(args?: SelectSubset<T, agendaitemspeakersFindFirstOrThrowArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendaitemspeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findMany()
     * 
     * // Get first 10 Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaitemspeakersWithIdOnly = await prisma.agendaitemspeakers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agendaitemspeakersFindManyArgs>(args?: SelectSubset<T, agendaitemspeakersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agendaitemspeakers.
     * @param {agendaitemspeakersCreateArgs} args - Arguments to create a Agendaitemspeakers.
     * @example
     * // Create one Agendaitemspeakers
     * const Agendaitemspeakers = await prisma.agendaitemspeakers.create({
     *   data: {
     *     // ... data to create a Agendaitemspeakers
     *   }
     * })
     * 
     */
    create<T extends agendaitemspeakersCreateArgs>(args: SelectSubset<T, agendaitemspeakersCreateArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agendaitemspeakers.
     * @param {agendaitemspeakersCreateManyArgs} args - Arguments to create many Agendaitemspeakers.
     * @example
     * // Create many Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agendaitemspeakersCreateManyArgs>(args?: SelectSubset<T, agendaitemspeakersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agendaitemspeakers.
     * @param {agendaitemspeakersDeleteArgs} args - Arguments to delete one Agendaitemspeakers.
     * @example
     * // Delete one Agendaitemspeakers
     * const Agendaitemspeakers = await prisma.agendaitemspeakers.delete({
     *   where: {
     *     // ... filter to delete one Agendaitemspeakers
     *   }
     * })
     * 
     */
    delete<T extends agendaitemspeakersDeleteArgs>(args: SelectSubset<T, agendaitemspeakersDeleteArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agendaitemspeakers.
     * @param {agendaitemspeakersUpdateArgs} args - Arguments to update one Agendaitemspeakers.
     * @example
     * // Update one Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agendaitemspeakersUpdateArgs>(args: SelectSubset<T, agendaitemspeakersUpdateArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agendaitemspeakers.
     * @param {agendaitemspeakersDeleteManyArgs} args - Arguments to filter Agendaitemspeakers to delete.
     * @example
     * // Delete a few Agendaitemspeakers
     * const { count } = await prisma.agendaitemspeakers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agendaitemspeakersDeleteManyArgs>(args?: SelectSubset<T, agendaitemspeakersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendaitemspeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agendaitemspeakersUpdateManyArgs>(args: SelectSubset<T, agendaitemspeakersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agendaitemspeakers.
     * @param {agendaitemspeakersUpsertArgs} args - Arguments to update or create a Agendaitemspeakers.
     * @example
     * // Update or create a Agendaitemspeakers
     * const agendaitemspeakers = await prisma.agendaitemspeakers.upsert({
     *   create: {
     *     // ... data to create a Agendaitemspeakers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendaitemspeakers we want to update
     *   }
     * })
     */
    upsert<T extends agendaitemspeakersUpsertArgs>(args: SelectSubset<T, agendaitemspeakersUpsertArgs<ExtArgs>>): Prisma__agendaitemspeakersClient<$Result.GetResult<Prisma.$agendaitemspeakersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendaitemspeakers that matches the filter.
     * @param {agendaitemspeakersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendaitemspeakers = await prisma.agendaitemspeakers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: agendaitemspeakersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agendaitemspeakers.
     * @param {agendaitemspeakersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendaitemspeakers = await prisma.agendaitemspeakers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: agendaitemspeakersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agendaitemspeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersCountArgs} args - Arguments to filter Agendaitemspeakers to count.
     * @example
     * // Count the number of Agendaitemspeakers
     * const count = await prisma.agendaitemspeakers.count({
     *   where: {
     *     // ... the filter for the Agendaitemspeakers we want to count
     *   }
     * })
    **/
    count<T extends agendaitemspeakersCountArgs>(
      args?: Subset<T, agendaitemspeakersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaitemspeakersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendaitemspeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaitemspeakersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaitemspeakersAggregateArgs>(args: Subset<T, AgendaitemspeakersAggregateArgs>): Prisma.PrismaPromise<GetAgendaitemspeakersAggregateType<T>>

    /**
     * Group by Agendaitemspeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendaitemspeakersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agendaitemspeakersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agendaitemspeakersGroupByArgs['orderBy'] }
        : { orderBy?: agendaitemspeakersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agendaitemspeakersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaitemspeakersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agendaitemspeakers model
   */
  readonly fields: agendaitemspeakersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agendaitemspeakers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agendaitemspeakersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agendaitemspeakers model
   */
  interface agendaitemspeakersFieldRefs {
    readonly id: FieldRef<"agendaitemspeakers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agendaitemspeakers findUnique
   */
  export type agendaitemspeakersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter, which agendaitemspeakers to fetch.
     */
    where: agendaitemspeakersWhereUniqueInput
  }

  /**
   * agendaitemspeakers findUniqueOrThrow
   */
  export type agendaitemspeakersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter, which agendaitemspeakers to fetch.
     */
    where: agendaitemspeakersWhereUniqueInput
  }

  /**
   * agendaitemspeakers findFirst
   */
  export type agendaitemspeakersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter, which agendaitemspeakers to fetch.
     */
    where?: agendaitemspeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitemspeakers to fetch.
     */
    orderBy?: agendaitemspeakersOrderByWithRelationInput | agendaitemspeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendaitemspeakers.
     */
    cursor?: agendaitemspeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitemspeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitemspeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendaitemspeakers.
     */
    distinct?: AgendaitemspeakersScalarFieldEnum | AgendaitemspeakersScalarFieldEnum[]
  }

  /**
   * agendaitemspeakers findFirstOrThrow
   */
  export type agendaitemspeakersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter, which agendaitemspeakers to fetch.
     */
    where?: agendaitemspeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitemspeakers to fetch.
     */
    orderBy?: agendaitemspeakersOrderByWithRelationInput | agendaitemspeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendaitemspeakers.
     */
    cursor?: agendaitemspeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitemspeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitemspeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendaitemspeakers.
     */
    distinct?: AgendaitemspeakersScalarFieldEnum | AgendaitemspeakersScalarFieldEnum[]
  }

  /**
   * agendaitemspeakers findMany
   */
  export type agendaitemspeakersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter, which agendaitemspeakers to fetch.
     */
    where?: agendaitemspeakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendaitemspeakers to fetch.
     */
    orderBy?: agendaitemspeakersOrderByWithRelationInput | agendaitemspeakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agendaitemspeakers.
     */
    cursor?: agendaitemspeakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendaitemspeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendaitemspeakers.
     */
    skip?: number
    distinct?: AgendaitemspeakersScalarFieldEnum | AgendaitemspeakersScalarFieldEnum[]
  }

  /**
   * agendaitemspeakers create
   */
  export type agendaitemspeakersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * The data needed to create a agendaitemspeakers.
     */
    data?: XOR<agendaitemspeakersCreateInput, agendaitemspeakersUncheckedCreateInput>
  }

  /**
   * agendaitemspeakers createMany
   */
  export type agendaitemspeakersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agendaitemspeakers.
     */
    data: agendaitemspeakersCreateManyInput | agendaitemspeakersCreateManyInput[]
  }

  /**
   * agendaitemspeakers update
   */
  export type agendaitemspeakersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * The data needed to update a agendaitemspeakers.
     */
    data: XOR<agendaitemspeakersUpdateInput, agendaitemspeakersUncheckedUpdateInput>
    /**
     * Choose, which agendaitemspeakers to update.
     */
    where: agendaitemspeakersWhereUniqueInput
  }

  /**
   * agendaitemspeakers updateMany
   */
  export type agendaitemspeakersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agendaitemspeakers.
     */
    data: XOR<agendaitemspeakersUpdateManyMutationInput, agendaitemspeakersUncheckedUpdateManyInput>
    /**
     * Filter which agendaitemspeakers to update
     */
    where?: agendaitemspeakersWhereInput
    /**
     * Limit how many agendaitemspeakers to update.
     */
    limit?: number
  }

  /**
   * agendaitemspeakers upsert
   */
  export type agendaitemspeakersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * The filter to search for the agendaitemspeakers to update in case it exists.
     */
    where: agendaitemspeakersWhereUniqueInput
    /**
     * In case the agendaitemspeakers found by the `where` argument doesn't exist, create a new agendaitemspeakers with this data.
     */
    create: XOR<agendaitemspeakersCreateInput, agendaitemspeakersUncheckedCreateInput>
    /**
     * In case the agendaitemspeakers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agendaitemspeakersUpdateInput, agendaitemspeakersUncheckedUpdateInput>
  }

  /**
   * agendaitemspeakers delete
   */
  export type agendaitemspeakersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
    /**
     * Filter which agendaitemspeakers to delete.
     */
    where: agendaitemspeakersWhereUniqueInput
  }

  /**
   * agendaitemspeakers deleteMany
   */
  export type agendaitemspeakersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendaitemspeakers to delete
     */
    where?: agendaitemspeakersWhereInput
    /**
     * Limit how many agendaitemspeakers to delete.
     */
    limit?: number
  }

  /**
   * agendaitemspeakers findRaw
   */
  export type agendaitemspeakersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendaitemspeakers aggregateRaw
   */
  export type agendaitemspeakersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendaitemspeakers without action
   */
  export type agendaitemspeakersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendaitemspeakers
     */
    select?: agendaitemspeakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendaitemspeakers
     */
    omit?: agendaitemspeakersOmit<ExtArgs> | null
  }


  /**
   * Model agendasessions
   */

  export type AggregateAgendasessions = {
    _count: AgendasessionsCountAggregateOutputType | null
    _min: AgendasessionsMinAggregateOutputType | null
    _max: AgendasessionsMaxAggregateOutputType | null
  }

  export type AgendasessionsMinAggregateOutputType = {
    id: string | null
  }

  export type AgendasessionsMaxAggregateOutputType = {
    id: string | null
  }

  export type AgendasessionsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type AgendasessionsMinAggregateInputType = {
    id?: true
  }

  export type AgendasessionsMaxAggregateInputType = {
    id?: true
  }

  export type AgendasessionsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type AgendasessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendasessions to aggregate.
     */
    where?: agendasessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendasessions to fetch.
     */
    orderBy?: agendasessionsOrderByWithRelationInput | agendasessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agendasessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendasessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendasessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agendasessions
    **/
    _count?: true | AgendasessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendasessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendasessionsMaxAggregateInputType
  }

  export type GetAgendasessionsAggregateType<T extends AgendasessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendasessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendasessions[P]>
      : GetScalarType<T[P], AggregateAgendasessions[P]>
  }




  export type agendasessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agendasessionsWhereInput
    orderBy?: agendasessionsOrderByWithAggregationInput | agendasessionsOrderByWithAggregationInput[]
    by: AgendasessionsScalarFieldEnum[] | AgendasessionsScalarFieldEnum
    having?: agendasessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendasessionsCountAggregateInputType | true
    _min?: AgendasessionsMinAggregateInputType
    _max?: AgendasessionsMaxAggregateInputType
  }

  export type AgendasessionsGroupByOutputType = {
    id: string
    _count: AgendasessionsCountAggregateOutputType | null
    _min: AgendasessionsMinAggregateOutputType | null
    _max: AgendasessionsMaxAggregateOutputType | null
  }

  type GetAgendasessionsGroupByPayload<T extends agendasessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgendasessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendasessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendasessionsGroupByOutputType[P]>
            : GetScalarType<T[P], AgendasessionsGroupByOutputType[P]>
        }
      >
    >


  export type agendasessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["agendasessions"]>



  export type agendasessionsSelectScalar = {
    id?: boolean
  }

  export type agendasessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["agendasessions"]>

  export type $agendasessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agendasessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["agendasessions"]>
    composites: {}
  }

  type agendasessionsGetPayload<S extends boolean | null | undefined | agendasessionsDefaultArgs> = $Result.GetResult<Prisma.$agendasessionsPayload, S>

  type agendasessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agendasessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgendasessionsCountAggregateInputType | true
    }

  export interface agendasessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agendasessions'], meta: { name: 'agendasessions' } }
    /**
     * Find zero or one Agendasessions that matches the filter.
     * @param {agendasessionsFindUniqueArgs} args - Arguments to find a Agendasessions
     * @example
     * // Get one Agendasessions
     * const agendasessions = await prisma.agendasessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agendasessionsFindUniqueArgs>(args: SelectSubset<T, agendasessionsFindUniqueArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agendasessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agendasessionsFindUniqueOrThrowArgs} args - Arguments to find a Agendasessions
     * @example
     * // Get one Agendasessions
     * const agendasessions = await prisma.agendasessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agendasessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, agendasessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendasessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsFindFirstArgs} args - Arguments to find a Agendasessions
     * @example
     * // Get one Agendasessions
     * const agendasessions = await prisma.agendasessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agendasessionsFindFirstArgs>(args?: SelectSubset<T, agendasessionsFindFirstArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agendasessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsFindFirstOrThrowArgs} args - Arguments to find a Agendasessions
     * @example
     * // Get one Agendasessions
     * const agendasessions = await prisma.agendasessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agendasessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, agendasessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendasessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendasessions
     * const agendasessions = await prisma.agendasessions.findMany()
     * 
     * // Get first 10 Agendasessions
     * const agendasessions = await prisma.agendasessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendasessionsWithIdOnly = await prisma.agendasessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agendasessionsFindManyArgs>(args?: SelectSubset<T, agendasessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agendasessions.
     * @param {agendasessionsCreateArgs} args - Arguments to create a Agendasessions.
     * @example
     * // Create one Agendasessions
     * const Agendasessions = await prisma.agendasessions.create({
     *   data: {
     *     // ... data to create a Agendasessions
     *   }
     * })
     * 
     */
    create<T extends agendasessionsCreateArgs>(args: SelectSubset<T, agendasessionsCreateArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agendasessions.
     * @param {agendasessionsCreateManyArgs} args - Arguments to create many Agendasessions.
     * @example
     * // Create many Agendasessions
     * const agendasessions = await prisma.agendasessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agendasessionsCreateManyArgs>(args?: SelectSubset<T, agendasessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agendasessions.
     * @param {agendasessionsDeleteArgs} args - Arguments to delete one Agendasessions.
     * @example
     * // Delete one Agendasessions
     * const Agendasessions = await prisma.agendasessions.delete({
     *   where: {
     *     // ... filter to delete one Agendasessions
     *   }
     * })
     * 
     */
    delete<T extends agendasessionsDeleteArgs>(args: SelectSubset<T, agendasessionsDeleteArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agendasessions.
     * @param {agendasessionsUpdateArgs} args - Arguments to update one Agendasessions.
     * @example
     * // Update one Agendasessions
     * const agendasessions = await prisma.agendasessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agendasessionsUpdateArgs>(args: SelectSubset<T, agendasessionsUpdateArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agendasessions.
     * @param {agendasessionsDeleteManyArgs} args - Arguments to filter Agendasessions to delete.
     * @example
     * // Delete a few Agendasessions
     * const { count } = await prisma.agendasessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agendasessionsDeleteManyArgs>(args?: SelectSubset<T, agendasessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendasessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendasessions
     * const agendasessions = await prisma.agendasessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agendasessionsUpdateManyArgs>(args: SelectSubset<T, agendasessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agendasessions.
     * @param {agendasessionsUpsertArgs} args - Arguments to update or create a Agendasessions.
     * @example
     * // Update or create a Agendasessions
     * const agendasessions = await prisma.agendasessions.upsert({
     *   create: {
     *     // ... data to create a Agendasessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendasessions we want to update
     *   }
     * })
     */
    upsert<T extends agendasessionsUpsertArgs>(args: SelectSubset<T, agendasessionsUpsertArgs<ExtArgs>>): Prisma__agendasessionsClient<$Result.GetResult<Prisma.$agendasessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agendasessions that matches the filter.
     * @param {agendasessionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const agendasessions = await prisma.agendasessions.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: agendasessionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Agendasessions.
     * @param {agendasessionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const agendasessions = await prisma.agendasessions.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: agendasessionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Agendasessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsCountArgs} args - Arguments to filter Agendasessions to count.
     * @example
     * // Count the number of Agendasessions
     * const count = await prisma.agendasessions.count({
     *   where: {
     *     // ... the filter for the Agendasessions we want to count
     *   }
     * })
    **/
    count<T extends agendasessionsCountArgs>(
      args?: Subset<T, agendasessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendasessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendasessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendasessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendasessionsAggregateArgs>(args: Subset<T, AgendasessionsAggregateArgs>): Prisma.PrismaPromise<GetAgendasessionsAggregateType<T>>

    /**
     * Group by Agendasessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agendasessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agendasessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agendasessionsGroupByArgs['orderBy'] }
        : { orderBy?: agendasessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agendasessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendasessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agendasessions model
   */
  readonly fields: agendasessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agendasessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agendasessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agendasessions model
   */
  interface agendasessionsFieldRefs {
    readonly id: FieldRef<"agendasessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agendasessions findUnique
   */
  export type agendasessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter, which agendasessions to fetch.
     */
    where: agendasessionsWhereUniqueInput
  }

  /**
   * agendasessions findUniqueOrThrow
   */
  export type agendasessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter, which agendasessions to fetch.
     */
    where: agendasessionsWhereUniqueInput
  }

  /**
   * agendasessions findFirst
   */
  export type agendasessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter, which agendasessions to fetch.
     */
    where?: agendasessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendasessions to fetch.
     */
    orderBy?: agendasessionsOrderByWithRelationInput | agendasessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendasessions.
     */
    cursor?: agendasessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendasessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendasessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendasessions.
     */
    distinct?: AgendasessionsScalarFieldEnum | AgendasessionsScalarFieldEnum[]
  }

  /**
   * agendasessions findFirstOrThrow
   */
  export type agendasessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter, which agendasessions to fetch.
     */
    where?: agendasessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendasessions to fetch.
     */
    orderBy?: agendasessionsOrderByWithRelationInput | agendasessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agendasessions.
     */
    cursor?: agendasessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendasessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendasessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agendasessions.
     */
    distinct?: AgendasessionsScalarFieldEnum | AgendasessionsScalarFieldEnum[]
  }

  /**
   * agendasessions findMany
   */
  export type agendasessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter, which agendasessions to fetch.
     */
    where?: agendasessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agendasessions to fetch.
     */
    orderBy?: agendasessionsOrderByWithRelationInput | agendasessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agendasessions.
     */
    cursor?: agendasessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agendasessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agendasessions.
     */
    skip?: number
    distinct?: AgendasessionsScalarFieldEnum | AgendasessionsScalarFieldEnum[]
  }

  /**
   * agendasessions create
   */
  export type agendasessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a agendasessions.
     */
    data?: XOR<agendasessionsCreateInput, agendasessionsUncheckedCreateInput>
  }

  /**
   * agendasessions createMany
   */
  export type agendasessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agendasessions.
     */
    data: agendasessionsCreateManyInput | agendasessionsCreateManyInput[]
  }

  /**
   * agendasessions update
   */
  export type agendasessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a agendasessions.
     */
    data: XOR<agendasessionsUpdateInput, agendasessionsUncheckedUpdateInput>
    /**
     * Choose, which agendasessions to update.
     */
    where: agendasessionsWhereUniqueInput
  }

  /**
   * agendasessions updateMany
   */
  export type agendasessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agendasessions.
     */
    data: XOR<agendasessionsUpdateManyMutationInput, agendasessionsUncheckedUpdateManyInput>
    /**
     * Filter which agendasessions to update
     */
    where?: agendasessionsWhereInput
    /**
     * Limit how many agendasessions to update.
     */
    limit?: number
  }

  /**
   * agendasessions upsert
   */
  export type agendasessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the agendasessions to update in case it exists.
     */
    where: agendasessionsWhereUniqueInput
    /**
     * In case the agendasessions found by the `where` argument doesn't exist, create a new agendasessions with this data.
     */
    create: XOR<agendasessionsCreateInput, agendasessionsUncheckedCreateInput>
    /**
     * In case the agendasessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agendasessionsUpdateInput, agendasessionsUncheckedUpdateInput>
  }

  /**
   * agendasessions delete
   */
  export type agendasessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
    /**
     * Filter which agendasessions to delete.
     */
    where: agendasessionsWhereUniqueInput
  }

  /**
   * agendasessions deleteMany
   */
  export type agendasessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agendasessions to delete
     */
    where?: agendasessionsWhereInput
    /**
     * Limit how many agendasessions to delete.
     */
    limit?: number
  }

  /**
   * agendasessions findRaw
   */
  export type agendasessionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendasessions aggregateRaw
   */
  export type agendasessionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * agendasessions without action
   */
  export type agendasessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agendasessions
     */
    select?: agendasessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agendasessions
     */
    omit?: agendasessionsOmit<ExtArgs> | null
  }


  /**
   * Model exhibitors
   */

  export type AggregateExhibitors = {
    _count: ExhibitorsCountAggregateOutputType | null
    _min: ExhibitorsMinAggregateOutputType | null
    _max: ExhibitorsMaxAggregateOutputType | null
  }

  export type ExhibitorsMinAggregateOutputType = {
    id: string | null
  }

  export type ExhibitorsMaxAggregateOutputType = {
    id: string | null
  }

  export type ExhibitorsCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type ExhibitorsMinAggregateInputType = {
    id?: true
  }

  export type ExhibitorsMaxAggregateInputType = {
    id?: true
  }

  export type ExhibitorsCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type ExhibitorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exhibitors to aggregate.
     */
    where?: exhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exhibitors to fetch.
     */
    orderBy?: exhibitorsOrderByWithRelationInput | exhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exhibitors
    **/
    _count?: true | ExhibitorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExhibitorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExhibitorsMaxAggregateInputType
  }

  export type GetExhibitorsAggregateType<T extends ExhibitorsAggregateArgs> = {
        [P in keyof T & keyof AggregateExhibitors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitors[P]>
      : GetScalarType<T[P], AggregateExhibitors[P]>
  }




  export type exhibitorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exhibitorsWhereInput
    orderBy?: exhibitorsOrderByWithAggregationInput | exhibitorsOrderByWithAggregationInput[]
    by: ExhibitorsScalarFieldEnum[] | ExhibitorsScalarFieldEnum
    having?: exhibitorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExhibitorsCountAggregateInputType | true
    _min?: ExhibitorsMinAggregateInputType
    _max?: ExhibitorsMaxAggregateInputType
  }

  export type ExhibitorsGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: ExhibitorsCountAggregateOutputType | null
    _min: ExhibitorsMinAggregateOutputType | null
    _max: ExhibitorsMaxAggregateOutputType | null
  }

  type GetExhibitorsGroupByPayload<T extends exhibitorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExhibitorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExhibitorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitorsGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitorsGroupByOutputType[P]>
        }
      >
    >


  export type exhibitorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["exhibitors"]>



  export type exhibitorsSelectScalar = {
    id?: boolean
  }

  export type exhibitorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["exhibitors"]>

  export type $exhibitorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exhibitors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["exhibitors"]>
    composites: {}
  }

  type exhibitorsGetPayload<S extends boolean | null | undefined | exhibitorsDefaultArgs> = $Result.GetResult<Prisma.$exhibitorsPayload, S>

  type exhibitorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exhibitorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExhibitorsCountAggregateInputType | true
    }

  export interface exhibitorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exhibitors'], meta: { name: 'exhibitors' } }
    /**
     * Find zero or one Exhibitors that matches the filter.
     * @param {exhibitorsFindUniqueArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exhibitorsFindUniqueArgs>(args: SelectSubset<T, exhibitorsFindUniqueArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exhibitors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exhibitorsFindUniqueOrThrowArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exhibitorsFindUniqueOrThrowArgs>(args: SelectSubset<T, exhibitorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsFindFirstArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exhibitorsFindFirstArgs>(args?: SelectSubset<T, exhibitorsFindFirstArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exhibitors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsFindFirstOrThrowArgs} args - Arguments to find a Exhibitors
     * @example
     * // Get one Exhibitors
     * const exhibitors = await prisma.exhibitors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exhibitorsFindFirstOrThrowArgs>(args?: SelectSubset<T, exhibitorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exhibitors
     * const exhibitors = await prisma.exhibitors.findMany()
     * 
     * // Get first 10 Exhibitors
     * const exhibitors = await prisma.exhibitors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exhibitorsWithIdOnly = await prisma.exhibitors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends exhibitorsFindManyArgs>(args?: SelectSubset<T, exhibitorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exhibitors.
     * @param {exhibitorsCreateArgs} args - Arguments to create a Exhibitors.
     * @example
     * // Create one Exhibitors
     * const Exhibitors = await prisma.exhibitors.create({
     *   data: {
     *     // ... data to create a Exhibitors
     *   }
     * })
     * 
     */
    create<T extends exhibitorsCreateArgs>(args: SelectSubset<T, exhibitorsCreateArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exhibitors.
     * @param {exhibitorsCreateManyArgs} args - Arguments to create many Exhibitors.
     * @example
     * // Create many Exhibitors
     * const exhibitors = await prisma.exhibitors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exhibitorsCreateManyArgs>(args?: SelectSubset<T, exhibitorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exhibitors.
     * @param {exhibitorsDeleteArgs} args - Arguments to delete one Exhibitors.
     * @example
     * // Delete one Exhibitors
     * const Exhibitors = await prisma.exhibitors.delete({
     *   where: {
     *     // ... filter to delete one Exhibitors
     *   }
     * })
     * 
     */
    delete<T extends exhibitorsDeleteArgs>(args: SelectSubset<T, exhibitorsDeleteArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exhibitors.
     * @param {exhibitorsUpdateArgs} args - Arguments to update one Exhibitors.
     * @example
     * // Update one Exhibitors
     * const exhibitors = await prisma.exhibitors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exhibitorsUpdateArgs>(args: SelectSubset<T, exhibitorsUpdateArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exhibitors.
     * @param {exhibitorsDeleteManyArgs} args - Arguments to filter Exhibitors to delete.
     * @example
     * // Delete a few Exhibitors
     * const { count } = await prisma.exhibitors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exhibitorsDeleteManyArgs>(args?: SelectSubset<T, exhibitorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exhibitors
     * const exhibitors = await prisma.exhibitors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exhibitorsUpdateManyArgs>(args: SelectSubset<T, exhibitorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exhibitors.
     * @param {exhibitorsUpsertArgs} args - Arguments to update or create a Exhibitors.
     * @example
     * // Update or create a Exhibitors
     * const exhibitors = await prisma.exhibitors.upsert({
     *   create: {
     *     // ... data to create a Exhibitors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exhibitors we want to update
     *   }
     * })
     */
    upsert<T extends exhibitorsUpsertArgs>(args: SelectSubset<T, exhibitorsUpsertArgs<ExtArgs>>): Prisma__exhibitorsClient<$Result.GetResult<Prisma.$exhibitorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exhibitors that matches the filter.
     * @param {exhibitorsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const exhibitors = await prisma.exhibitors.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: exhibitorsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Exhibitors.
     * @param {exhibitorsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const exhibitors = await prisma.exhibitors.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: exhibitorsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsCountArgs} args - Arguments to filter Exhibitors to count.
     * @example
     * // Count the number of Exhibitors
     * const count = await prisma.exhibitors.count({
     *   where: {
     *     // ... the filter for the Exhibitors we want to count
     *   }
     * })
    **/
    count<T extends exhibitorsCountArgs>(
      args?: Subset<T, exhibitorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExhibitorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExhibitorsAggregateArgs>(args: Subset<T, ExhibitorsAggregateArgs>): Prisma.PrismaPromise<GetExhibitorsAggregateType<T>>

    /**
     * Group by Exhibitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exhibitorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exhibitorsGroupByArgs['orderBy'] }
        : { orderBy?: exhibitorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exhibitorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExhibitorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exhibitors model
   */
  readonly fields: exhibitorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exhibitors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exhibitorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exhibitors model
   */
  interface exhibitorsFieldRefs {
    readonly id: FieldRef<"exhibitors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * exhibitors findUnique
   */
  export type exhibitorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which exhibitors to fetch.
     */
    where: exhibitorsWhereUniqueInput
  }

  /**
   * exhibitors findUniqueOrThrow
   */
  export type exhibitorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which exhibitors to fetch.
     */
    where: exhibitorsWhereUniqueInput
  }

  /**
   * exhibitors findFirst
   */
  export type exhibitorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which exhibitors to fetch.
     */
    where?: exhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exhibitors to fetch.
     */
    orderBy?: exhibitorsOrderByWithRelationInput | exhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exhibitors.
     */
    cursor?: exhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exhibitors.
     */
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * exhibitors findFirstOrThrow
   */
  export type exhibitorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which exhibitors to fetch.
     */
    where?: exhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exhibitors to fetch.
     */
    orderBy?: exhibitorsOrderByWithRelationInput | exhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exhibitors.
     */
    cursor?: exhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exhibitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exhibitors.
     */
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * exhibitors findMany
   */
  export type exhibitorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter, which exhibitors to fetch.
     */
    where?: exhibitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exhibitors to fetch.
     */
    orderBy?: exhibitorsOrderByWithRelationInput | exhibitorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exhibitors.
     */
    cursor?: exhibitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exhibitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exhibitors.
     */
    skip?: number
    distinct?: ExhibitorsScalarFieldEnum | ExhibitorsScalarFieldEnum[]
  }

  /**
   * exhibitors create
   */
  export type exhibitorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * The data needed to create a exhibitors.
     */
    data?: XOR<exhibitorsCreateInput, exhibitorsUncheckedCreateInput>
  }

  /**
   * exhibitors createMany
   */
  export type exhibitorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exhibitors.
     */
    data: exhibitorsCreateManyInput | exhibitorsCreateManyInput[]
  }

  /**
   * exhibitors update
   */
  export type exhibitorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * The data needed to update a exhibitors.
     */
    data: XOR<exhibitorsUpdateInput, exhibitorsUncheckedUpdateInput>
    /**
     * Choose, which exhibitors to update.
     */
    where: exhibitorsWhereUniqueInput
  }

  /**
   * exhibitors updateMany
   */
  export type exhibitorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exhibitors.
     */
    data: XOR<exhibitorsUpdateManyMutationInput, exhibitorsUncheckedUpdateManyInput>
    /**
     * Filter which exhibitors to update
     */
    where?: exhibitorsWhereInput
    /**
     * Limit how many exhibitors to update.
     */
    limit?: number
  }

  /**
   * exhibitors upsert
   */
  export type exhibitorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * The filter to search for the exhibitors to update in case it exists.
     */
    where: exhibitorsWhereUniqueInput
    /**
     * In case the exhibitors found by the `where` argument doesn't exist, create a new exhibitors with this data.
     */
    create: XOR<exhibitorsCreateInput, exhibitorsUncheckedCreateInput>
    /**
     * In case the exhibitors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exhibitorsUpdateInput, exhibitorsUncheckedUpdateInput>
  }

  /**
   * exhibitors delete
   */
  export type exhibitorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
    /**
     * Filter which exhibitors to delete.
     */
    where: exhibitorsWhereUniqueInput
  }

  /**
   * exhibitors deleteMany
   */
  export type exhibitorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exhibitors to delete
     */
    where?: exhibitorsWhereInput
    /**
     * Limit how many exhibitors to delete.
     */
    limit?: number
  }

  /**
   * exhibitors findRaw
   */
  export type exhibitorsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * exhibitors aggregateRaw
   */
  export type exhibitorsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * exhibitors without action
   */
  export type exhibitorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exhibitors
     */
    select?: exhibitorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exhibitors
     */
    omit?: exhibitorsOmit<ExtArgs> | null
  }


  /**
   * Model projects
   */

  export type AggregateProjects = {
    _count: ProjectsCountAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsMinAggregateOutputType = {
    id: string | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: string | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ProjectsMinAggregateInputType = {
    id?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to aggregate.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    _count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }




  export type projectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsWhereInput
    orderBy?: projectsOrderByWithAggregationInput | projectsOrderByWithAggregationInput[]
    by: ProjectsScalarFieldEnum[] | ProjectsScalarFieldEnum
    having?: projectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsCountAggregateInputType | true
    _min?: ProjectsMinAggregateInputType
    _max?: ProjectsMaxAggregateInputType
  }

  export type ProjectsGroupByOutputType = {
    id: string
    _count: ProjectsCountAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  type GetProjectsGroupByPayload<T extends projectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
        }
      >
    >


  export type projectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["projects"]>



  export type projectsSelectScalar = {
    id?: boolean
  }

  export type projectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["projects"]>

  export type $projectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projects"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["projects"]>
    composites: {}
  }

  type projectsGetPayload<S extends boolean | null | undefined | projectsDefaultArgs> = $Result.GetResult<Prisma.$projectsPayload, S>

  type projectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectsCountAggregateInputType | true
    }

  export interface projectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projects'], meta: { name: 'projects' } }
    /**
     * Find zero or one Projects that matches the filter.
     * @param {projectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectsFindUniqueArgs>(args: SelectSubset<T, projectsFindUniqueArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectsFindUniqueOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectsFindUniqueOrThrowArgs>(args: SelectSubset<T, projectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectsFindFirstArgs>(args?: SelectSubset<T, projectsFindFirstArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectsFindFirstOrThrowArgs>(args?: SelectSubset<T, projectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectsFindManyArgs>(args?: SelectSubset<T, projectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projects.
     * @param {projectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
     */
    create<T extends projectsCreateArgs>(args: SelectSubset<T, projectsCreateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {projectsCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectsCreateManyArgs>(args?: SelectSubset<T, projectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projects.
     * @param {projectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
     */
    delete<T extends projectsDeleteArgs>(args: SelectSubset<T, projectsDeleteArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projects.
     * @param {projectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectsUpdateArgs>(args: SelectSubset<T, projectsUpdateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {projectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectsDeleteManyArgs>(args?: SelectSubset<T, projectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectsUpdateManyArgs>(args: SelectSubset<T, projectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projects.
     * @param {projectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
     */
    upsert<T extends projectsUpsertArgs>(args: SelectSubset<T, projectsUpsertArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * @param {projectsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const projects = await prisma.projects.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: projectsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Projects.
     * @param {projectsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const projects = await prisma.projects.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: projectsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectsCountArgs>(
      args?: Subset<T, projectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Prisma.PrismaPromise<GetProjectsAggregateType<T>>

    /**
     * Group by Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectsGroupByArgs['orderBy'] }
        : { orderBy?: projectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projects model
   */
  readonly fields: projectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projects model
   */
  interface projectsFieldRefs {
    readonly id: FieldRef<"projects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * projects findUnique
   */
  export type projectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findUniqueOrThrow
   */
  export type projectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findFirst
   */
  export type projectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findFirstOrThrow
   */
  export type projectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findMany
   */
  export type projectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects create
   */
  export type projectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data needed to create a projects.
     */
    data?: XOR<projectsCreateInput, projectsUncheckedCreateInput>
  }

  /**
   * projects createMany
   */
  export type projectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projects.
     */
    data: projectsCreateManyInput | projectsCreateManyInput[]
  }

  /**
   * projects update
   */
  export type projectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data needed to update a projects.
     */
    data: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
    /**
     * Choose, which projects to update.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects updateMany
   */
  export type projectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projects.
     */
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to update.
     */
    limit?: number
  }

  /**
   * projects upsert
   */
  export type projectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The filter to search for the projects to update in case it exists.
     */
    where: projectsWhereUniqueInput
    /**
     * In case the projects found by the `where` argument doesn't exist, create a new projects with this data.
     */
    create: XOR<projectsCreateInput, projectsUncheckedCreateInput>
    /**
     * In case the projects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
  }

  /**
   * projects delete
   */
  export type projectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Filter which projects to delete.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects deleteMany
   */
  export type projectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to delete
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to delete.
     */
    limit?: number
  }

  /**
   * projects findRaw
   */
  export type projectsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * projects aggregateRaw
   */
  export type projectsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * projects without action
   */
  export type projectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
  }


  /**
   * Model speakers
   */

  export type AggregateSpeakers = {
    _count: SpeakersCountAggregateOutputType | null
    _min: SpeakersMinAggregateOutputType | null
    _max: SpeakersMaxAggregateOutputType | null
  }

  export type SpeakersMinAggregateOutputType = {
    id: string | null
  }

  export type SpeakersMaxAggregateOutputType = {
    id: string | null
  }

  export type SpeakersCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type SpeakersMinAggregateInputType = {
    id?: true
  }

  export type SpeakersMaxAggregateInputType = {
    id?: true
  }

  export type SpeakersCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type SpeakersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which speakers to aggregate.
     */
    where?: speakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speakers to fetch.
     */
    orderBy?: speakersOrderByWithRelationInput | speakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: speakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned speakers
    **/
    _count?: true | SpeakersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakersMaxAggregateInputType
  }

  export type GetSpeakersAggregateType<T extends SpeakersAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakers[P]>
      : GetScalarType<T[P], AggregateSpeakers[P]>
  }




  export type speakersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: speakersWhereInput
    orderBy?: speakersOrderByWithAggregationInput | speakersOrderByWithAggregationInput[]
    by: SpeakersScalarFieldEnum[] | SpeakersScalarFieldEnum
    having?: speakersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakersCountAggregateInputType | true
    _min?: SpeakersMinAggregateInputType
    _max?: SpeakersMaxAggregateInputType
  }

  export type SpeakersGroupByOutputType = {
    id: string
    projectId: JsonValue | null
    _count: SpeakersCountAggregateOutputType | null
    _min: SpeakersMinAggregateOutputType | null
    _max: SpeakersMaxAggregateOutputType | null
  }

  type GetSpeakersGroupByPayload<T extends speakersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakersGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakersGroupByOutputType[P]>
        }
      >
    >


  export type speakersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["speakers"]>



  export type speakersSelectScalar = {
    id?: boolean
  }

  export type speakersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["speakers"]>

  export type $speakersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "speakers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["speakers"]>
    composites: {}
  }

  type speakersGetPayload<S extends boolean | null | undefined | speakersDefaultArgs> = $Result.GetResult<Prisma.$speakersPayload, S>

  type speakersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<speakersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakersCountAggregateInputType | true
    }

  export interface speakersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['speakers'], meta: { name: 'speakers' } }
    /**
     * Find zero or one Speakers that matches the filter.
     * @param {speakersFindUniqueArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends speakersFindUniqueArgs>(args: SelectSubset<T, speakersFindUniqueArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Speakers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {speakersFindUniqueOrThrowArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends speakersFindUniqueOrThrowArgs>(args: SelectSubset<T, speakersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersFindFirstArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends speakersFindFirstArgs>(args?: SelectSubset<T, speakersFindFirstArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speakers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersFindFirstOrThrowArgs} args - Arguments to find a Speakers
     * @example
     * // Get one Speakers
     * const speakers = await prisma.speakers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends speakersFindFirstOrThrowArgs>(args?: SelectSubset<T, speakersFindFirstOrThrowArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speakers.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speakers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakersWithIdOnly = await prisma.speakers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends speakersFindManyArgs>(args?: SelectSubset<T, speakersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Speakers.
     * @param {speakersCreateArgs} args - Arguments to create a Speakers.
     * @example
     * // Create one Speakers
     * const Speakers = await prisma.speakers.create({
     *   data: {
     *     // ... data to create a Speakers
     *   }
     * })
     * 
     */
    create<T extends speakersCreateArgs>(args: SelectSubset<T, speakersCreateArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Speakers.
     * @param {speakersCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speakers = await prisma.speakers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends speakersCreateManyArgs>(args?: SelectSubset<T, speakersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Speakers.
     * @param {speakersDeleteArgs} args - Arguments to delete one Speakers.
     * @example
     * // Delete one Speakers
     * const Speakers = await prisma.speakers.delete({
     *   where: {
     *     // ... filter to delete one Speakers
     *   }
     * })
     * 
     */
    delete<T extends speakersDeleteArgs>(args: SelectSubset<T, speakersDeleteArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Speakers.
     * @param {speakersUpdateArgs} args - Arguments to update one Speakers.
     * @example
     * // Update one Speakers
     * const speakers = await prisma.speakers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends speakersUpdateArgs>(args: SelectSubset<T, speakersUpdateArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Speakers.
     * @param {speakersDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speakers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends speakersDeleteManyArgs>(args?: SelectSubset<T, speakersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speakers = await prisma.speakers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends speakersUpdateManyArgs>(args: SelectSubset<T, speakersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Speakers.
     * @param {speakersUpsertArgs} args - Arguments to update or create a Speakers.
     * @example
     * // Update or create a Speakers
     * const speakers = await prisma.speakers.upsert({
     *   create: {
     *     // ... data to create a Speakers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speakers we want to update
     *   }
     * })
     */
    upsert<T extends speakersUpsertArgs>(args: SelectSubset<T, speakersUpsertArgs<ExtArgs>>): Prisma__speakersClient<$Result.GetResult<Prisma.$speakersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * @param {speakersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const speakers = await prisma.speakers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: speakersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Speakers.
     * @param {speakersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const speakers = await prisma.speakers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: speakersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speakers.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends speakersCountArgs>(
      args?: Subset<T, speakersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakersAggregateArgs>(args: Subset<T, SpeakersAggregateArgs>): Prisma.PrismaPromise<GetSpeakersAggregateType<T>>

    /**
     * Group by Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {speakersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends speakersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: speakersGroupByArgs['orderBy'] }
        : { orderBy?: speakersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, speakersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the speakers model
   */
  readonly fields: speakersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for speakers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__speakersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the speakers model
   */
  interface speakersFieldRefs {
    readonly id: FieldRef<"speakers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * speakers findUnique
   */
  export type speakersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter, which speakers to fetch.
     */
    where: speakersWhereUniqueInput
  }

  /**
   * speakers findUniqueOrThrow
   */
  export type speakersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter, which speakers to fetch.
     */
    where: speakersWhereUniqueInput
  }

  /**
   * speakers findFirst
   */
  export type speakersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter, which speakers to fetch.
     */
    where?: speakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speakers to fetch.
     */
    orderBy?: speakersOrderByWithRelationInput | speakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for speakers.
     */
    cursor?: speakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of speakers.
     */
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * speakers findFirstOrThrow
   */
  export type speakersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter, which speakers to fetch.
     */
    where?: speakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speakers to fetch.
     */
    orderBy?: speakersOrderByWithRelationInput | speakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for speakers.
     */
    cursor?: speakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of speakers.
     */
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * speakers findMany
   */
  export type speakersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter, which speakers to fetch.
     */
    where?: speakersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of speakers to fetch.
     */
    orderBy?: speakersOrderByWithRelationInput | speakersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing speakers.
     */
    cursor?: speakersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` speakers.
     */
    skip?: number
    distinct?: SpeakersScalarFieldEnum | SpeakersScalarFieldEnum[]
  }

  /**
   * speakers create
   */
  export type speakersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * The data needed to create a speakers.
     */
    data?: XOR<speakersCreateInput, speakersUncheckedCreateInput>
  }

  /**
   * speakers createMany
   */
  export type speakersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many speakers.
     */
    data: speakersCreateManyInput | speakersCreateManyInput[]
  }

  /**
   * speakers update
   */
  export type speakersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * The data needed to update a speakers.
     */
    data: XOR<speakersUpdateInput, speakersUncheckedUpdateInput>
    /**
     * Choose, which speakers to update.
     */
    where: speakersWhereUniqueInput
  }

  /**
   * speakers updateMany
   */
  export type speakersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update speakers.
     */
    data: XOR<speakersUpdateManyMutationInput, speakersUncheckedUpdateManyInput>
    /**
     * Filter which speakers to update
     */
    where?: speakersWhereInput
    /**
     * Limit how many speakers to update.
     */
    limit?: number
  }

  /**
   * speakers upsert
   */
  export type speakersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * The filter to search for the speakers to update in case it exists.
     */
    where: speakersWhereUniqueInput
    /**
     * In case the speakers found by the `where` argument doesn't exist, create a new speakers with this data.
     */
    create: XOR<speakersCreateInput, speakersUncheckedCreateInput>
    /**
     * In case the speakers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<speakersUpdateInput, speakersUncheckedUpdateInput>
  }

  /**
   * speakers delete
   */
  export type speakersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
    /**
     * Filter which speakers to delete.
     */
    where: speakersWhereUniqueInput
  }

  /**
   * speakers deleteMany
   */
  export type speakersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which speakers to delete
     */
    where?: speakersWhereInput
    /**
     * Limit how many speakers to delete.
     */
    limit?: number
  }

  /**
   * speakers findRaw
   */
  export type speakersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * speakers aggregateRaw
   */
  export type speakersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * speakers without action
   */
  export type speakersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the speakers
     */
    select?: speakersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the speakers
     */
    omit?: speakersOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const AgendaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type AgendaScalarFieldEnum = (typeof AgendaScalarFieldEnum)[keyof typeof AgendaScalarFieldEnum]


  export const AgendaDayScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    date: 'date',
    dayNumber: 'dayNumber',
    name: 'name',
    projectId: 'projectId',
    updatedAt: 'updatedAt'
  };

  export type AgendaDayScalarFieldEnum = (typeof AgendaDayScalarFieldEnum)[keyof typeof AgendaDayScalarFieldEnum]


  export const AgendaItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    description: 'description',
    endTime: 'endTime',
    sessionId: 'sessionId',
    startTime: 'startTime',
    title: 'title',
    type: 'type',
    updatedAt: 'updatedAt'
  };

  export type AgendaItemScalarFieldEnum = (typeof AgendaItemScalarFieldEnum)[keyof typeof AgendaItemScalarFieldEnum]


  export const AgendaItemSpeakerScalarFieldEnum: {
    id: 'id',
    agendaItemId: 'agendaItemId',
    speakerId: 'speakerId'
  };

  export type AgendaItemSpeakerScalarFieldEnum = (typeof AgendaItemSpeakerScalarFieldEnum)[keyof typeof AgendaItemSpeakerScalarFieldEnum]


  export const AgendaSessionScalarFieldEnum: {
    id: 'id',
    color: 'color',
    createdAt: 'createdAt',
    dayId: 'dayId',
    endTime: 'endTime',
    startTime: 'startTime',
    title: 'title',
    updatedAt: 'updatedAt',
    venue: 'venue'
  };

  export type AgendaSessionScalarFieldEnum = (typeof AgendaSessionScalarFieldEnum)[keyof typeof AgendaSessionScalarFieldEnum]


  export const AttendeeScalarFieldEnum: {
    id: 'id',
    checkedIn: 'checkedIn',
    checkinTime: 'checkinTime',
    company: 'company',
    createdAt: 'createdAt',
    email: 'email',
    jobTitle: 'jobTitle',
    name: 'name',
    phone: 'phone',
    projectId: 'projectId',
    updatedAt: 'updatedAt'
  };

  export type AttendeeScalarFieldEnum = (typeof AttendeeScalarFieldEnum)[keyof typeof AttendeeScalarFieldEnum]


  export const AttendeesScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type AttendeesScalarFieldEnum = (typeof AttendeesScalarFieldEnum)[keyof typeof AttendeesScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const ContactRequestScalarFieldEnum: {
    id: 'id'
  };

  export type ContactRequestScalarFieldEnum = (typeof ContactRequestScalarFieldEnum)[keyof typeof ContactRequestScalarFieldEnum]


  export const DelegateScalarFieldEnum: {
    id: 'id',
    address: 'address',
    booth: 'booth',
    company: 'company',
    createdAt: 'createdAt',
    description: 'description',
    email: 'email',
    featured: 'featured',
    image: 'image',
    jobTitle: 'jobTitle',
    name: 'name',
    phone: 'phone',
    priority: 'priority',
    projectId: 'projectId',
    status: 'status',
    type: 'type',
    updatedAt: 'updatedAt'
  };

  export type DelegateScalarFieldEnum = (typeof DelegateScalarFieldEnum)[keyof typeof DelegateScalarFieldEnum]


  export const DelegatesScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type DelegatesScalarFieldEnum = (typeof DelegatesScalarFieldEnum)[keyof typeof DelegatesScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    code: 'code'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const EnquiryScalarFieldEnum: {
    id: 'id'
  };

  export type EnquiryScalarFieldEnum = (typeof EnquiryScalarFieldEnum)[keyof typeof EnquiryScalarFieldEnum]


  export const ExhibitorScalarFieldEnum: {
    id: 'id',
    boothNumber: 'boothNumber',
    category: 'category',
    createdAt: 'createdAt',
    image: 'image',
    name: 'name',
    projectId: 'projectId',
    size: 'size',
    status: 'status',
    updatedAt: 'updatedAt'
  };

  export type ExhibitorScalarFieldEnum = (typeof ExhibitorScalarFieldEnum)[keyof typeof ExhibitorScalarFieldEnum]


  export const ExhibitorsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type ExhibitorsScalarFieldEnum = (typeof ExhibitorsScalarFieldEnum)[keyof typeof ExhibitorsScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const MarketingScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type MarketingScalarFieldEnum = (typeof MarketingScalarFieldEnum)[keyof typeof MarketingScalarFieldEnum]


  export const MarketingCampaignScalarFieldEnum: {
    id: 'id'
  };

  export type MarketingCampaignScalarFieldEnum = (typeof MarketingCampaignScalarFieldEnum)[keyof typeof MarketingCampaignScalarFieldEnum]


  export const MediaPartnerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    image: 'image',
    name: 'name',
    priority: 'priority',
    projectId: 'projectId',
    type: 'type',
    updatedAt: 'updatedAt',
    website: 'website'
  };

  export type MediaPartnerScalarFieldEnum = (typeof MediaPartnerScalarFieldEnum)[keyof typeof MediaPartnerScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    contribution: 'contribution',
    createdAt: 'createdAt',
    image: 'image',
    name: 'name',
    projectId: 'projectId',
    status: 'status',
    type: 'type',
    updatedAt: 'updatedAt',
    website: 'website'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const PartnersScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type PartnersScalarFieldEnum = (typeof PartnersScalarFieldEnum)[keyof typeof PartnersScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    currency: 'currency',
    description: 'description',
    endDate: 'endDate',
    name: 'name',
    startDate: 'startDate',
    updatedAt: 'updatedAt',
    venue: 'venue',
    website: 'website',
    year: 'year'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectStatsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    delegates: 'delegates',
    exhibitors: 'exhibitors',
    mediaPartners: 'mediaPartners',
    partners: 'partners',
    projectId: 'projectId',
    speakers: 'speakers',
    sponsors: 'sponsors',
    updatedAt: 'updatedAt'
  };

  export type ProjectStatsScalarFieldEnum = (typeof ProjectStatsScalarFieldEnum)[keyof typeof ProjectStatsScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const SpeakerScalarFieldEnum: {
    id: 'id'
  };

  export type SpeakerScalarFieldEnum = (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum]


  export const SpeakerSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    speakerId: 'speakerId'
  };

  export type SpeakerSessionScalarFieldEnum = (typeof SpeakerSessionScalarFieldEnum)[keyof typeof SpeakerSessionScalarFieldEnum]


  export const SpeakersScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type SpeakersScalarFieldEnum = (typeof SpeakersScalarFieldEnum)[keyof typeof SpeakersScalarFieldEnum]


  export const SponsorScalarFieldEnum: {
    id: 'id'
  };

  export type SponsorScalarFieldEnum = (typeof SponsorScalarFieldEnum)[keyof typeof SponsorScalarFieldEnum]


  export const SponsorsScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type SponsorsScalarFieldEnum = (typeof SponsorsScalarFieldEnum)[keyof typeof SponsorsScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketingScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type TicketingScalarFieldEnum = (typeof TicketingScalarFieldEnum)[keyof typeof TicketingScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UtmDataScalarFieldEnum: {
    id: 'id',
    campaign: 'campaign',
    content: 'content',
    conversions: 'conversions',
    createdAt: 'createdAt',
    medium: 'medium',
    name: 'name',
    projectId: 'projectId',
    source: 'source',
    term: 'term',
    updatedAt: 'updatedAt',
    visits: 'visits',
    websiteUrl: 'websiteUrl'
  };

  export type UtmDataScalarFieldEnum = (typeof UtmDataScalarFieldEnum)[keyof typeof UtmDataScalarFieldEnum]


  export const AgendadaysScalarFieldEnum: {
    id: 'id',
    v: 'v',
    date: 'date',
    dayNumber: 'dayNumber',
    name: 'name'
  };

  export type AgendadaysScalarFieldEnum = (typeof AgendadaysScalarFieldEnum)[keyof typeof AgendadaysScalarFieldEnum]


  export const AgendaitemsScalarFieldEnum: {
    id: 'id'
  };

  export type AgendaitemsScalarFieldEnum = (typeof AgendaitemsScalarFieldEnum)[keyof typeof AgendaitemsScalarFieldEnum]


  export const AgendaitemspeakersScalarFieldEnum: {
    id: 'id'
  };

  export type AgendaitemspeakersScalarFieldEnum = (typeof AgendaitemspeakersScalarFieldEnum)[keyof typeof AgendaitemspeakersScalarFieldEnum]


  export const AgendasessionsScalarFieldEnum: {
    id: 'id'
  };

  export type AgendasessionsScalarFieldEnum = (typeof AgendasessionsScalarFieldEnum)[keyof typeof AgendasessionsScalarFieldEnum]


  export const ExhibitorsScalarFieldEnum: {
    id: 'id'
  };

  export type ExhibitorsScalarFieldEnum = (typeof ExhibitorsScalarFieldEnum)[keyof typeof ExhibitorsScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const SpeakersScalarFieldEnum: {
    id: 'id'
  };

  export type SpeakersScalarFieldEnum = (typeof SpeakersScalarFieldEnum)[keyof typeof SpeakersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AgendaWhereInput = {
    AND?: AgendaWhereInput | AgendaWhereInput[]
    OR?: AgendaWhereInput[]
    NOT?: AgendaWhereInput | AgendaWhereInput[]
    id?: StringFilter<"Agenda"> | string
    projectId?: JsonNullableFilter<"Agenda">
  }

  export type AgendaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type AgendaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: AgendaWhereInput | AgendaWhereInput[]
    OR?: AgendaWhereInput[]
    NOT?: AgendaWhereInput | AgendaWhereInput[]
  }, "id" | "projectId">

  export type AgendaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: AgendaCountOrderByAggregateInput
    _max?: AgendaMaxOrderByAggregateInput
    _min?: AgendaMinOrderByAggregateInput
  }

  export type AgendaScalarWhereWithAggregatesInput = {
    AND?: AgendaScalarWhereWithAggregatesInput | AgendaScalarWhereWithAggregatesInput[]
    OR?: AgendaScalarWhereWithAggregatesInput[]
    NOT?: AgendaScalarWhereWithAggregatesInput | AgendaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agenda"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Agenda">
  }

  export type AgendaDayWhereInput = {
    AND?: AgendaDayWhereInput | AgendaDayWhereInput[]
    OR?: AgendaDayWhereInput[]
    NOT?: AgendaDayWhereInput | AgendaDayWhereInput[]
    id?: StringFilter<"AgendaDay"> | string
    createdAt?: DateTimeFilter<"AgendaDay"> | Date | string
    date?: DateTimeFilter<"AgendaDay"> | Date | string
    dayNumber?: BigIntFilter<"AgendaDay"> | bigint | number
    name?: StringFilter<"AgendaDay"> | string
    projectId?: StringFilter<"AgendaDay"> | string
    updatedAt?: DateTimeFilter<"AgendaDay"> | Date | string
  }

  export type AgendaDayOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaDayWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaDayWhereInput | AgendaDayWhereInput[]
    OR?: AgendaDayWhereInput[]
    NOT?: AgendaDayWhereInput | AgendaDayWhereInput[]
    createdAt?: DateTimeFilter<"AgendaDay"> | Date | string
    date?: DateTimeFilter<"AgendaDay"> | Date | string
    dayNumber?: BigIntFilter<"AgendaDay"> | bigint | number
    name?: StringFilter<"AgendaDay"> | string
    projectId?: StringFilter<"AgendaDay"> | string
    updatedAt?: DateTimeFilter<"AgendaDay"> | Date | string
  }, "id">

  export type AgendaDayOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
    _count?: AgendaDayCountOrderByAggregateInput
    _avg?: AgendaDayAvgOrderByAggregateInput
    _max?: AgendaDayMaxOrderByAggregateInput
    _min?: AgendaDayMinOrderByAggregateInput
    _sum?: AgendaDaySumOrderByAggregateInput
  }

  export type AgendaDayScalarWhereWithAggregatesInput = {
    AND?: AgendaDayScalarWhereWithAggregatesInput | AgendaDayScalarWhereWithAggregatesInput[]
    OR?: AgendaDayScalarWhereWithAggregatesInput[]
    NOT?: AgendaDayScalarWhereWithAggregatesInput | AgendaDayScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaDay"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
    date?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
    dayNumber?: BigIntWithAggregatesFilter<"AgendaDay"> | bigint | number
    name?: StringWithAggregatesFilter<"AgendaDay"> | string
    projectId?: StringWithAggregatesFilter<"AgendaDay"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaDay"> | Date | string
  }

  export type AgendaItemWhereInput = {
    AND?: AgendaItemWhereInput | AgendaItemWhereInput[]
    OR?: AgendaItemWhereInput[]
    NOT?: AgendaItemWhereInput | AgendaItemWhereInput[]
    id?: StringFilter<"AgendaItem"> | string
    createdAt?: DateTimeFilter<"AgendaItem"> | Date | string
    description?: StringFilter<"AgendaItem"> | string
    endTime?: StringFilter<"AgendaItem"> | string
    sessionId?: StringFilter<"AgendaItem"> | string
    startTime?: StringFilter<"AgendaItem"> | string
    title?: StringFilter<"AgendaItem"> | string
    type?: StringFilter<"AgendaItem"> | string
    updatedAt?: DateTimeFilter<"AgendaItem"> | Date | string
  }

  export type AgendaItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    endTime?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaItemWhereInput | AgendaItemWhereInput[]
    OR?: AgendaItemWhereInput[]
    NOT?: AgendaItemWhereInput | AgendaItemWhereInput[]
    createdAt?: DateTimeFilter<"AgendaItem"> | Date | string
    description?: StringFilter<"AgendaItem"> | string
    endTime?: StringFilter<"AgendaItem"> | string
    sessionId?: StringFilter<"AgendaItem"> | string
    startTime?: StringFilter<"AgendaItem"> | string
    title?: StringFilter<"AgendaItem"> | string
    type?: StringFilter<"AgendaItem"> | string
    updatedAt?: DateTimeFilter<"AgendaItem"> | Date | string
  }, "id">

  export type AgendaItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    endTime?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    _count?: AgendaItemCountOrderByAggregateInput
    _max?: AgendaItemMaxOrderByAggregateInput
    _min?: AgendaItemMinOrderByAggregateInput
  }

  export type AgendaItemScalarWhereWithAggregatesInput = {
    AND?: AgendaItemScalarWhereWithAggregatesInput | AgendaItemScalarWhereWithAggregatesInput[]
    OR?: AgendaItemScalarWhereWithAggregatesInput[]
    NOT?: AgendaItemScalarWhereWithAggregatesInput | AgendaItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgendaItem"> | Date | string
    description?: StringWithAggregatesFilter<"AgendaItem"> | string
    endTime?: StringWithAggregatesFilter<"AgendaItem"> | string
    sessionId?: StringWithAggregatesFilter<"AgendaItem"> | string
    startTime?: StringWithAggregatesFilter<"AgendaItem"> | string
    title?: StringWithAggregatesFilter<"AgendaItem"> | string
    type?: StringWithAggregatesFilter<"AgendaItem"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaItem"> | Date | string
  }

  export type AgendaItemSpeakerWhereInput = {
    AND?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    OR?: AgendaItemSpeakerWhereInput[]
    NOT?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    id?: StringFilter<"AgendaItemSpeaker"> | string
    agendaItemId?: JsonNullableFilter<"AgendaItemSpeaker">
    speakerId?: JsonNullableFilter<"AgendaItemSpeaker">
  }

  export type AgendaItemSpeakerOrderByWithRelationInput = {
    id?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
  }

  export type AgendaItemSpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agendaItemId_speakerId?: AgendaItemSpeakerAgendaItemIdSpeakerIdCompoundUniqueInput
    AND?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    OR?: AgendaItemSpeakerWhereInput[]
    NOT?: AgendaItemSpeakerWhereInput | AgendaItemSpeakerWhereInput[]
    agendaItemId?: JsonNullableFilter<"AgendaItemSpeaker">
    speakerId?: JsonNullableFilter<"AgendaItemSpeaker">
  }, "id" | "agendaItemId_speakerId">

  export type AgendaItemSpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
    _count?: AgendaItemSpeakerCountOrderByAggregateInput
    _max?: AgendaItemSpeakerMaxOrderByAggregateInput
    _min?: AgendaItemSpeakerMinOrderByAggregateInput
  }

  export type AgendaItemSpeakerScalarWhereWithAggregatesInput = {
    AND?: AgendaItemSpeakerScalarWhereWithAggregatesInput | AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    OR?: AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    NOT?: AgendaItemSpeakerScalarWhereWithAggregatesInput | AgendaItemSpeakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaItemSpeaker"> | string
    agendaItemId?: JsonNullableWithAggregatesFilter<"AgendaItemSpeaker">
    speakerId?: JsonNullableWithAggregatesFilter<"AgendaItemSpeaker">
  }

  export type AgendaSessionWhereInput = {
    AND?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    OR?: AgendaSessionWhereInput[]
    NOT?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    id?: StringFilter<"AgendaSession"> | string
    color?: StringFilter<"AgendaSession"> | string
    createdAt?: DateTimeFilter<"AgendaSession"> | Date | string
    dayId?: StringFilter<"AgendaSession"> | string
    endTime?: StringFilter<"AgendaSession"> | string
    startTime?: StringFilter<"AgendaSession"> | string
    title?: StringFilter<"AgendaSession"> | string
    updatedAt?: DateTimeFilter<"AgendaSession"> | Date | string
    venue?: StringFilter<"AgendaSession"> | string
  }

  export type AgendaSessionOrderByWithRelationInput = {
    id?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    dayId?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
  }

  export type AgendaSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    OR?: AgendaSessionWhereInput[]
    NOT?: AgendaSessionWhereInput | AgendaSessionWhereInput[]
    color?: StringFilter<"AgendaSession"> | string
    createdAt?: DateTimeFilter<"AgendaSession"> | Date | string
    dayId?: StringFilter<"AgendaSession"> | string
    endTime?: StringFilter<"AgendaSession"> | string
    startTime?: StringFilter<"AgendaSession"> | string
    title?: StringFilter<"AgendaSession"> | string
    updatedAt?: DateTimeFilter<"AgendaSession"> | Date | string
    venue?: StringFilter<"AgendaSession"> | string
  }, "id">

  export type AgendaSessionOrderByWithAggregationInput = {
    id?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    dayId?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    _count?: AgendaSessionCountOrderByAggregateInput
    _max?: AgendaSessionMaxOrderByAggregateInput
    _min?: AgendaSessionMinOrderByAggregateInput
  }

  export type AgendaSessionScalarWhereWithAggregatesInput = {
    AND?: AgendaSessionScalarWhereWithAggregatesInput | AgendaSessionScalarWhereWithAggregatesInput[]
    OR?: AgendaSessionScalarWhereWithAggregatesInput[]
    NOT?: AgendaSessionScalarWhereWithAggregatesInput | AgendaSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgendaSession"> | string
    color?: StringWithAggregatesFilter<"AgendaSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgendaSession"> | Date | string
    dayId?: StringWithAggregatesFilter<"AgendaSession"> | string
    endTime?: StringWithAggregatesFilter<"AgendaSession"> | string
    startTime?: StringWithAggregatesFilter<"AgendaSession"> | string
    title?: StringWithAggregatesFilter<"AgendaSession"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgendaSession"> | Date | string
    venue?: StringWithAggregatesFilter<"AgendaSession"> | string
  }

  export type AttendeeWhereInput = {
    AND?: AttendeeWhereInput | AttendeeWhereInput[]
    OR?: AttendeeWhereInput[]
    NOT?: AttendeeWhereInput | AttendeeWhereInput[]
    id?: StringFilter<"Attendee"> | string
    checkedIn?: BoolFilter<"Attendee"> | boolean
    checkinTime?: DateTimeFilter<"Attendee"> | Date | string
    company?: StringFilter<"Attendee"> | string
    createdAt?: DateTimeFilter<"Attendee"> | Date | string
    email?: StringFilter<"Attendee"> | string
    jobTitle?: StringFilter<"Attendee"> | string
    name?: StringFilter<"Attendee"> | string
    phone?: StringFilter<"Attendee"> | string
    projectId?: StringFilter<"Attendee"> | string
    updatedAt?: DateTimeFilter<"Attendee"> | Date | string
  }

  export type AttendeeOrderByWithRelationInput = {
    id?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendeeWhereInput | AttendeeWhereInput[]
    OR?: AttendeeWhereInput[]
    NOT?: AttendeeWhereInput | AttendeeWhereInput[]
    checkedIn?: BoolFilter<"Attendee"> | boolean
    checkinTime?: DateTimeFilter<"Attendee"> | Date | string
    company?: StringFilter<"Attendee"> | string
    createdAt?: DateTimeFilter<"Attendee"> | Date | string
    email?: StringFilter<"Attendee"> | string
    jobTitle?: StringFilter<"Attendee"> | string
    name?: StringFilter<"Attendee"> | string
    phone?: StringFilter<"Attendee"> | string
    projectId?: StringFilter<"Attendee"> | string
    updatedAt?: DateTimeFilter<"Attendee"> | Date | string
  }, "id">

  export type AttendeeOrderByWithAggregationInput = {
    id?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendeeCountOrderByAggregateInput
    _max?: AttendeeMaxOrderByAggregateInput
    _min?: AttendeeMinOrderByAggregateInput
  }

  export type AttendeeScalarWhereWithAggregatesInput = {
    AND?: AttendeeScalarWhereWithAggregatesInput | AttendeeScalarWhereWithAggregatesInput[]
    OR?: AttendeeScalarWhereWithAggregatesInput[]
    NOT?: AttendeeScalarWhereWithAggregatesInput | AttendeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendee"> | string
    checkedIn?: BoolWithAggregatesFilter<"Attendee"> | boolean
    checkinTime?: DateTimeWithAggregatesFilter<"Attendee"> | Date | string
    company?: StringWithAggregatesFilter<"Attendee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendee"> | Date | string
    email?: StringWithAggregatesFilter<"Attendee"> | string
    jobTitle?: StringWithAggregatesFilter<"Attendee"> | string
    name?: StringWithAggregatesFilter<"Attendee"> | string
    phone?: StringWithAggregatesFilter<"Attendee"> | string
    projectId?: StringWithAggregatesFilter<"Attendee"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendee"> | Date | string
  }

  export type AttendeesWhereInput = {
    AND?: AttendeesWhereInput | AttendeesWhereInput[]
    OR?: AttendeesWhereInput[]
    NOT?: AttendeesWhereInput | AttendeesWhereInput[]
    id?: StringFilter<"Attendees"> | string
    projectId?: JsonNullableFilter<"Attendees">
  }

  export type AttendeesOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type AttendeesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: AttendeesWhereInput | AttendeesWhereInput[]
    OR?: AttendeesWhereInput[]
    NOT?: AttendeesWhereInput | AttendeesWhereInput[]
  }, "id" | "projectId">

  export type AttendeesOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: AttendeesCountOrderByAggregateInput
    _max?: AttendeesMaxOrderByAggregateInput
    _min?: AttendeesMinOrderByAggregateInput
  }

  export type AttendeesScalarWhereWithAggregatesInput = {
    AND?: AttendeesScalarWhereWithAggregatesInput | AttendeesScalarWhereWithAggregatesInput[]
    OR?: AttendeesScalarWhereWithAggregatesInput[]
    NOT?: AttendeesScalarWhereWithAggregatesInput | AttendeesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendees"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Attendees">
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
  }

  export type ContactRequestWhereInput = {
    AND?: ContactRequestWhereInput | ContactRequestWhereInput[]
    OR?: ContactRequestWhereInput[]
    NOT?: ContactRequestWhereInput | ContactRequestWhereInput[]
    id?: StringFilter<"ContactRequest"> | string
  }

  export type ContactRequestOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type ContactRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactRequestWhereInput | ContactRequestWhereInput[]
    OR?: ContactRequestWhereInput[]
    NOT?: ContactRequestWhereInput | ContactRequestWhereInput[]
  }, "id">

  export type ContactRequestOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ContactRequestCountOrderByAggregateInput
    _max?: ContactRequestMaxOrderByAggregateInput
    _min?: ContactRequestMinOrderByAggregateInput
  }

  export type ContactRequestScalarWhereWithAggregatesInput = {
    AND?: ContactRequestScalarWhereWithAggregatesInput | ContactRequestScalarWhereWithAggregatesInput[]
    OR?: ContactRequestScalarWhereWithAggregatesInput[]
    NOT?: ContactRequestScalarWhereWithAggregatesInput | ContactRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactRequest"> | string
  }

  export type DelegateWhereInput = {
    AND?: DelegateWhereInput | DelegateWhereInput[]
    OR?: DelegateWhereInput[]
    NOT?: DelegateWhereInput | DelegateWhereInput[]
    id?: StringFilter<"Delegate"> | string
    address?: StringFilter<"Delegate"> | string
    booth?: StringFilter<"Delegate"> | string
    company?: StringFilter<"Delegate"> | string
    createdAt?: DateTimeFilter<"Delegate"> | Date | string
    description?: StringFilter<"Delegate"> | string
    email?: StringFilter<"Delegate"> | string
    featured?: BoolFilter<"Delegate"> | boolean
    image?: StringFilter<"Delegate"> | string
    jobTitle?: StringFilter<"Delegate"> | string
    name?: StringFilter<"Delegate"> | string
    phone?: StringFilter<"Delegate"> | string
    priority?: BigIntFilter<"Delegate"> | bigint | number
    projectId?: StringFilter<"Delegate"> | string
    status?: StringFilter<"Delegate"> | string
    type?: StringFilter<"Delegate"> | string
    updatedAt?: DateTimeFilter<"Delegate"> | Date | string
  }

  export type DelegateOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    email?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelegateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DelegateWhereInput | DelegateWhereInput[]
    OR?: DelegateWhereInput[]
    NOT?: DelegateWhereInput | DelegateWhereInput[]
    address?: StringFilter<"Delegate"> | string
    booth?: StringFilter<"Delegate"> | string
    company?: StringFilter<"Delegate"> | string
    createdAt?: DateTimeFilter<"Delegate"> | Date | string
    description?: StringFilter<"Delegate"> | string
    email?: StringFilter<"Delegate"> | string
    featured?: BoolFilter<"Delegate"> | boolean
    image?: StringFilter<"Delegate"> | string
    jobTitle?: StringFilter<"Delegate"> | string
    name?: StringFilter<"Delegate"> | string
    phone?: StringFilter<"Delegate"> | string
    priority?: BigIntFilter<"Delegate"> | bigint | number
    projectId?: StringFilter<"Delegate"> | string
    status?: StringFilter<"Delegate"> | string
    type?: StringFilter<"Delegate"> | string
    updatedAt?: DateTimeFilter<"Delegate"> | Date | string
  }, "id">

  export type DelegateOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    email?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    _count?: DelegateCountOrderByAggregateInput
    _avg?: DelegateAvgOrderByAggregateInput
    _max?: DelegateMaxOrderByAggregateInput
    _min?: DelegateMinOrderByAggregateInput
    _sum?: DelegateSumOrderByAggregateInput
  }

  export type DelegateScalarWhereWithAggregatesInput = {
    AND?: DelegateScalarWhereWithAggregatesInput | DelegateScalarWhereWithAggregatesInput[]
    OR?: DelegateScalarWhereWithAggregatesInput[]
    NOT?: DelegateScalarWhereWithAggregatesInput | DelegateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delegate"> | string
    address?: StringWithAggregatesFilter<"Delegate"> | string
    booth?: StringWithAggregatesFilter<"Delegate"> | string
    company?: StringWithAggregatesFilter<"Delegate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Delegate"> | Date | string
    description?: StringWithAggregatesFilter<"Delegate"> | string
    email?: StringWithAggregatesFilter<"Delegate"> | string
    featured?: BoolWithAggregatesFilter<"Delegate"> | boolean
    image?: StringWithAggregatesFilter<"Delegate"> | string
    jobTitle?: StringWithAggregatesFilter<"Delegate"> | string
    name?: StringWithAggregatesFilter<"Delegate"> | string
    phone?: StringWithAggregatesFilter<"Delegate"> | string
    priority?: BigIntWithAggregatesFilter<"Delegate"> | bigint | number
    projectId?: StringWithAggregatesFilter<"Delegate"> | string
    status?: StringWithAggregatesFilter<"Delegate"> | string
    type?: StringWithAggregatesFilter<"Delegate"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delegate"> | Date | string
  }

  export type DelegatesWhereInput = {
    AND?: DelegatesWhereInput | DelegatesWhereInput[]
    OR?: DelegatesWhereInput[]
    NOT?: DelegatesWhereInput | DelegatesWhereInput[]
    id?: StringFilter<"Delegates"> | string
    projectId?: JsonNullableFilter<"Delegates">
  }

  export type DelegatesOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type DelegatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: DelegatesWhereInput | DelegatesWhereInput[]
    OR?: DelegatesWhereInput[]
    NOT?: DelegatesWhereInput | DelegatesWhereInput[]
  }, "id" | "projectId">

  export type DelegatesOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: DelegatesCountOrderByAggregateInput
    _max?: DelegatesMaxOrderByAggregateInput
    _min?: DelegatesMinOrderByAggregateInput
  }

  export type DelegatesScalarWhereWithAggregatesInput = {
    AND?: DelegatesScalarWhereWithAggregatesInput | DelegatesScalarWhereWithAggregatesInput[]
    OR?: DelegatesScalarWhereWithAggregatesInput[]
    NOT?: DelegatesScalarWhereWithAggregatesInput | DelegatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delegates"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Delegates">
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    code?: JsonNullableFilter<"Discount">
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: InputJsonValue
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
  }, "id" | "code">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    code?: JsonNullableWithAggregatesFilter<"Discount">
  }

  export type EnquiryWhereInput = {
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    id?: StringFilter<"Enquiry"> | string
  }

  export type EnquiryOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type EnquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
  }, "id">

  export type EnquiryOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: EnquiryCountOrderByAggregateInput
    _max?: EnquiryMaxOrderByAggregateInput
    _min?: EnquiryMinOrderByAggregateInput
  }

  export type EnquiryScalarWhereWithAggregatesInput = {
    AND?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    OR?: EnquiryScalarWhereWithAggregatesInput[]
    NOT?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enquiry"> | string
  }

  export type ExhibitorWhereInput = {
    AND?: ExhibitorWhereInput | ExhibitorWhereInput[]
    OR?: ExhibitorWhereInput[]
    NOT?: ExhibitorWhereInput | ExhibitorWhereInput[]
    id?: StringFilter<"Exhibitor"> | string
    boothNumber?: StringFilter<"Exhibitor"> | string
    category?: StringFilter<"Exhibitor"> | string
    createdAt?: DateTimeFilter<"Exhibitor"> | Date | string
    image?: StringFilter<"Exhibitor"> | string
    name?: StringFilter<"Exhibitor"> | string
    projectId?: StringFilter<"Exhibitor"> | string
    size?: StringFilter<"Exhibitor"> | string
    status?: StringFilter<"Exhibitor"> | string
    updatedAt?: DateTimeFilter<"Exhibitor"> | Date | string
  }

  export type ExhibitorOrderByWithRelationInput = {
    id?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExhibitorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExhibitorWhereInput | ExhibitorWhereInput[]
    OR?: ExhibitorWhereInput[]
    NOT?: ExhibitorWhereInput | ExhibitorWhereInput[]
    boothNumber?: StringFilter<"Exhibitor"> | string
    category?: StringFilter<"Exhibitor"> | string
    createdAt?: DateTimeFilter<"Exhibitor"> | Date | string
    image?: StringFilter<"Exhibitor"> | string
    name?: StringFilter<"Exhibitor"> | string
    projectId?: StringFilter<"Exhibitor"> | string
    size?: StringFilter<"Exhibitor"> | string
    status?: StringFilter<"Exhibitor"> | string
    updatedAt?: DateTimeFilter<"Exhibitor"> | Date | string
  }, "id">

  export type ExhibitorOrderByWithAggregationInput = {
    id?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    _count?: ExhibitorCountOrderByAggregateInput
    _max?: ExhibitorMaxOrderByAggregateInput
    _min?: ExhibitorMinOrderByAggregateInput
  }

  export type ExhibitorScalarWhereWithAggregatesInput = {
    AND?: ExhibitorScalarWhereWithAggregatesInput | ExhibitorScalarWhereWithAggregatesInput[]
    OR?: ExhibitorScalarWhereWithAggregatesInput[]
    NOT?: ExhibitorScalarWhereWithAggregatesInput | ExhibitorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exhibitor"> | string
    boothNumber?: StringWithAggregatesFilter<"Exhibitor"> | string
    category?: StringWithAggregatesFilter<"Exhibitor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Exhibitor"> | Date | string
    image?: StringWithAggregatesFilter<"Exhibitor"> | string
    name?: StringWithAggregatesFilter<"Exhibitor"> | string
    projectId?: StringWithAggregatesFilter<"Exhibitor"> | string
    size?: StringWithAggregatesFilter<"Exhibitor"> | string
    status?: StringWithAggregatesFilter<"Exhibitor"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exhibitor"> | Date | string
  }

  export type ExhibitorsWhereInput = {
    AND?: ExhibitorsWhereInput | ExhibitorsWhereInput[]
    OR?: ExhibitorsWhereInput[]
    NOT?: ExhibitorsWhereInput | ExhibitorsWhereInput[]
    id?: StringFilter<"Exhibitors"> | string
    projectId?: JsonNullableFilter<"Exhibitors">
  }

  export type ExhibitorsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ExhibitorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: ExhibitorsWhereInput | ExhibitorsWhereInput[]
    OR?: ExhibitorsWhereInput[]
    NOT?: ExhibitorsWhereInput | ExhibitorsWhereInput[]
  }, "id" | "projectId">

  export type ExhibitorsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: ExhibitorsCountOrderByAggregateInput
    _max?: ExhibitorsMaxOrderByAggregateInput
    _min?: ExhibitorsMinOrderByAggregateInput
  }

  export type ExhibitorsScalarWhereWithAggregatesInput = {
    AND?: ExhibitorsScalarWhereWithAggregatesInput | ExhibitorsScalarWhereWithAggregatesInput[]
    OR?: ExhibitorsScalarWhereWithAggregatesInput[]
    NOT?: ExhibitorsScalarWhereWithAggregatesInput | ExhibitorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exhibitors"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Exhibitors">
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
  }

  export type MarketingWhereInput = {
    AND?: MarketingWhereInput | MarketingWhereInput[]
    OR?: MarketingWhereInput[]
    NOT?: MarketingWhereInput | MarketingWhereInput[]
    id?: StringFilter<"Marketing"> | string
    projectId?: JsonNullableFilter<"Marketing">
  }

  export type MarketingOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type MarketingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: MarketingWhereInput | MarketingWhereInput[]
    OR?: MarketingWhereInput[]
    NOT?: MarketingWhereInput | MarketingWhereInput[]
  }, "id" | "projectId">

  export type MarketingOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: MarketingCountOrderByAggregateInput
    _max?: MarketingMaxOrderByAggregateInput
    _min?: MarketingMinOrderByAggregateInput
  }

  export type MarketingScalarWhereWithAggregatesInput = {
    AND?: MarketingScalarWhereWithAggregatesInput | MarketingScalarWhereWithAggregatesInput[]
    OR?: MarketingScalarWhereWithAggregatesInput[]
    NOT?: MarketingScalarWhereWithAggregatesInput | MarketingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Marketing"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Marketing">
  }

  export type MarketingCampaignWhereInput = {
    AND?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    OR?: MarketingCampaignWhereInput[]
    NOT?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    id?: StringFilter<"MarketingCampaign"> | string
  }

  export type MarketingCampaignOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type MarketingCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
    OR?: MarketingCampaignWhereInput[]
    NOT?: MarketingCampaignWhereInput | MarketingCampaignWhereInput[]
  }, "id">

  export type MarketingCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: MarketingCampaignCountOrderByAggregateInput
    _max?: MarketingCampaignMaxOrderByAggregateInput
    _min?: MarketingCampaignMinOrderByAggregateInput
  }

  export type MarketingCampaignScalarWhereWithAggregatesInput = {
    AND?: MarketingCampaignScalarWhereWithAggregatesInput | MarketingCampaignScalarWhereWithAggregatesInput[]
    OR?: MarketingCampaignScalarWhereWithAggregatesInput[]
    NOT?: MarketingCampaignScalarWhereWithAggregatesInput | MarketingCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingCampaign"> | string
  }

  export type MediaPartnerWhereInput = {
    AND?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    OR?: MediaPartnerWhereInput[]
    NOT?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    id?: StringFilter<"MediaPartner"> | string
    createdAt?: DateTimeFilter<"MediaPartner"> | Date | string
    image?: StringFilter<"MediaPartner"> | string
    name?: StringFilter<"MediaPartner"> | string
    priority?: BigIntFilter<"MediaPartner"> | bigint | number
    projectId?: StringFilter<"MediaPartner"> | string
    type?: StringFilter<"MediaPartner"> | string
    updatedAt?: DateTimeFilter<"MediaPartner"> | Date | string
    website?: StringFilter<"MediaPartner"> | string
  }

  export type MediaPartnerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type MediaPartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    OR?: MediaPartnerWhereInput[]
    NOT?: MediaPartnerWhereInput | MediaPartnerWhereInput[]
    createdAt?: DateTimeFilter<"MediaPartner"> | Date | string
    image?: StringFilter<"MediaPartner"> | string
    name?: StringFilter<"MediaPartner"> | string
    priority?: BigIntFilter<"MediaPartner"> | bigint | number
    projectId?: StringFilter<"MediaPartner"> | string
    type?: StringFilter<"MediaPartner"> | string
    updatedAt?: DateTimeFilter<"MediaPartner"> | Date | string
    website?: StringFilter<"MediaPartner"> | string
  }, "id">

  export type MediaPartnerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
    _count?: MediaPartnerCountOrderByAggregateInput
    _avg?: MediaPartnerAvgOrderByAggregateInput
    _max?: MediaPartnerMaxOrderByAggregateInput
    _min?: MediaPartnerMinOrderByAggregateInput
    _sum?: MediaPartnerSumOrderByAggregateInput
  }

  export type MediaPartnerScalarWhereWithAggregatesInput = {
    AND?: MediaPartnerScalarWhereWithAggregatesInput | MediaPartnerScalarWhereWithAggregatesInput[]
    OR?: MediaPartnerScalarWhereWithAggregatesInput[]
    NOT?: MediaPartnerScalarWhereWithAggregatesInput | MediaPartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MediaPartner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MediaPartner"> | Date | string
    image?: StringWithAggregatesFilter<"MediaPartner"> | string
    name?: StringWithAggregatesFilter<"MediaPartner"> | string
    priority?: BigIntWithAggregatesFilter<"MediaPartner"> | bigint | number
    projectId?: StringWithAggregatesFilter<"MediaPartner"> | string
    type?: StringWithAggregatesFilter<"MediaPartner"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaPartner"> | Date | string
    website?: StringWithAggregatesFilter<"MediaPartner"> | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
  }, "id">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: PackageCountOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    contribution?: StringFilter<"Partner"> | string
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    image?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    projectId?: StringFilter<"Partner"> | string
    status?: StringFilter<"Partner"> | string
    type?: StringFilter<"Partner"> | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    website?: StringFilter<"Partner"> | string
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    contribution?: StringFilter<"Partner"> | string
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    image?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    projectId?: StringFilter<"Partner"> | string
    status?: StringFilter<"Partner"> | string
    type?: StringFilter<"Partner"> | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    website?: StringFilter<"Partner"> | string
  }, "id">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    contribution?: StringWithAggregatesFilter<"Partner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    image?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    projectId?: StringWithAggregatesFilter<"Partner"> | string
    status?: StringWithAggregatesFilter<"Partner"> | string
    type?: StringWithAggregatesFilter<"Partner"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    website?: StringWithAggregatesFilter<"Partner"> | string
  }

  export type PartnersWhereInput = {
    AND?: PartnersWhereInput | PartnersWhereInput[]
    OR?: PartnersWhereInput[]
    NOT?: PartnersWhereInput | PartnersWhereInput[]
    id?: StringFilter<"Partners"> | string
    projectId?: JsonNullableFilter<"Partners">
  }

  export type PartnersOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PartnersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: PartnersWhereInput | PartnersWhereInput[]
    OR?: PartnersWhereInput[]
    NOT?: PartnersWhereInput | PartnersWhereInput[]
  }, "id" | "projectId">

  export type PartnersOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: PartnersCountOrderByAggregateInput
    _max?: PartnersMaxOrderByAggregateInput
    _min?: PartnersMinOrderByAggregateInput
  }

  export type PartnersScalarWhereWithAggregatesInput = {
    AND?: PartnersScalarWhereWithAggregatesInput | PartnersScalarWhereWithAggregatesInput[]
    OR?: PartnersScalarWhereWithAggregatesInput[]
    NOT?: PartnersScalarWhereWithAggregatesInput | PartnersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partners"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Partners">
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    currency?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    name?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    venue?: StringFilter<"Project"> | string
    website?: StringFilter<"Project"> | string
    year?: StringFilter<"Project"> | string
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    year?: SortOrder
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    createdAt?: DateTimeFilter<"Project"> | Date | string
    currency?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    name?: StringFilter<"Project"> | string
    startDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    venue?: StringFilter<"Project"> | string
    website?: StringFilter<"Project"> | string
    year?: StringFilter<"Project"> | string
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    year?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    currency?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    name?: StringWithAggregatesFilter<"Project"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    venue?: StringWithAggregatesFilter<"Project"> | string
    website?: StringWithAggregatesFilter<"Project"> | string
    year?: StringWithAggregatesFilter<"Project"> | string
  }

  export type ProjectStatsWhereInput = {
    AND?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    OR?: ProjectStatsWhereInput[]
    NOT?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    id?: StringFilter<"ProjectStats"> | string
    createdAt?: DateTimeFilter<"ProjectStats"> | Date | string
    delegates?: BigIntFilter<"ProjectStats"> | bigint | number
    exhibitors?: BigIntFilter<"ProjectStats"> | bigint | number
    mediaPartners?: BigIntFilter<"ProjectStats"> | bigint | number
    partners?: BigIntFilter<"ProjectStats"> | bigint | number
    projectId?: StringFilter<"ProjectStats"> | string
    speakers?: BigIntFilter<"ProjectStats"> | bigint | number
    sponsors?: BigIntFilter<"ProjectStats"> | bigint | number
    updatedAt?: DateTimeFilter<"ProjectStats"> | Date | string
  }

  export type ProjectStatsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    projectId?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    OR?: ProjectStatsWhereInput[]
    NOT?: ProjectStatsWhereInput | ProjectStatsWhereInput[]
    createdAt?: DateTimeFilter<"ProjectStats"> | Date | string
    delegates?: BigIntFilter<"ProjectStats"> | bigint | number
    exhibitors?: BigIntFilter<"ProjectStats"> | bigint | number
    mediaPartners?: BigIntFilter<"ProjectStats"> | bigint | number
    partners?: BigIntFilter<"ProjectStats"> | bigint | number
    speakers?: BigIntFilter<"ProjectStats"> | bigint | number
    sponsors?: BigIntFilter<"ProjectStats"> | bigint | number
    updatedAt?: DateTimeFilter<"ProjectStats"> | Date | string
  }, "id" | "projectId">

  export type ProjectStatsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    projectId?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectStatsCountOrderByAggregateInput
    _avg?: ProjectStatsAvgOrderByAggregateInput
    _max?: ProjectStatsMaxOrderByAggregateInput
    _min?: ProjectStatsMinOrderByAggregateInput
    _sum?: ProjectStatsSumOrderByAggregateInput
  }

  export type ProjectStatsScalarWhereWithAggregatesInput = {
    AND?: ProjectStatsScalarWhereWithAggregatesInput | ProjectStatsScalarWhereWithAggregatesInput[]
    OR?: ProjectStatsScalarWhereWithAggregatesInput[]
    NOT?: ProjectStatsScalarWhereWithAggregatesInput | ProjectStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectStats"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectStats"> | Date | string
    delegates?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    exhibitors?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    mediaPartners?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    partners?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    projectId?: StringWithAggregatesFilter<"ProjectStats"> | string
    speakers?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    sponsors?: BigIntWithAggregatesFilter<"ProjectStats"> | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectStats"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
  }

  export type SpeakerWhereInput = {
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    id?: StringFilter<"Speaker"> | string
  }

  export type SpeakerOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type SpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
  }, "id">

  export type SpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SpeakerCountOrderByAggregateInput
    _max?: SpeakerMaxOrderByAggregateInput
    _min?: SpeakerMinOrderByAggregateInput
  }

  export type SpeakerScalarWhereWithAggregatesInput = {
    AND?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    OR?: SpeakerScalarWhereWithAggregatesInput[]
    NOT?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Speaker"> | string
  }

  export type SpeakerSessionWhereInput = {
    AND?: SpeakerSessionWhereInput | SpeakerSessionWhereInput[]
    OR?: SpeakerSessionWhereInput[]
    NOT?: SpeakerSessionWhereInput | SpeakerSessionWhereInput[]
    id?: StringFilter<"SpeakerSession"> | string
    sessionId?: JsonNullableFilter<"SpeakerSession">
    speakerId?: JsonNullableFilter<"SpeakerSession">
  }

  export type SpeakerSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SpeakerSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    speakerId_sessionId?: SpeakerSessionSpeakerIdSessionIdCompoundUniqueInput
    AND?: SpeakerSessionWhereInput | SpeakerSessionWhereInput[]
    OR?: SpeakerSessionWhereInput[]
    NOT?: SpeakerSessionWhereInput | SpeakerSessionWhereInput[]
    sessionId?: JsonNullableFilter<"SpeakerSession">
    speakerId?: JsonNullableFilter<"SpeakerSession">
  }, "id" | "speakerId_sessionId">

  export type SpeakerSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    speakerId?: SortOrder
    _count?: SpeakerSessionCountOrderByAggregateInput
    _max?: SpeakerSessionMaxOrderByAggregateInput
    _min?: SpeakerSessionMinOrderByAggregateInput
  }

  export type SpeakerSessionScalarWhereWithAggregatesInput = {
    AND?: SpeakerSessionScalarWhereWithAggregatesInput | SpeakerSessionScalarWhereWithAggregatesInput[]
    OR?: SpeakerSessionScalarWhereWithAggregatesInput[]
    NOT?: SpeakerSessionScalarWhereWithAggregatesInput | SpeakerSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpeakerSession"> | string
    sessionId?: JsonNullableWithAggregatesFilter<"SpeakerSession">
    speakerId?: JsonNullableWithAggregatesFilter<"SpeakerSession">
  }

  export type SpeakersWhereInput = {
    AND?: SpeakersWhereInput | SpeakersWhereInput[]
    OR?: SpeakersWhereInput[]
    NOT?: SpeakersWhereInput | SpeakersWhereInput[]
    id?: StringFilter<"Speakers"> | string
    projectId?: JsonNullableFilter<"Speakers">
  }

  export type SpeakersOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SpeakersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: SpeakersWhereInput | SpeakersWhereInput[]
    OR?: SpeakersWhereInput[]
    NOT?: SpeakersWhereInput | SpeakersWhereInput[]
  }, "id" | "projectId">

  export type SpeakersOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: SpeakersCountOrderByAggregateInput
    _max?: SpeakersMaxOrderByAggregateInput
    _min?: SpeakersMinOrderByAggregateInput
  }

  export type SpeakersScalarWhereWithAggregatesInput = {
    AND?: SpeakersScalarWhereWithAggregatesInput | SpeakersScalarWhereWithAggregatesInput[]
    OR?: SpeakersScalarWhereWithAggregatesInput[]
    NOT?: SpeakersScalarWhereWithAggregatesInput | SpeakersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Speakers"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Speakers">
  }

  export type SponsorWhereInput = {
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
    id?: StringFilter<"Sponsor"> | string
  }

  export type SponsorOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type SponsorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SponsorWhereInput | SponsorWhereInput[]
    OR?: SponsorWhereInput[]
    NOT?: SponsorWhereInput | SponsorWhereInput[]
  }, "id">

  export type SponsorOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SponsorCountOrderByAggregateInput
    _max?: SponsorMaxOrderByAggregateInput
    _min?: SponsorMinOrderByAggregateInput
  }

  export type SponsorScalarWhereWithAggregatesInput = {
    AND?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    OR?: SponsorScalarWhereWithAggregatesInput[]
    NOT?: SponsorScalarWhereWithAggregatesInput | SponsorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sponsor"> | string
  }

  export type SponsorsWhereInput = {
    AND?: SponsorsWhereInput | SponsorsWhereInput[]
    OR?: SponsorsWhereInput[]
    NOT?: SponsorsWhereInput | SponsorsWhereInput[]
    id?: StringFilter<"Sponsors"> | string
    projectId?: JsonNullableFilter<"Sponsors">
  }

  export type SponsorsOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SponsorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: SponsorsWhereInput | SponsorsWhereInput[]
    OR?: SponsorsWhereInput[]
    NOT?: SponsorsWhereInput | SponsorsWhereInput[]
  }, "id" | "projectId">

  export type SponsorsOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: SponsorsCountOrderByAggregateInput
    _max?: SponsorsMaxOrderByAggregateInput
    _min?: SponsorsMinOrderByAggregateInput
  }

  export type SponsorsScalarWhereWithAggregatesInput = {
    AND?: SponsorsScalarWhereWithAggregatesInput | SponsorsScalarWhereWithAggregatesInput[]
    OR?: SponsorsScalarWhereWithAggregatesInput[]
    NOT?: SponsorsScalarWhereWithAggregatesInput | SponsorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sponsors"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Sponsors">
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
  }

  export type TicketingWhereInput = {
    AND?: TicketingWhereInput | TicketingWhereInput[]
    OR?: TicketingWhereInput[]
    NOT?: TicketingWhereInput | TicketingWhereInput[]
    id?: StringFilter<"Ticketing"> | string
    projectId?: JsonNullableFilter<"Ticketing">
  }

  export type TicketingOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TicketingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: InputJsonValue
    AND?: TicketingWhereInput | TicketingWhereInput[]
    OR?: TicketingWhereInput[]
    NOT?: TicketingWhereInput | TicketingWhereInput[]
  }, "id" | "projectId">

  export type TicketingOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    _count?: TicketingCountOrderByAggregateInput
    _max?: TicketingMaxOrderByAggregateInput
    _min?: TicketingMinOrderByAggregateInput
  }

  export type TicketingScalarWhereWithAggregatesInput = {
    AND?: TicketingScalarWhereWithAggregatesInput | TicketingScalarWhereWithAggregatesInput[]
    OR?: TicketingScalarWhereWithAggregatesInput[]
    NOT?: TicketingScalarWhereWithAggregatesInput | TicketingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticketing"> | string
    projectId?: JsonNullableWithAggregatesFilter<"Ticketing">
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: JsonNullableFilter<"User">
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: InputJsonValue
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: JsonNullableWithAggregatesFilter<"User">
  }

  export type UtmDataWhereInput = {
    AND?: UtmDataWhereInput | UtmDataWhereInput[]
    OR?: UtmDataWhereInput[]
    NOT?: UtmDataWhereInput | UtmDataWhereInput[]
    id?: StringFilter<"UtmData"> | string
    campaign?: StringFilter<"UtmData"> | string
    content?: StringFilter<"UtmData"> | string
    conversions?: BigIntFilter<"UtmData"> | bigint | number
    createdAt?: DateTimeFilter<"UtmData"> | Date | string
    medium?: StringFilter<"UtmData"> | string
    name?: StringFilter<"UtmData"> | string
    projectId?: StringFilter<"UtmData"> | string
    source?: StringFilter<"UtmData"> | string
    term?: StringFilter<"UtmData"> | string
    updatedAt?: DateTimeFilter<"UtmData"> | Date | string
    visits?: BigIntFilter<"UtmData"> | bigint | number
    websiteUrl?: StringFilter<"UtmData"> | string
  }

  export type UtmDataOrderByWithRelationInput = {
    id?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    medium?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    source?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    websiteUrl?: SortOrder
  }

  export type UtmDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UtmDataWhereInput | UtmDataWhereInput[]
    OR?: UtmDataWhereInput[]
    NOT?: UtmDataWhereInput | UtmDataWhereInput[]
    campaign?: StringFilter<"UtmData"> | string
    content?: StringFilter<"UtmData"> | string
    conversions?: BigIntFilter<"UtmData"> | bigint | number
    createdAt?: DateTimeFilter<"UtmData"> | Date | string
    medium?: StringFilter<"UtmData"> | string
    name?: StringFilter<"UtmData"> | string
    projectId?: StringFilter<"UtmData"> | string
    source?: StringFilter<"UtmData"> | string
    term?: StringFilter<"UtmData"> | string
    updatedAt?: DateTimeFilter<"UtmData"> | Date | string
    visits?: BigIntFilter<"UtmData"> | bigint | number
    websiteUrl?: StringFilter<"UtmData"> | string
  }, "id">

  export type UtmDataOrderByWithAggregationInput = {
    id?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    medium?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    source?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    websiteUrl?: SortOrder
    _count?: UtmDataCountOrderByAggregateInput
    _avg?: UtmDataAvgOrderByAggregateInput
    _max?: UtmDataMaxOrderByAggregateInput
    _min?: UtmDataMinOrderByAggregateInput
    _sum?: UtmDataSumOrderByAggregateInput
  }

  export type UtmDataScalarWhereWithAggregatesInput = {
    AND?: UtmDataScalarWhereWithAggregatesInput | UtmDataScalarWhereWithAggregatesInput[]
    OR?: UtmDataScalarWhereWithAggregatesInput[]
    NOT?: UtmDataScalarWhereWithAggregatesInput | UtmDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UtmData"> | string
    campaign?: StringWithAggregatesFilter<"UtmData"> | string
    content?: StringWithAggregatesFilter<"UtmData"> | string
    conversions?: BigIntWithAggregatesFilter<"UtmData"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"UtmData"> | Date | string
    medium?: StringWithAggregatesFilter<"UtmData"> | string
    name?: StringWithAggregatesFilter<"UtmData"> | string
    projectId?: StringWithAggregatesFilter<"UtmData"> | string
    source?: StringWithAggregatesFilter<"UtmData"> | string
    term?: StringWithAggregatesFilter<"UtmData"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"UtmData"> | Date | string
    visits?: BigIntWithAggregatesFilter<"UtmData"> | bigint | number
    websiteUrl?: StringWithAggregatesFilter<"UtmData"> | string
  }

  export type agendadaysWhereInput = {
    AND?: agendadaysWhereInput | agendadaysWhereInput[]
    OR?: agendadaysWhereInput[]
    NOT?: agendadaysWhereInput | agendadaysWhereInput[]
    id?: StringFilter<"agendadays"> | string
    v?: IntFilter<"agendadays"> | number
    date?: DateTimeFilter<"agendadays"> | Date | string
    dayNumber?: IntFilter<"agendadays"> | number
    name?: StringFilter<"agendadays"> | string
  }

  export type agendadaysOrderByWithRelationInput = {
    id?: SortOrder
    v?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
  }

  export type agendadaysWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: agendadaysWhereInput | agendadaysWhereInput[]
    OR?: agendadaysWhereInput[]
    NOT?: agendadaysWhereInput | agendadaysWhereInput[]
    v?: IntFilter<"agendadays"> | number
    date?: DateTimeFilter<"agendadays"> | Date | string
    dayNumber?: IntFilter<"agendadays"> | number
    name?: StringFilter<"agendadays"> | string
  }, "id">

  export type agendadaysOrderByWithAggregationInput = {
    id?: SortOrder
    v?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    _count?: agendadaysCountOrderByAggregateInput
    _avg?: agendadaysAvgOrderByAggregateInput
    _max?: agendadaysMaxOrderByAggregateInput
    _min?: agendadaysMinOrderByAggregateInput
    _sum?: agendadaysSumOrderByAggregateInput
  }

  export type agendadaysScalarWhereWithAggregatesInput = {
    AND?: agendadaysScalarWhereWithAggregatesInput | agendadaysScalarWhereWithAggregatesInput[]
    OR?: agendadaysScalarWhereWithAggregatesInput[]
    NOT?: agendadaysScalarWhereWithAggregatesInput | agendadaysScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"agendadays"> | string
    v?: IntWithAggregatesFilter<"agendadays"> | number
    date?: DateTimeWithAggregatesFilter<"agendadays"> | Date | string
    dayNumber?: IntWithAggregatesFilter<"agendadays"> | number
    name?: StringWithAggregatesFilter<"agendadays"> | string
  }

  export type agendaitemsWhereInput = {
    AND?: agendaitemsWhereInput | agendaitemsWhereInput[]
    OR?: agendaitemsWhereInput[]
    NOT?: agendaitemsWhereInput | agendaitemsWhereInput[]
    id?: StringFilter<"agendaitems"> | string
  }

  export type agendaitemsOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type agendaitemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: agendaitemsWhereInput | agendaitemsWhereInput[]
    OR?: agendaitemsWhereInput[]
    NOT?: agendaitemsWhereInput | agendaitemsWhereInput[]
  }, "id">

  export type agendaitemsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: agendaitemsCountOrderByAggregateInput
    _max?: agendaitemsMaxOrderByAggregateInput
    _min?: agendaitemsMinOrderByAggregateInput
  }

  export type agendaitemsScalarWhereWithAggregatesInput = {
    AND?: agendaitemsScalarWhereWithAggregatesInput | agendaitemsScalarWhereWithAggregatesInput[]
    OR?: agendaitemsScalarWhereWithAggregatesInput[]
    NOT?: agendaitemsScalarWhereWithAggregatesInput | agendaitemsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"agendaitems"> | string
  }

  export type agendaitemspeakersWhereInput = {
    AND?: agendaitemspeakersWhereInput | agendaitemspeakersWhereInput[]
    OR?: agendaitemspeakersWhereInput[]
    NOT?: agendaitemspeakersWhereInput | agendaitemspeakersWhereInput[]
    id?: StringFilter<"agendaitemspeakers"> | string
  }

  export type agendaitemspeakersOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type agendaitemspeakersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: agendaitemspeakersWhereInput | agendaitemspeakersWhereInput[]
    OR?: agendaitemspeakersWhereInput[]
    NOT?: agendaitemspeakersWhereInput | agendaitemspeakersWhereInput[]
  }, "id">

  export type agendaitemspeakersOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: agendaitemspeakersCountOrderByAggregateInput
    _max?: agendaitemspeakersMaxOrderByAggregateInput
    _min?: agendaitemspeakersMinOrderByAggregateInput
  }

  export type agendaitemspeakersScalarWhereWithAggregatesInput = {
    AND?: agendaitemspeakersScalarWhereWithAggregatesInput | agendaitemspeakersScalarWhereWithAggregatesInput[]
    OR?: agendaitemspeakersScalarWhereWithAggregatesInput[]
    NOT?: agendaitemspeakersScalarWhereWithAggregatesInput | agendaitemspeakersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"agendaitemspeakers"> | string
  }

  export type agendasessionsWhereInput = {
    AND?: agendasessionsWhereInput | agendasessionsWhereInput[]
    OR?: agendasessionsWhereInput[]
    NOT?: agendasessionsWhereInput | agendasessionsWhereInput[]
    id?: StringFilter<"agendasessions"> | string
  }

  export type agendasessionsOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type agendasessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: agendasessionsWhereInput | agendasessionsWhereInput[]
    OR?: agendasessionsWhereInput[]
    NOT?: agendasessionsWhereInput | agendasessionsWhereInput[]
  }, "id">

  export type agendasessionsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: agendasessionsCountOrderByAggregateInput
    _max?: agendasessionsMaxOrderByAggregateInput
    _min?: agendasessionsMinOrderByAggregateInput
  }

  export type agendasessionsScalarWhereWithAggregatesInput = {
    AND?: agendasessionsScalarWhereWithAggregatesInput | agendasessionsScalarWhereWithAggregatesInput[]
    OR?: agendasessionsScalarWhereWithAggregatesInput[]
    NOT?: agendasessionsScalarWhereWithAggregatesInput | agendasessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"agendasessions"> | string
  }

  export type exhibitorsWhereInput = {
    AND?: exhibitorsWhereInput | exhibitorsWhereInput[]
    OR?: exhibitorsWhereInput[]
    NOT?: exhibitorsWhereInput | exhibitorsWhereInput[]
    id?: StringFilter<"exhibitors"> | string
  }

  export type exhibitorsOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type exhibitorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: exhibitorsWhereInput | exhibitorsWhereInput[]
    OR?: exhibitorsWhereInput[]
    NOT?: exhibitorsWhereInput | exhibitorsWhereInput[]
  }, "id">

  export type exhibitorsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: exhibitorsCountOrderByAggregateInput
    _max?: exhibitorsMaxOrderByAggregateInput
    _min?: exhibitorsMinOrderByAggregateInput
  }

  export type exhibitorsScalarWhereWithAggregatesInput = {
    AND?: exhibitorsScalarWhereWithAggregatesInput | exhibitorsScalarWhereWithAggregatesInput[]
    OR?: exhibitorsScalarWhereWithAggregatesInput[]
    NOT?: exhibitorsScalarWhereWithAggregatesInput | exhibitorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"exhibitors"> | string
  }

  export type projectsWhereInput = {
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
    id?: StringFilter<"projects"> | string
  }

  export type projectsOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type projectsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
  }, "id">

  export type projectsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: projectsCountOrderByAggregateInput
    _max?: projectsMaxOrderByAggregateInput
    _min?: projectsMinOrderByAggregateInput
  }

  export type projectsScalarWhereWithAggregatesInput = {
    AND?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    OR?: projectsScalarWhereWithAggregatesInput[]
    NOT?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"projects"> | string
  }

  export type speakersWhereInput = {
    AND?: speakersWhereInput | speakersWhereInput[]
    OR?: speakersWhereInput[]
    NOT?: speakersWhereInput | speakersWhereInput[]
    id?: StringFilter<"speakers"> | string
  }

  export type speakersOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type speakersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: speakersWhereInput | speakersWhereInput[]
    OR?: speakersWhereInput[]
    NOT?: speakersWhereInput | speakersWhereInput[]
  }, "id">

  export type speakersOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: speakersCountOrderByAggregateInput
    _max?: speakersMaxOrderByAggregateInput
    _min?: speakersMinOrderByAggregateInput
  }

  export type speakersScalarWhereWithAggregatesInput = {
    AND?: speakersScalarWhereWithAggregatesInput | speakersScalarWhereWithAggregatesInput[]
    OR?: speakersScalarWhereWithAggregatesInput[]
    NOT?: speakersScalarWhereWithAggregatesInput | speakersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"speakers"> | string
  }

  export type AgendaCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AgendaUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AgendaUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AgendaUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaDayCreateInput = {
    id?: string
    createdAt: Date | string
    date: Date | string
    dayNumber: bigint | number
    name: string
    projectId: string
    updatedAt: Date | string
  }

  export type AgendaDayUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    date: Date | string
    dayNumber: bigint | number
    name: string
    projectId: string
    updatedAt: Date | string
  }

  export type AgendaDayUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaDayUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaDayCreateManyInput = {
    id?: string
    createdAt: Date | string
    date: Date | string
    dayNumber: bigint | number
    name: string
    projectId: string
    updatedAt: Date | string
  }

  export type AgendaDayUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaDayUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemCreateInput = {
    id?: string
    createdAt: Date | string
    description: string
    endTime: string
    sessionId: string
    startTime: string
    title: string
    type: string
    updatedAt: Date | string
  }

  export type AgendaItemUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    description: string
    endTime: string
    sessionId: string
    startTime: string
    title: string
    type: string
    updatedAt: Date | string
  }

  export type AgendaItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemCreateManyInput = {
    id?: string
    createdAt: Date | string
    description: string
    endTime: string
    sessionId: string
    startTime: string
    title: string
    type: string
    updatedAt: Date | string
  }

  export type AgendaItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaItemSpeakerCreateInput = {
    id?: string
    agendaItemId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type AgendaItemSpeakerUncheckedCreateInput = {
    id?: string
    agendaItemId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type AgendaItemSpeakerUpdateInput = {
    agendaItemId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaItemSpeakerUncheckedUpdateInput = {
    agendaItemId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaItemSpeakerCreateManyInput = {
    id?: string
    agendaItemId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type AgendaItemSpeakerUpdateManyMutationInput = {
    agendaItemId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaItemSpeakerUncheckedUpdateManyInput = {
    agendaItemId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type AgendaSessionCreateInput = {
    id?: string
    color: string
    createdAt: Date | string
    dayId: string
    endTime: string
    startTime: string
    title: string
    updatedAt: Date | string
    venue: string
  }

  export type AgendaSessionUncheckedCreateInput = {
    id?: string
    color: string
    createdAt: Date | string
    dayId: string
    endTime: string
    startTime: string
    title: string
    updatedAt: Date | string
    venue: string
  }

  export type AgendaSessionUpdateInput = {
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaSessionUncheckedUpdateInput = {
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaSessionCreateManyInput = {
    id?: string
    color: string
    createdAt: Date | string
    dayId: string
    endTime: string
    startTime: string
    title: string
    updatedAt: Date | string
    venue: string
  }

  export type AgendaSessionUpdateManyMutationInput = {
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaSessionUncheckedUpdateManyInput = {
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayId?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
  }

  export type AttendeeCreateInput = {
    id?: string
    checkedIn: boolean
    checkinTime: Date | string
    company: string
    createdAt: Date | string
    email: string
    jobTitle: string
    name: string
    phone: string
    projectId: string
    updatedAt: Date | string
  }

  export type AttendeeUncheckedCreateInput = {
    id?: string
    checkedIn: boolean
    checkinTime: Date | string
    company: string
    createdAt: Date | string
    email: string
    jobTitle: string
    name: string
    phone: string
    projectId: string
    updatedAt: Date | string
  }

  export type AttendeeUpdateInput = {
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUncheckedUpdateInput = {
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeCreateManyInput = {
    id?: string
    checkedIn: boolean
    checkinTime: Date | string
    company: string
    createdAt: Date | string
    email: string
    jobTitle: string
    name: string
    phone: string
    projectId: string
    updatedAt: Date | string
  }

  export type AttendeeUpdateManyMutationInput = {
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeeUncheckedUpdateManyInput = {
    checkedIn?: BoolFieldUpdateOperationsInput | boolean
    checkinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendeesCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AttendeesUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AttendeesUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AttendeesUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AttendeesCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type AttendeesUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type AttendeesUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type CampaignCreateInput = {
    id?: string
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
  }

  export type CampaignUpdateInput = {

  }

  export type CampaignUncheckedUpdateInput = {

  }

  export type CampaignCreateManyInput = {
    id?: string
  }

  export type CampaignUpdateManyMutationInput = {

  }

  export type CampaignUncheckedUpdateManyInput = {

  }

  export type ContactRequestCreateInput = {
    id?: string
  }

  export type ContactRequestUncheckedCreateInput = {
    id?: string
  }

  export type ContactRequestUpdateInput = {

  }

  export type ContactRequestUncheckedUpdateInput = {

  }

  export type ContactRequestCreateManyInput = {
    id?: string
  }

  export type ContactRequestUpdateManyMutationInput = {

  }

  export type ContactRequestUncheckedUpdateManyInput = {

  }

  export type DelegateCreateInput = {
    id?: string
    address: string
    booth: string
    company: string
    createdAt: Date | string
    description: string
    email: string
    featured: boolean
    image: string
    jobTitle: string
    name: string
    phone: string
    priority: bigint | number
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
  }

  export type DelegateUncheckedCreateInput = {
    id?: string
    address: string
    booth: string
    company: string
    createdAt: Date | string
    description: string
    email: string
    featured: boolean
    image: string
    jobTitle: string
    name: string
    phone: string
    priority: bigint | number
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
  }

  export type DelegateUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    booth?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUncheckedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    booth?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateCreateManyInput = {
    id?: string
    address: string
    booth: string
    company: string
    createdAt: Date | string
    description: string
    email: string
    featured: boolean
    image: string
    jobTitle: string
    name: string
    phone: string
    priority: bigint | number
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
  }

  export type DelegateUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    booth?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegateUncheckedUpdateManyInput = {
    address?: StringFieldUpdateOperationsInput | string
    booth?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    featured?: BoolFieldUpdateOperationsInput | boolean
    image?: StringFieldUpdateOperationsInput | string
    jobTitle?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelegatesCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type DelegatesUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type DelegatesUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type DelegatesUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type DelegatesCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type DelegatesUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type DelegatesUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type DiscountCreateInput = {
    id?: string
    code?: InputJsonValue | null
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    code?: InputJsonValue | null
  }

  export type DiscountUpdateInput = {
    code?: InputJsonValue | InputJsonValue | null
  }

  export type DiscountUncheckedUpdateInput = {
    code?: InputJsonValue | InputJsonValue | null
  }

  export type DiscountCreateManyInput = {
    id?: string
    code?: InputJsonValue | null
  }

  export type DiscountUpdateManyMutationInput = {
    code?: InputJsonValue | InputJsonValue | null
  }

  export type DiscountUncheckedUpdateManyInput = {
    code?: InputJsonValue | InputJsonValue | null
  }

  export type EnquiryCreateInput = {
    id?: string
  }

  export type EnquiryUncheckedCreateInput = {
    id?: string
  }

  export type EnquiryUpdateInput = {

  }

  export type EnquiryUncheckedUpdateInput = {

  }

  export type EnquiryCreateManyInput = {
    id?: string
  }

  export type EnquiryUpdateManyMutationInput = {

  }

  export type EnquiryUncheckedUpdateManyInput = {

  }

  export type ExhibitorCreateInput = {
    id?: string
    boothNumber: string
    category: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    size: string
    status: string
    updatedAt: Date | string
  }

  export type ExhibitorUncheckedCreateInput = {
    id?: string
    boothNumber: string
    category: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    size: string
    status: string
    updatedAt: Date | string
  }

  export type ExhibitorUpdateInput = {
    boothNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUncheckedUpdateInput = {
    boothNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorCreateManyInput = {
    id?: string
    boothNumber: string
    category: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    size: string
    status: string
    updatedAt: Date | string
  }

  export type ExhibitorUpdateManyMutationInput = {
    boothNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorUncheckedUpdateManyInput = {
    boothNumber?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExhibitorsCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type ExhibitorsUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type ExhibitorsUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type ExhibitorsUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type ExhibitorsCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type ExhibitorsUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type ExhibitorsUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type LeadCreateInput = {
    id?: string
  }

  export type LeadUncheckedCreateInput = {
    id?: string
  }

  export type LeadUpdateInput = {

  }

  export type LeadUncheckedUpdateInput = {

  }

  export type LeadCreateManyInput = {
    id?: string
  }

  export type LeadUpdateManyMutationInput = {

  }

  export type LeadUncheckedUpdateManyInput = {

  }

  export type MarketingCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type MarketingUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type MarketingUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type MarketingUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type MarketingCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type MarketingUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type MarketingUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type MarketingCampaignCreateInput = {
    id?: string
  }

  export type MarketingCampaignUncheckedCreateInput = {
    id?: string
  }

  export type MarketingCampaignUpdateInput = {

  }

  export type MarketingCampaignUncheckedUpdateInput = {

  }

  export type MarketingCampaignCreateManyInput = {
    id?: string
  }

  export type MarketingCampaignUpdateManyMutationInput = {

  }

  export type MarketingCampaignUncheckedUpdateManyInput = {

  }

  export type MediaPartnerCreateInput = {
    id?: string
    createdAt: Date | string
    image: string
    name: string
    priority: bigint | number
    projectId: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type MediaPartnerUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    image: string
    name: string
    priority: bigint | number
    projectId: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type MediaPartnerUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type MediaPartnerUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type MediaPartnerCreateManyInput = {
    id?: string
    createdAt: Date | string
    image: string
    name: string
    priority: bigint | number
    projectId: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type MediaPartnerUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type MediaPartnerUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    priority?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateInput = {
    id?: string
  }

  export type OrderUncheckedCreateInput = {
    id?: string
  }

  export type OrderUpdateInput = {

  }

  export type OrderUncheckedUpdateInput = {

  }

  export type OrderCreateManyInput = {
    id?: string
  }

  export type OrderUpdateManyMutationInput = {

  }

  export type OrderUncheckedUpdateManyInput = {

  }

  export type PackageCreateInput = {
    id?: string
  }

  export type PackageUncheckedCreateInput = {
    id?: string
  }

  export type PackageUpdateInput = {

  }

  export type PackageUncheckedUpdateInput = {

  }

  export type PackageCreateManyInput = {
    id?: string
  }

  export type PackageUpdateManyMutationInput = {

  }

  export type PackageUncheckedUpdateManyInput = {

  }

  export type PartnerCreateInput = {
    id?: string
    contribution: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    contribution: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type PartnerUpdateInput = {
    contribution?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type PartnerUncheckedUpdateInput = {
    contribution?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type PartnerCreateManyInput = {
    id?: string
    contribution: string
    createdAt: Date | string
    image: string
    name: string
    projectId: string
    status: string
    type: string
    updatedAt: Date | string
    website: string
  }

  export type PartnerUpdateManyMutationInput = {
    contribution?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    contribution?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    website?: StringFieldUpdateOperationsInput | string
  }

  export type PartnersCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type PartnersUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type PartnersUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type PartnersUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type PartnersCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type PartnersUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type PartnersUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type ProjectCreateInput = {
    id?: string
    createdAt: Date | string
    currency: string
    description: string
    endDate?: Date | string | null
    name: string
    startDate?: Date | string | null
    updatedAt: Date | string
    venue: string
    website: string
    year: string
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    currency: string
    description: string
    endDate?: Date | string | null
    name: string
    startDate?: Date | string | null
    updatedAt: Date | string
    venue: string
    website: string
    year: string
  }

  export type ProjectUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyInput = {
    id?: string
    createdAt: Date | string
    currency: string
    description: string
    endDate?: Date | string | null
    name: string
    startDate?: Date | string | null
    updatedAt: Date | string
    venue: string
    website: string
    year: string
  }

  export type ProjectUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    website?: StringFieldUpdateOperationsInput | string
    year?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectStatsCreateInput = {
    id?: string
    createdAt: Date | string
    delegates: bigint | number
    exhibitors: bigint | number
    mediaPartners: bigint | number
    partners: bigint | number
    projectId: string
    speakers: bigint | number
    sponsors: bigint | number
    updatedAt: Date | string
  }

  export type ProjectStatsUncheckedCreateInput = {
    id?: string
    createdAt: Date | string
    delegates: bigint | number
    exhibitors: bigint | number
    mediaPartners: bigint | number
    partners: bigint | number
    projectId: string
    speakers: bigint | number
    sponsors: bigint | number
    updatedAt: Date | string
  }

  export type ProjectStatsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delegates?: BigIntFieldUpdateOperationsInput | bigint | number
    exhibitors?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaPartners?: BigIntFieldUpdateOperationsInput | bigint | number
    partners?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    speakers?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsors?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delegates?: BigIntFieldUpdateOperationsInput | bigint | number
    exhibitors?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaPartners?: BigIntFieldUpdateOperationsInput | bigint | number
    partners?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    speakers?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsors?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsCreateManyInput = {
    id?: string
    createdAt: Date | string
    delegates: bigint | number
    exhibitors: bigint | number
    mediaPartners: bigint | number
    partners: bigint | number
    projectId: string
    speakers: bigint | number
    sponsors: bigint | number
    updatedAt: Date | string
  }

  export type ProjectStatsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delegates?: BigIntFieldUpdateOperationsInput | bigint | number
    exhibitors?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaPartners?: BigIntFieldUpdateOperationsInput | bigint | number
    partners?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    speakers?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsors?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectStatsUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delegates?: BigIntFieldUpdateOperationsInput | bigint | number
    exhibitors?: BigIntFieldUpdateOperationsInput | bigint | number
    mediaPartners?: BigIntFieldUpdateOperationsInput | bigint | number
    partners?: BigIntFieldUpdateOperationsInput | bigint | number
    projectId?: StringFieldUpdateOperationsInput | string
    speakers?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsors?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
  }

  export type SessionUncheckedCreateInput = {
    id?: string
  }

  export type SessionUpdateInput = {

  }

  export type SessionUncheckedUpdateInput = {

  }

  export type SessionCreateManyInput = {
    id?: string
  }

  export type SessionUpdateManyMutationInput = {

  }

  export type SessionUncheckedUpdateManyInput = {

  }

  export type SpeakerCreateInput = {
    id?: string
  }

  export type SpeakerUncheckedCreateInput = {
    id?: string
  }

  export type SpeakerUpdateInput = {

  }

  export type SpeakerUncheckedUpdateInput = {

  }

  export type SpeakerCreateManyInput = {
    id?: string
  }

  export type SpeakerUpdateManyMutationInput = {

  }

  export type SpeakerUncheckedUpdateManyInput = {

  }

  export type SpeakerSessionCreateInput = {
    id?: string
    sessionId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type SpeakerSessionUncheckedCreateInput = {
    id?: string
    sessionId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type SpeakerSessionUpdateInput = {
    sessionId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakerSessionUncheckedUpdateInput = {
    sessionId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakerSessionCreateManyInput = {
    id?: string
    sessionId?: InputJsonValue | null
    speakerId?: InputJsonValue | null
  }

  export type SpeakerSessionUpdateManyMutationInput = {
    sessionId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakerSessionUncheckedUpdateManyInput = {
    sessionId?: InputJsonValue | InputJsonValue | null
    speakerId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakersCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SpeakersUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SpeakersUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakersUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakersCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SpeakersUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SpeakersUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SponsorCreateInput = {
    id?: string
  }

  export type SponsorUncheckedCreateInput = {
    id?: string
  }

  export type SponsorUpdateInput = {

  }

  export type SponsorUncheckedUpdateInput = {

  }

  export type SponsorCreateManyInput = {
    id?: string
  }

  export type SponsorUpdateManyMutationInput = {

  }

  export type SponsorUncheckedUpdateManyInput = {

  }

  export type SponsorsCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SponsorsUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SponsorsUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SponsorsUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SponsorsCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type SponsorsUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type SponsorsUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type TicketCreateInput = {
    id?: string
  }

  export type TicketUncheckedCreateInput = {
    id?: string
  }

  export type TicketUpdateInput = {

  }

  export type TicketUncheckedUpdateInput = {

  }

  export type TicketCreateManyInput = {
    id?: string
  }

  export type TicketUpdateManyMutationInput = {

  }

  export type TicketUncheckedUpdateManyInput = {

  }

  export type TicketingCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type TicketingUncheckedCreateInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type TicketingUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type TicketingUncheckedUpdateInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type TicketingCreateManyInput = {
    id?: string
    projectId?: InputJsonValue | null
  }

  export type TicketingUpdateManyMutationInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type TicketingUncheckedUpdateManyInput = {
    projectId?: InputJsonValue | InputJsonValue | null
  }

  export type UserCreateInput = {
    id?: string
    email?: InputJsonValue | null
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: InputJsonValue | null
  }

  export type UserUpdateInput = {
    email?: InputJsonValue | InputJsonValue | null
  }

  export type UserUncheckedUpdateInput = {
    email?: InputJsonValue | InputJsonValue | null
  }

  export type UserCreateManyInput = {
    id?: string
    email?: InputJsonValue | null
  }

  export type UserUpdateManyMutationInput = {
    email?: InputJsonValue | InputJsonValue | null
  }

  export type UserUncheckedUpdateManyInput = {
    email?: InputJsonValue | InputJsonValue | null
  }

  export type UtmDataCreateInput = {
    id?: string
    campaign: string
    content: string
    conversions: bigint | number
    createdAt: Date | string
    medium: string
    name: string
    projectId: string
    source: string
    term: string
    updatedAt: Date | string
    visits: bigint | number
    websiteUrl: string
  }

  export type UtmDataUncheckedCreateInput = {
    id?: string
    campaign: string
    content: string
    conversions: bigint | number
    createdAt: Date | string
    medium: string
    name: string
    projectId: string
    source: string
    term: string
    updatedAt: Date | string
    visits: bigint | number
    websiteUrl: string
  }

  export type UtmDataUpdateInput = {
    campaign?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversions?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medium?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: BigIntFieldUpdateOperationsInput | bigint | number
    websiteUrl?: StringFieldUpdateOperationsInput | string
  }

  export type UtmDataUncheckedUpdateInput = {
    campaign?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversions?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medium?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: BigIntFieldUpdateOperationsInput | bigint | number
    websiteUrl?: StringFieldUpdateOperationsInput | string
  }

  export type UtmDataCreateManyInput = {
    id?: string
    campaign: string
    content: string
    conversions: bigint | number
    createdAt: Date | string
    medium: string
    name: string
    projectId: string
    source: string
    term: string
    updatedAt: Date | string
    visits: bigint | number
    websiteUrl: string
  }

  export type UtmDataUpdateManyMutationInput = {
    campaign?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversions?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medium?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: BigIntFieldUpdateOperationsInput | bigint | number
    websiteUrl?: StringFieldUpdateOperationsInput | string
  }

  export type UtmDataUncheckedUpdateManyInput = {
    campaign?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversions?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medium?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: BigIntFieldUpdateOperationsInput | bigint | number
    websiteUrl?: StringFieldUpdateOperationsInput | string
  }

  export type agendadaysCreateInput = {
    id?: string
    v: number
    date: Date | string
    dayNumber: number
    name: string
  }

  export type agendadaysUncheckedCreateInput = {
    id?: string
    v: number
    date: Date | string
    dayNumber: number
    name: string
  }

  export type agendadaysUpdateInput = {
    v?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type agendadaysUncheckedUpdateInput = {
    v?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type agendadaysCreateManyInput = {
    id?: string
    v: number
    date: Date | string
    dayNumber: number
    name: string
  }

  export type agendadaysUpdateManyMutationInput = {
    v?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type agendadaysUncheckedUpdateManyInput = {
    v?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type agendaitemsCreateInput = {
    id?: string
  }

  export type agendaitemsUncheckedCreateInput = {
    id?: string
  }

  export type agendaitemsUpdateInput = {

  }

  export type agendaitemsUncheckedUpdateInput = {

  }

  export type agendaitemsCreateManyInput = {
    id?: string
  }

  export type agendaitemsUpdateManyMutationInput = {

  }

  export type agendaitemsUncheckedUpdateManyInput = {

  }

  export type agendaitemspeakersCreateInput = {
    id?: string
  }

  export type agendaitemspeakersUncheckedCreateInput = {
    id?: string
  }

  export type agendaitemspeakersUpdateInput = {

  }

  export type agendaitemspeakersUncheckedUpdateInput = {

  }

  export type agendaitemspeakersCreateManyInput = {
    id?: string
  }

  export type agendaitemspeakersUpdateManyMutationInput = {

  }

  export type agendaitemspeakersUncheckedUpdateManyInput = {

  }

  export type agendasessionsCreateInput = {
    id?: string
  }

  export type agendasessionsUncheckedCreateInput = {
    id?: string
  }

  export type agendasessionsUpdateInput = {

  }

  export type agendasessionsUncheckedUpdateInput = {

  }

  export type agendasessionsCreateManyInput = {
    id?: string
  }

  export type agendasessionsUpdateManyMutationInput = {

  }

  export type agendasessionsUncheckedUpdateManyInput = {

  }

  export type exhibitorsCreateInput = {
    id?: string
  }

  export type exhibitorsUncheckedCreateInput = {
    id?: string
  }

  export type exhibitorsUpdateInput = {

  }

  export type exhibitorsUncheckedUpdateInput = {

  }

  export type exhibitorsCreateManyInput = {
    id?: string
  }

  export type exhibitorsUpdateManyMutationInput = {

  }

  export type exhibitorsUncheckedUpdateManyInput = {

  }

  export type projectsCreateInput = {
    id?: string
  }

  export type projectsUncheckedCreateInput = {
    id?: string
  }

  export type projectsUpdateInput = {

  }

  export type projectsUncheckedUpdateInput = {

  }

  export type projectsCreateManyInput = {
    id?: string
  }

  export type projectsUpdateManyMutationInput = {

  }

  export type projectsUncheckedUpdateManyInput = {

  }

  export type speakersCreateInput = {
    id?: string
  }

  export type speakersUncheckedCreateInput = {
    id?: string
  }

  export type speakersUpdateInput = {

  }

  export type speakersUncheckedUpdateInput = {

  }

  export type speakersCreateManyInput = {
    id?: string
  }

  export type speakersUpdateManyMutationInput = {

  }

  export type speakersUncheckedUpdateManyInput = {

  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type AgendaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type AgendaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgendaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type AgendaDayCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaDayAvgOrderByAggregateInput = {
    dayNumber?: SortOrder
  }

  export type AgendaDayMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaDayMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaDaySumOrderByAggregateInput = {
    dayNumber?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type AgendaItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    endTime?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    endTime?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    endTime?: SortOrder
    sessionId?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgendaItemSpeakerAgendaItemIdSpeakerIdCompoundUniqueInput = {
    agendaItemId: InputJsonValue
    speakerId: InputJsonValue
  }

  export type AgendaItemSpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    agendaItemId?: SortOrder
    speakerId?: SortOrder
  }

  export type AgendaItemSpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgendaItemSpeakerMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgendaSessionCountOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    dayId?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
  }

  export type AgendaSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    dayId?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
  }

  export type AgendaSessionMinOrderByAggregateInput = {
    id?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    dayId?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AttendeeCountOrderByAggregateInput = {
    id?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendeeMaxOrderByAggregateInput = {
    id?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendeeMinOrderByAggregateInput = {
    id?: SortOrder
    checkedIn?: SortOrder
    checkinTime?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AttendeesCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type AttendeesMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AttendeesMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactRequestCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactRequestMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactRequestMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DelegateCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    email?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelegateAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type DelegateMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    email?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelegateMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    booth?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    email?: SortOrder
    featured?: SortOrder
    image?: SortOrder
    jobTitle?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelegateSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type DelegatesCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type DelegatesMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DelegatesMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnquiryCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnquiryMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnquiryMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExhibitorCountOrderByAggregateInput = {
    id?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExhibitorMaxOrderByAggregateInput = {
    id?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExhibitorMinOrderByAggregateInput = {
    id?: SortOrder
    boothNumber?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    size?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExhibitorsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ExhibitorsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ExhibitorsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type MarketingMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingCampaignCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingCampaignMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MediaPartnerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type MediaPartnerAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type MediaPartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type MediaPartnerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    projectId?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type MediaPartnerSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    contribution?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    website?: SortOrder
  }

  export type PartnersCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PartnersMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PartnersMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    year?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    year?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    endDate?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    updatedAt?: SortOrder
    venue?: SortOrder
    website?: SortOrder
    year?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ProjectStatsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    projectId?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatsAvgOrderByAggregateInput = {
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
  }

  export type ProjectStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    projectId?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    projectId?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectStatsSumOrderByAggregateInput = {
    delegates?: SortOrder
    exhibitors?: SortOrder
    mediaPartners?: SortOrder
    partners?: SortOrder
    speakers?: SortOrder
    sponsors?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerSessionSpeakerIdSessionIdCompoundUniqueInput = {
    speakerId: InputJsonValue
    sessionId: InputJsonValue
  }

  export type SpeakerSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SpeakerSessionMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerSessionMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakersCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SpeakersMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakersMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorsCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type SponsorsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SponsorsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketingCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TicketingMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TicketingMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UtmDataCountOrderByAggregateInput = {
    id?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    medium?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    source?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    websiteUrl?: SortOrder
  }

  export type UtmDataAvgOrderByAggregateInput = {
    conversions?: SortOrder
    visits?: SortOrder
  }

  export type UtmDataMaxOrderByAggregateInput = {
    id?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    medium?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    source?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    websiteUrl?: SortOrder
  }

  export type UtmDataMinOrderByAggregateInput = {
    id?: SortOrder
    campaign?: SortOrder
    content?: SortOrder
    conversions?: SortOrder
    createdAt?: SortOrder
    medium?: SortOrder
    name?: SortOrder
    projectId?: SortOrder
    source?: SortOrder
    term?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    websiteUrl?: SortOrder
  }

  export type UtmDataSumOrderByAggregateInput = {
    conversions?: SortOrder
    visits?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type agendadaysCountOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
  }

  export type agendadaysAvgOrderByAggregateInput = {
    v?: SortOrder
    dayNumber?: SortOrder
  }

  export type agendadaysMaxOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
  }

  export type agendadaysMinOrderByAggregateInput = {
    id?: SortOrder
    v?: SortOrder
    date?: SortOrder
    dayNumber?: SortOrder
    name?: SortOrder
  }

  export type agendadaysSumOrderByAggregateInput = {
    v?: SortOrder
    dayNumber?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type agendaitemsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendaitemsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendaitemsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendaitemspeakersCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendaitemspeakersMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendaitemspeakersMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendasessionsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendasessionsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agendasessionsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type exhibitorsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type exhibitorsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type exhibitorsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type projectsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type projectsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type projectsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type speakersCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type speakersMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type speakersMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}